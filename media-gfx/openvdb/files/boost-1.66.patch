From ffb02d5527379a08c07449e39d3324ac2e5eff28 Mon Sep 17 00:00:00 2001
From: Peter Cucka <peter.cucka@dreamworks.com>
Date: Thu, 21 Sep 2017 11:05:42 -0700
Subject: [PATCH] Boost 1.65 NumPy support; Houdini 16.5 compatibility;
 ParmFactory::setAttrChoiceList()

---
 openvdb/CHANGES                                 |   7 +
 openvdb/doc/changes.txt                         |   8 +
 openvdb/math/Transform.h                        |   6 +-
 openvdb/python/pyFloatGrid.cc                   |   2 +
 openvdb/python/pyGrid.h                         | 585 +++++++++++++++---------
 openvdb/python/pyOpenVDBModule.cc               |  52 ++-
 openvdb/python/test/TestOpenVDB.py              |  12 +-
 openvdb/tools/Filter.h                          |  73 +--
 openvdb/tools/LevelSetAdvect.h                  |  71 +--
 openvdb/tools/LevelSetFilter.h                  | 112 +++--
 openvdb/tools/LevelSetMorph.h                   |  61 +--
 openvdb/tools/LevelSetTracker.h                 |  57 +--
 openvdb/tools/ParticlesToLevelSet.h             |  97 ++--
 openvdb/tools/VolumeAdvect.h                    | 105 ++---
 openvdb_houdini/houdini/AttributeTransferUtil.h |   2 +
 openvdb_houdini/houdini/ParmFactory.cc          | 230 +++++++++-
 openvdb_houdini/houdini/ParmFactory.h           |  87 +++-
 openvdb_houdini/houdini/SOP_OpenVDB_Fracture.cc |   1 -
 18 files changed, 1005 insertions(+), 563 deletions(-)

diff --git a/openvdb/CHANGES b/openvdb/CHANGES
index dc35b2ab..5b23d5e1 100644
--- a/openvdb/CHANGES
+++ b/openvdb/CHANGES
@@ -47,15 +47,22 @@ Version 5.0.0 - In development
       and ABI version numbers, respectively), but only when the library
       is built using an older ABI version.
 
+    Python:
+    - Reimplemented NumPy support for Boost 1.65 compatibility.
+
     Houdini:
     - Fixed bugs that caused the Ray SOP's closest surface point searches
       to produce incorrect results.
     - Changed the VdbPrimCIterator::FilterFunc type from boost::function
       to std::function.
+    - Changed the houdini_utils::OpPolicyPtr type from boost:shared_ptr
+      to std::shared_ptr.
     - Debug-level log messages generated by OpenVDB are no longer forwarded
       to Houdini's error manager.
     - Fixed a bug in the Read SOP that made it impossible to select among
       grids of the same name in a file.
+    - Added houdini_utils::ParmFactory::setAttrChoiceList(), a convenience
+      method for the creation of menus of attributes.
     - Added a Potential Flow SOP.
       [Contributed by Double Negative]
 
diff --git a/openvdb/doc/changes.txt b/openvdb/doc/changes.txt
index 960b7aa0..5b0feafd 100644
--- a/openvdb/doc/changes.txt
+++ b/openvdb/doc/changes.txt
@@ -68,16 +68,24 @@ API changes:
   and ABI version numbers, respectively), but only when the library
   is built using an older ABI version.
 
+@par
+Python:
+- Reimplemented NumPy support for Boost&nbsp;1.65 compatibility.
+
 @par
 Houdini:
 - Fixed bugs that caused the Ray&nbsp;SOP&rsquo;s closest surface point
   searches to produce incorrect results.
 - Changed the @b VdbPrimCIterator::FilterFunc type from @b boost::function
   to @b std::function.
+- Changed the @b houdini_utils::OpPolicyPtr type from @b boost:shared_ptr
+  to @b std::shared_ptr.
 - Debug-level log messages generated by OpenVDB are no longer forwarded
   to Houdini&rsquo;s error manager.
 - Fixed a bug in the Read&nbsp;SOP that made it impossible to select among
   grids of the same name in a file.
+- Added @b houdini_utils::ParmFactory::setAttrChoiceList, a convenience
+  method for the creation of menus of attributes.
 - Added a Potential&nbsp;Flow&nbsp;SOP.
   <I>[Contributed&nbsp;by&nbsp;Double&nbsp;Negative]</I>
 
diff --git a/openvdb/math/Transform.h b/openvdb/math/Transform.h
index 2f47824a..a23ec525 100644
--- a/openvdb/math/Transform.h
+++ b/openvdb/math/Transform.h
@@ -53,10 +53,10 @@ OPENVDB_API void
 calculateBounds(const Transform& t, const Vec3d& minWS, const Vec3d& maxWS,
     Vec3d& minIS, Vec3d& maxIS);
 
-/// @brief Calculate an axis-aligned bounding box in index space from a
+/// @todo Calculate an axis-aligned bounding box in index space from a
 /// bounding sphere in world space.
-/// @todo void calculateBounds(const Transform& t, const Vec3d& center, const Real radius,
-///     Vec3d& minIS, Vec3d& maxIS);
+//void calculateBounds(const Transform& t, const Vec3d& center, const Real radius,
+//    Vec3d& minIS, Vec3d& maxIS);
 
 
 ////////////////////////////////////////
diff --git a/openvdb/python/pyFloatGrid.cc b/openvdb/python/pyFloatGrid.cc
index e5686b20..1adbba2f 100644
--- a/openvdb/python/pyFloatGrid.cc
+++ b/openvdb/python/pyFloatGrid.cc
@@ -45,9 +45,11 @@ exportFloatGrid()
     // Add a module-level list that gives the types of all supported Grid classes.
     py::scope().attr("GridTypes") = py::list();
 
+#if BOOST_VERSION < 106500
     // Specify that py::numeric::array should refer to the Python type numpy.ndarray
     // (rather than the older Numeric.array).
     py::numeric::array::set_module_and_type("numpy", "ndarray");
+#endif
 
     pyGrid::exportGrid<FloatGrid>();
 #ifdef PY_OPENVDB_WRAP_ALL_GRID_TYPES
diff --git a/openvdb/python/pyGrid.h b/openvdb/python/pyGrid.h
index f1a01d92..d5fc7e10 100644
--- a/openvdb/python/pyGrid.h
+++ b/openvdb/python/pyGrid.h
@@ -43,15 +43,23 @@
 #define DWA_BOOST_VERSION (10 * BOOST_VERSION)
 #endif
 #ifdef PY_OPENVDB_USE_NUMPY
-#define PY_ARRAY_UNIQUE_SYMBOL PY_OPENVDB_ARRAY_API
-#define NO_IMPORT_ARRAY // NumPy gets initialized during module initialization
-#include <numpyconfig.h>
-#ifdef NPY_1_7_API_VERSION
-#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
-#endif
-#include <arrayobject.h> // for PyArrayObject
-#include "openvdb/tools/MeshToVolume.h"
-#include "openvdb/tools/VolumeToMesh.h" // for tools::volumeToMesh()
+  #if DWA_BOOST_VERSION >= 1065000
+    // boost::python::numeric was replaced with boost::python::numpy in Boost 1.65.
+    // (boost::python::numpy requires NumPy 1.7 or later.)
+    #include <boost/python/numpy.hpp>
+    //#include <arrayobject.h> // for PyArray_Descr (see pyGrid::arrayTypeId())
+    #define PY_OPENVDB_USE_BOOST_PYTHON_NUMPY
+  #else
+    #define PY_ARRAY_UNIQUE_SYMBOL PY_OPENVDB_ARRAY_API
+    #define NO_IMPORT_ARRAY // NumPy gets initialized during module initialization
+    #include <numpyconfig.h>
+    #ifdef NPY_1_7_API_VERSION
+      #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
+    #endif
+    #include <arrayobject.h> // for PyArrayObject
+  #endif
+  #include "openvdb/tools/MeshToVolume.h"
+  #include "openvdb/tools/VolumeToMesh.h" // for tools::volumeToMesh()
 #endif
 #include "openvdb/openvdb.h"
 #include "openvdb/io/Stream.h"
@@ -64,8 +72,12 @@
 #include "pyutil.h"
 #include "pyAccessor.h" // for pyAccessor::AccessorWrap
 #include "pyopenvdb.h"
+#include <algorithm> // for std::max()
 #include <cstring> // for memcpy()
+#include <iostream>
 #include <sstream>
+#include <string>
+#include <vector>
 
 namespace py = boost::python;
 
@@ -199,7 +211,7 @@ extractValueArg(
     py::object obj,
     const char* functionName,
     int argIdx = 0, // args are numbered starting from 1
-    const char* expectedType = NULL)
+    const char* expectedType = nullptr)
 {
     return pyutil::extractArg<T>(obj,
         functionName, pyutil::GridTraits<GridType>::name(), argIdx, expectedType);
@@ -214,7 +226,7 @@ extractValueArg(
     py::object obj,
     const char* functionName,
     int argIdx = 0, // args are numbered starting from 1
-    const char* expectedType = NULL)
+    const char* expectedType = nullptr)
 {
     return extractValueArg<GridType, typename GridType::ValueType>(
         obj, functionName, argIdx, expectedType);
@@ -268,7 +280,7 @@ template<typename GridType>
 inline typename GridType::ValueType
 getOneValue()
 {
-    typedef typename GridType::ValueType ValueT;
+    using ValueT = typename GridType::ValueType;
     return ValueT(openvdb::zeroVal<ValueT>() + 1);
 }
 
@@ -305,7 +317,7 @@ setGridName(GridBase::Ptr grid, py::object strObj)
             grid->removeMeta(GridBase::META_GRID_NAME);
         } else {
             const std::string name = pyutil::extractArg<std::string>(
-                strObj, "setName", /*className=*/NULL, /*argIdx=*/1, "str");
+                strObj, "setName", /*className=*/nullptr, /*argIdx=*/1, "str");
             grid->setName(name);
         }
     }
@@ -320,7 +332,7 @@ setGridCreator(GridBase::Ptr grid, py::object strObj)
             grid->removeMeta(GridBase::META_GRID_CREATOR);
         } else {
             const std::string name = pyutil::extractArg<std::string>(
-                strObj, "setCreator", /*className=*/NULL, /*argIdx=*/1, "str");
+                strObj, "setCreator", /*className=*/nullptr, /*argIdx=*/1, "str");
             grid->setCreator(name);
         }
     }
@@ -341,7 +353,7 @@ setGridClass(GridBase::Ptr grid, py::object strObj)
         grid->clearGridClass();
     } else {
         const std::string name = pyutil::extractArg<std::string>(
-            strObj, "setGridClass", /*className=*/NULL, /*argIdx=*/1, "str");
+            strObj, "setGridClass", /*className=*/nullptr, /*argIdx=*/1, "str");
         grid->setGridClass(GridBase::stringToGridClass(name));
     }
 }
@@ -361,7 +373,7 @@ setVecType(GridBase::Ptr grid, py::object strObj)
         grid->clearVectorType();
     } else {
         const std::string name = pyutil::extractArg<std::string>(
-            strObj, "setVectorType", /*className=*/NULL, /*argIdx=*/1, "str");
+            strObj, "setVectorType", /*className=*/nullptr, /*argIdx=*/1, "str");
         grid->setVectorType(GridBase::stringToVecType(name));
     }
 }
@@ -384,7 +396,7 @@ setGridTransform(GridBase::Ptr grid, py::object xformObj)
 {
     if (grid) {
         if (math::Transform::Ptr xform = pyutil::extractArg<math::Transform::Ptr>(
-            xformObj, "setTransform", /*className=*/NULL, /*argIdx=*/1, "Transform"))
+            xformObj, "setTransform", /*className=*/nullptr, /*argIdx=*/1, "Transform"))
         {
             grid->setTransform(xform);
         } else {
@@ -403,7 +415,7 @@ setGridTransform(GridBase::Ptr grid, py::object xformObj)
 template<typename GridType>
 struct AccessorHelper
 {
-    typedef typename pyAccessor::AccessorWrap<GridType> Wrapper;
+    using Wrapper = typename pyAccessor::AccessorWrap<GridType>;
     static Wrapper wrap(typename GridType::Ptr grid)
     {
         if (!grid) {
@@ -418,7 +430,7 @@ struct AccessorHelper
 template<typename GridType>
 struct AccessorHelper<const GridType>
 {
-    typedef typename pyAccessor::AccessorWrap<const GridType> Wrapper;
+    using Wrapper = typename pyAccessor::AccessorWrap<const GridType>;
     static Wrapper wrap(typename GridType::ConstPtr grid)
     {
         if (!grid) {
@@ -630,7 +642,7 @@ getMetadata(GridBase::ConstPtr grid, py::object nameObj)
     if (!grid) return py::object();
 
     const std::string name = pyutil::extractArg<std::string>(
-        nameObj, "__getitem__", NULL, /*argIdx=*/1, "str");
+        nameObj, "__getitem__", nullptr, /*argIdx=*/1, "str");
 
     Metadata::ConstPtr metadata = (*grid)[name];
     if (!metadata) {
@@ -654,7 +666,7 @@ setMetadata(GridBase::Ptr grid, py::object nameObj, py::object valueObj)
     if (!grid) return;
 
     const std::string name = pyutil::extractArg<std::string>(
-        nameObj, "__setitem__", NULL, /*argIdx=*/1, "str");
+        nameObj, "__setitem__", nullptr, /*argIdx=*/1, "str");
 
     // Insert the Python object into a Python dict, then use the dict-to-MetaMap
     // converter (see pyOpenVDBModule.cc) to convert the dict to a MetaMap
@@ -689,7 +701,7 @@ removeMetadata(GridBase::Ptr grid, const std::string& name)
 inline bool
 hasMetadata(GridBase::ConstPtr grid, const std::string& name)
 {
-    if (grid) return ((*grid)[name].get() != NULL);
+    if (grid) return ((*grid)[name].get() != nullptr);
     return false;
 }
 
@@ -761,29 +773,160 @@ copyToArray(GridType&, const py::object&, py::object)
 
 #else // if defined(PY_OPENVDB_USE_NUMPY)
 
-template<int TypeNum> struct NumPyToCpp {};
-//template<> struct NumPyToCpp<NPY_HALF>   { typedef half type; };
-template<> struct NumPyToCpp<NPY_FLOAT>  { typedef float type; };
-template<> struct NumPyToCpp<NPY_DOUBLE> { typedef double type; };
-template<> struct NumPyToCpp<NPY_BOOL>   { typedef bool type; };
-template<> struct NumPyToCpp<NPY_INT16>  { typedef Int16 type; };
-template<> struct NumPyToCpp<NPY_INT32>  { typedef Int32 type; };
-template<> struct NumPyToCpp<NPY_INT64>  { typedef Int64 type; };
-template<> struct NumPyToCpp<NPY_UINT32> { typedef Index32 type; };
-template<> struct NumPyToCpp<NPY_UINT64> { typedef Index64 type; };
+using ArrayDimVec = std::vector<size_t>;
+
+#ifdef PY_OPENVDB_USE_BOOST_PYTHON_NUMPY
+
+// ID numbers for supported value types
+enum class DtId { NONE, FLOAT, DOUBLE, BOOL, INT16, INT32, INT64, UINT32, UINT64/*, HALF*/ };
+
+using NumPyArrayType = py::numpy::ndarray;
+
+#else // if !defined PY_OPENVDB_USE_BOOST_PYTHON_NUMPY
+
+// NumPy type numbers for supported value types
+enum class DtId {
+    NONE =   NPY_NOTYPE,
+    FLOAT =  NPY_FLOAT,
+    DOUBLE = NPY_DOUBLE,
+    BOOL =   NPY_BOOL,
+    INT16 =  NPY_INT16,
+    INT32 =  NPY_INT32,
+    INT64 =  NPY_INT64,
+    UINT32 = NPY_UINT32,
+    UINT64 = NPY_UINT64,
+    //HALF =   NPY_HALF
+};
+
+using NumPyArrayType = py::numeric::array;
+
+#endif // PY_OPENVDB_USE_BOOST_PYTHON_NUMPY
+
+
+template<DtId TypeId> struct NumPyToCpp {};
+template<> struct NumPyToCpp<DtId::FLOAT>  { using type = float; };
+template<> struct NumPyToCpp<DtId::DOUBLE> { using type = double; };
+template<> struct NumPyToCpp<DtId::BOOL>   { using type = bool; };
+template<> struct NumPyToCpp<DtId::INT16>  { using type = Int16; };
+template<> struct NumPyToCpp<DtId::INT32>  { using type = Int32; };
+template<> struct NumPyToCpp<DtId::INT64>  { using type = Int64; };
+template<> struct NumPyToCpp<DtId::UINT32> { using type = Index32; };
+template<> struct NumPyToCpp<DtId::UINT64> { using type = Index64; };
+//template<> struct NumPyToCpp<DtId::HALF>   { using type = half; };
+
+
+#if 0
+template<typename T> struct CppToNumPy { static const DtId typeId = DtId::NONE; };
+template<> struct CppToNumPy<float>    { static const DtId typeId = DtId::FLOAT; };
+template<> struct CppToNumPy<double>   { static const DtId typeId = DtId::DOUBLE; };
+template<> struct CppToNumPy<bool>     { static const DtId typeId = DtId::BOOL; };
+template<> struct CppToNumPy<Int16>    { static const DtId typeId = DtId::INT16; };
+template<> struct CppToNumPy<Int32>    { static const DtId typeId = DtId::INT32; };
+template<> struct CppToNumPy<Int64>    { static const DtId typeId = DtId::INT64; };
+template<> struct CppToNumPy<Index32>  { static const DtId typeId = DtId::UINT32; };
+template<> struct CppToNumPy<Index64>  { static const DtId typeId = DtId::UINT64; };
+//template<> struct CppToNumPy<half>     { static const DtId typeId = DtId::HALF; };
+#endif
+
+
+#ifdef PY_OPENVDB_USE_BOOST_PYTHON_NUMPY
 
+// Return the ID number of the given NumPy array's data type.
+/// @todo Revisit this if and when py::numpy::dtype ever provides a type number accessor.
+inline DtId
+arrayTypeId(const py::numpy::ndarray& arrayObj)
+{
+    namespace np = py::numpy;
+    const auto dtype = arrayObj.get_dtype();
 #if 0
-template<typename T> struct CppToNumPy {};
-//template<> struct NumPyToCpp<half>     { enum { typenum = NPY_HALF }; };
-template<> struct CppToNumPy<float>    { enum { typenum = NPY_FLOAT }; };
-template<> struct CppToNumPy<double>   { enum { typenum = NPY_DOUBLE }; };
-template<> struct CppToNumPy<bool>     { enum { typenum = NPY_BOOL }; };
-template<> struct CppToNumPy<Int16>    { enum { typenum = NPY_INT16 }; };
-template<> struct CppToNumPy<Int32>    { enum { typenum = NPY_INT32 }; };
-template<> struct CppToNumPy<Int64>    { enum { typenum = NPY_INT64 }; };
-template<> struct CppToNumPy<Index32>  { enum { typenum = NPY_UINT32 }; };
-template<> struct CppToNumPy<Index64>  { enum { typenum = NPY_UINT64 }; };
+    // More efficient than np::equivalent(), but requires NumPy headers.
+    if (const auto* descr = reinterpret_cast<const PyArray_Descr*>(dtype.ptr())) {
+        const auto typeId = static_cast<DtId>(descr->type_num);
+        switch (typeId) {
+            case DtId::NONE: break;
+            case DtId::FLOAT: case DtId::DOUBLE: case DtId::BOOL:
+            case DtId::INT16: case DtId::INT32: case DtId::INT64:
+            case DtId::UINT32: case DtId::UINT64:
+                return typeId;
+        }
+        throw openvdb::TypeError{};
+    }
+#else
+    if (np::equivalent(dtype, np::dtype::get_builtin<float>())) return DtId::FLOAT;
+    if (np::equivalent(dtype, np::dtype::get_builtin<double>())) return DtId::DOUBLE;
+    if (np::equivalent(dtype, np::dtype::get_builtin<bool>())) return DtId::BOOL;
+    if (np::equivalent(dtype, np::dtype::get_builtin<Int16>())) return DtId::INT16;
+    if (np::equivalent(dtype, np::dtype::get_builtin<Int32>())) return DtId::INT32;
+    if (np::equivalent(dtype, np::dtype::get_builtin<Int64>())) return DtId::INT64;
+    if (np::equivalent(dtype, np::dtype::get_builtin<Index32>())) return DtId::UINT32;
+    if (np::equivalent(dtype, np::dtype::get_builtin<Index64>())) return DtId::UINT64;
+    //if (np::equivalent(dtype, np::dtype::get_builtin<half>())) return DtId::HALF;
 #endif
+    throw openvdb::TypeError{};
+}
+
+
+// Return a string description of the given NumPy array's data type.
+inline std::string
+arrayTypeName(const py::numpy::ndarray& arrayObj)
+{
+    return pyutil::str(arrayObj.get_dtype());
+}
+
+
+// Return the dimensions of the given NumPy array.
+inline ArrayDimVec
+arrayDimensions(const py::numpy::ndarray& arrayObj)
+{
+    ArrayDimVec dims;
+    for (int i = 0, N = arrayObj.get_nd(); i < N; ++i) {
+        dims.push_back(static_cast<size_t>(arrayObj.shape(i)));
+    }
+    return dims;
+}
+
+#else // !defined PY_OPENVDB_USE_BOOST_PYTHON_NUMPY
+
+// Return the ID number of the given NumPy array's data type.
+inline DtId
+arrayTypeId(const py::numeric::array& arrayObj)
+{
+    const PyArray_Descr* dtype = nullptr;
+    if (PyArrayObject* arrayObjPtr = reinterpret_cast<PyArrayObject*>(arrayObj.ptr())) {
+        dtype = PyArray_DESCR(arrayObjPtr);
+    }
+    if (dtype) return static_cast<DtId>(dtype->type_num);
+    throw openvdb::TypeError{};
+}
+
+
+// Return a string description of the given NumPy array's data type.
+inline std::string
+arrayTypeName(const py::numeric::array& arrayObj)
+{
+    std::string name;
+    if (PyObject_HasAttrString(arrayObj.ptr(), "dtype")) {
+        name = pyutil::str(arrayObj.attr("dtype"));
+    } else {
+        name = "'_'";
+        PyArrayObject* arrayObjPtr = reinterpret_cast<PyArrayObject*>(arrayObj.ptr());
+        name[1] = PyArray_DESCR(arrayObjPtr)->kind;
+    }
+    return name;
+}
+
+
+// Return the dimensions of the given NumPy array.
+inline ArrayDimVec
+arrayDimensions(const py::numeric::array& arrayObj)
+{
+    const py::object shape = arrayObj.attr("shape");
+    ArrayDimVec dims;
+    for (long i = 0, N = py::len(shape); i < N; ++i) {
+        dims.push_back(py::extract<size_t>(shape[i]));
+    }
+    return dims;
+}
 
 
 inline py::object
@@ -797,6 +940,8 @@ copyNumPyArray(PyArrayObject* arrayObj, NPY_ORDER order = NPY_CORDER)
     return obj;
 }
 
+#endif // PY_OPENVDB_USE_BOOST_PYTHON_NUMPY
+
 
 // Abstract base class for helper classes that copy data between
 // NumPy arrays of various types and grids of various types
@@ -804,7 +949,7 @@ template<typename GridType>
 class CopyOpBase
 {
 public:
-    typedef typename GridType::ValueType ValueT;
+    using ValueT = typename GridType::ValueType;
 
     CopyOpBase(bool toGrid, GridType& grid, py::object arrObj,
         py::object coordObj, py::object tolObj)
@@ -820,30 +965,28 @@ class CopyOpBase
 
         // Extract a reference to (not a copy of) the NumPy array,
         // or throw an exception if arrObj is not a NumPy array object.
-        const py::numeric::array arrayObj = pyutil::extractArg<py::numeric::array>(
+        const auto arrayObj = pyutil::extractArg<NumPyArrayType>(
             arrObj, opName[toGrid], pyutil::GridTraits<GridType>::name(),
             /*argIdx=*/1, "numpy.ndarray");
 
-        PyArrayObject* arrayObjPtr = reinterpret_cast<PyArrayObject*>(arrayObj.ptr());
-
-        const PyArray_Descr* dtype = PyArray_DESCR(arrayObjPtr);
-        const py::object shape = arrayObj.attr("shape");
+#ifdef PY_OPENVDB_USE_BOOST_PYTHON_NUMPY
+        mArray = arrayObj.get_data();
+#else
+        mArray = PyArray_DATA(reinterpret_cast<PyArrayObject*>(arrayObj.ptr()));
+#endif
 
-        if (PyObject_HasAttrString(arrayObj.ptr(), "dtype")) {
-            mArrayTypeName = pyutil::str(arrayObj.attr("dtype"));
-        } else {
-            mArrayTypeName = "'_'";
-            mArrayTypeName[1] = dtype->kind;
-        }
+        mArrayTypeName = arrayTypeName(arrayObj);
+        mArrayTypeId = arrayTypeId(arrayObj);
+        mArrayDims = arrayDimensions(arrayObj);
 
-        mArray = PyArray_DATA(arrayObjPtr);
-        mArrayTypeNum = dtype->type_num;
         mTolerance = extractValueArg<GridType>(tolObj, opName[toGrid], 2);
-        for (long i = 0, N = py::len(shape); i < N; ++i) {
-            mArrayDims.push_back(py::extract<int>(shape[i]));
-        }
+
         // Compute the bounding box of the region of the grid that is to be copied from or to.
-        mBBox.reset(origin, origin.offsetBy(mArrayDims[0]-1, mArrayDims[1]-1, mArrayDims[2]-1));
+        Coord bboxMax = origin;
+        for (size_t n = 0, N = std::min<size_t>(mArrayDims.size(), 3); n < N; ++n) {
+            bboxMax[n] += int(mArrayDims[n]) - 1;
+        }
+        mBBox.reset(origin, bboxMax);
     }
     virtual ~CopyOpBase() {}
 
@@ -887,8 +1030,8 @@ class CopyOpBase
     bool mToGrid; // if true, copy from the array to the grid, else vice-versa
     void* mArray;
     GridType* mGrid;
-    int mArrayTypeNum;
-    std::vector<int> mArrayDims;
+    DtId mArrayTypeId;
+    ArrayDimVec mArrayDims;
     std::string mArrayTypeName;
     CoordBBox mBBox;
     ValueT mTolerance;
@@ -910,7 +1053,7 @@ class CopyOp<GridType, /*VecSize=*/1>: public CopyOpBase<GridType>
     }
 
 protected:
-    virtual void validate() const
+    void validate() const override
     {
         if (this->mArrayDims.size() != 3) {
             std::ostringstream os;
@@ -921,32 +1064,32 @@ class CopyOp<GridType, /*VecSize=*/1>: public CopyOpBase<GridType>
         }
     }
 
-    virtual void copyFromArray() const
+    void copyFromArray() const override
     {
-        switch (this->mArrayTypeNum) {
-        case NPY_FLOAT:  this->template fromArray<typename NumPyToCpp<NPY_FLOAT>::type>(); break;
-        case NPY_DOUBLE: this->template fromArray<typename NumPyToCpp<NPY_DOUBLE>::type>(); break;
-        case NPY_BOOL:   this->template fromArray<typename NumPyToCpp<NPY_BOOL>::type>(); break;
-        case NPY_INT16:  this->template fromArray<typename NumPyToCpp<NPY_INT16>::type>(); break;
-        case NPY_INT32:  this->template fromArray<typename NumPyToCpp<NPY_INT32>::type>(); break;
-        case NPY_INT64:  this->template fromArray<typename NumPyToCpp<NPY_INT64>::type>(); break;
-        case NPY_UINT32: this->template fromArray<typename NumPyToCpp<NPY_UINT32>::type>(); break;
-        case NPY_UINT64: this->template fromArray<typename NumPyToCpp<NPY_UINT64>::type>(); break;
+        switch (this->mArrayTypeId) {
+        case DtId::FLOAT: this->template fromArray<typename NumPyToCpp<DtId::FLOAT>::type>(); break;
+        case DtId::DOUBLE:this->template fromArray<typename NumPyToCpp<DtId::DOUBLE>::type>();break;
+        case DtId::BOOL:  this->template fromArray<typename NumPyToCpp<DtId::BOOL>::type>(); break;
+        case DtId::INT16: this->template fromArray<typename NumPyToCpp<DtId::INT16>::type>(); break;
+        case DtId::INT32: this->template fromArray<typename NumPyToCpp<DtId::INT32>::type>(); break;
+        case DtId::INT64: this->template fromArray<typename NumPyToCpp<DtId::INT64>::type>(); break;
+        case DtId::UINT32:this->template fromArray<typename NumPyToCpp<DtId::UINT32>::type>();break;
+        case DtId::UINT64:this->template fromArray<typename NumPyToCpp<DtId::UINT64>::type>();break;
         default: throw openvdb::TypeError(); break;
         }
     }
 
-    virtual void copyToArray() const
+    void copyToArray() const override
     {
-        switch (this->mArrayTypeNum) {
-        case NPY_FLOAT:  this->template toArray<typename NumPyToCpp<NPY_FLOAT>::type>(); break;
-        case NPY_DOUBLE: this->template toArray<typename NumPyToCpp<NPY_DOUBLE>::type>(); break;
-        case NPY_BOOL:   this->template toArray<typename NumPyToCpp<NPY_BOOL>::type>(); break;
-        case NPY_INT16:  this->template toArray<typename NumPyToCpp<NPY_INT16>::type>(); break;
-        case NPY_INT32:  this->template toArray<typename NumPyToCpp<NPY_INT32>::type>(); break;
-        case NPY_INT64:  this->template toArray<typename NumPyToCpp<NPY_INT64>::type>(); break;
-        case NPY_UINT32: this->template toArray<typename NumPyToCpp<NPY_UINT32>::type>(); break;
-        case NPY_UINT64: this->template toArray<typename NumPyToCpp<NPY_UINT64>::type>(); break;
+        switch (this->mArrayTypeId) {
+        case DtId::FLOAT:  this->template toArray<typename NumPyToCpp<DtId::FLOAT>::type>(); break;
+        case DtId::DOUBLE: this->template toArray<typename NumPyToCpp<DtId::DOUBLE>::type>(); break;
+        case DtId::BOOL:   this->template toArray<typename NumPyToCpp<DtId::BOOL>::type>(); break;
+        case DtId::INT16:  this->template toArray<typename NumPyToCpp<DtId::INT16>::type>(); break;
+        case DtId::INT32:  this->template toArray<typename NumPyToCpp<DtId::INT32>::type>(); break;
+        case DtId::INT64:  this->template toArray<typename NumPyToCpp<DtId::INT64>::type>(); break;
+        case DtId::UINT32: this->template toArray<typename NumPyToCpp<DtId::UINT32>::type>(); break;
+        case DtId::UINT64: this->template toArray<typename NumPyToCpp<DtId::UINT64>::type>(); break;
         default: throw openvdb::TypeError(); break;
         }
     }
@@ -964,7 +1107,7 @@ class CopyOp<GridType, /*VecSize=*/3>: public CopyOpBase<GridType>
     }
 
 protected:
-    virtual void validate() const
+    void validate() const override
     {
         if (this->mArrayDims.size() != 4) {
             std::ostringstream os;
@@ -984,48 +1127,48 @@ class CopyOp<GridType, /*VecSize=*/3>: public CopyOpBase<GridType>
         }
     }
 
-    virtual void copyFromArray() const
+    void copyFromArray() const override
     {
-        switch (this->mArrayTypeNum) {
-        case NPY_FLOAT:
-            this->template fromArray<math::Vec3<typename NumPyToCpp<NPY_FLOAT>::type> >(); break;
-        case NPY_DOUBLE:
-            this->template fromArray<math::Vec3<typename NumPyToCpp<NPY_DOUBLE>::type> >(); break;
-        case NPY_BOOL:
-            this->template fromArray<math::Vec3<typename NumPyToCpp<NPY_BOOL>::type> >(); break;
-        case NPY_INT16:
-            this->template fromArray<math::Vec3<typename NumPyToCpp<NPY_INT16>::type> >(); break;
-        case NPY_INT32:
-            this->template fromArray<math::Vec3<typename NumPyToCpp<NPY_INT32>::type> >(); break;
-        case NPY_INT64:
-            this->template fromArray<math::Vec3<typename NumPyToCpp<NPY_INT64>::type> >(); break;
-        case NPY_UINT32:
-            this->template fromArray<math::Vec3<typename NumPyToCpp<NPY_UINT32>::type> >(); break;
-        case NPY_UINT64:
-            this->template fromArray<math::Vec3<typename NumPyToCpp<NPY_UINT64>::type> >(); break;
+        switch (this->mArrayTypeId) {
+        case DtId::FLOAT:
+            this->template fromArray<math::Vec3<typename NumPyToCpp<DtId::FLOAT>::type>>(); break;
+        case DtId::DOUBLE:
+            this->template fromArray<math::Vec3<typename NumPyToCpp<DtId::DOUBLE>::type>>(); break;
+        case DtId::BOOL:
+            this->template fromArray<math::Vec3<typename NumPyToCpp<DtId::BOOL>::type>>(); break;
+        case DtId::INT16:
+            this->template fromArray<math::Vec3<typename NumPyToCpp<DtId::INT16>::type>>(); break;
+        case DtId::INT32:
+            this->template fromArray<math::Vec3<typename NumPyToCpp<DtId::INT32>::type>>(); break;
+        case DtId::INT64:
+            this->template fromArray<math::Vec3<typename NumPyToCpp<DtId::INT64>::type>>(); break;
+        case DtId::UINT32:
+            this->template fromArray<math::Vec3<typename NumPyToCpp<DtId::UINT32>::type>>(); break;
+        case DtId::UINT64:
+            this->template fromArray<math::Vec3<typename NumPyToCpp<DtId::UINT64>::type>>(); break;
         default: throw openvdb::TypeError(); break;
         }
     }
 
-    virtual void copyToArray() const
+    void copyToArray() const override
     {
-        switch (this->mArrayTypeNum) {
-        case NPY_FLOAT:
-            this->template toArray<math::Vec3<typename NumPyToCpp<NPY_FLOAT>::type> >(); break;
-        case NPY_DOUBLE:
-            this->template toArray<math::Vec3<typename NumPyToCpp<NPY_DOUBLE>::type> >(); break;
-        case NPY_BOOL:
-            this->template toArray<math::Vec3<typename NumPyToCpp<NPY_BOOL>::type> >(); break;
-        case NPY_INT16:
-            this->template toArray<math::Vec3<typename NumPyToCpp<NPY_INT16>::type> >(); break;
-        case NPY_INT32:
-            this->template toArray<math::Vec3<typename NumPyToCpp<NPY_INT32>::type> >(); break;
-        case NPY_INT64:
-            this->template toArray<math::Vec3<typename NumPyToCpp<NPY_INT64>::type> >(); break;
-        case NPY_UINT32:
-            this->template toArray<math::Vec3<typename NumPyToCpp<NPY_UINT32>::type> >(); break;
-        case NPY_UINT64:
-            this->template toArray<math::Vec3<typename NumPyToCpp<NPY_UINT64>::type> >(); break;
+        switch (this->mArrayTypeId) {
+        case DtId::FLOAT:
+            this->template toArray<math::Vec3<typename NumPyToCpp<DtId::FLOAT>::type>>(); break;
+        case DtId::DOUBLE:
+            this->template toArray<math::Vec3<typename NumPyToCpp<DtId::DOUBLE>::type>>(); break;
+        case DtId::BOOL:
+            this->template toArray<math::Vec3<typename NumPyToCpp<DtId::BOOL>::type>>(); break;
+        case DtId::INT16:
+            this->template toArray<math::Vec3<typename NumPyToCpp<DtId::INT16>::type>>(); break;
+        case DtId::INT32:
+            this->template toArray<math::Vec3<typename NumPyToCpp<DtId::INT32>::type>>(); break;
+        case DtId::INT64:
+            this->template toArray<math::Vec3<typename NumPyToCpp<DtId::INT64>::type>>(); break;
+        case DtId::UINT32:
+            this->template toArray<math::Vec3<typename NumPyToCpp<DtId::UINT32>::type>>(); break;
+        case DtId::UINT64:
+            this->template toArray<math::Vec3<typename NumPyToCpp<DtId::UINT64>::type>>(); break;
         default: throw openvdb::TypeError(); break;
         }
     }
@@ -1036,7 +1179,7 @@ template<typename GridType>
 inline void
 copyFromArray(GridType& grid, py::object arrayObj, py::object coordObj, py::object toleranceObj)
 {
-    typedef typename GridType::ValueType ValueT;
+    using ValueT = typename GridType::ValueType;
     CopyOp<GridType, VecTraits<ValueT>::Size>
         op(/*toGrid=*/true, grid, arrayObj, coordObj, toleranceObj);
     op();
@@ -1047,7 +1190,7 @@ template<typename GridType>
 inline void
 copyToArray(GridType& grid, py::object arrayObj, py::object coordObj)
 {
-    typedef typename GridType::ValueType ValueT;
+    using ValueT = typename GridType::ValueType;
     CopyOp<GridType, VecTraits<ValueT>::Size>
         op(/*toGrid=*/false, grid, arrayObj, coordObj);
     op();
@@ -1109,18 +1252,18 @@ struct CopyVecOp<T, T> {
     }
 };
 
+
 // Helper function for use with meshToLevelSet() to copy vectors of various types
 // and sizes from NumPy arrays to STL vectors
 template<typename VecT>
 inline void
-copyVecArray(py::numeric::array& arrayObj, std::vector<VecT>& vec)
+copyVecArray(NumPyArrayType& arrayObj, std::vector<VecT>& vec)
 {
-    typedef typename VecT::ValueType ValueT;
+    using ValueT = typename VecT::ValueType;
 
     // Get the input array dimensions.
-    PyArrayObject* arrayObjPtr = reinterpret_cast<PyArrayObject*>(arrayObj.ptr());
-    const PyArray_Descr* dtype = PyArray_DESCR(arrayObjPtr);
-    const size_t M = py::extract<size_t>(arrayObj.attr("shape")[0]);
+    const auto dims = arrayDimensions(arrayObj);
+    const size_t M = dims.empty() ? 0 : dims[0];
     const size_t N = VecT().numElements();
     if (M == 0 || N == 0) return;
 
@@ -1128,17 +1271,22 @@ copyVecArray(py::numeric::array& arrayObj, std::vector<VecT>& vec)
     vec.resize(M);
 
     // Copy values from the input array to the output vector (with type conversion, if necessary).
+#ifdef PY_OPENVDB_USE_BOOST_PYTHON_NUMPY
+    const void* src = arrayObj.get_data();
+#else
+    PyArrayObject* arrayObjPtr = reinterpret_cast<PyArrayObject*>(arrayObj.ptr());
     const void* src = PyArray_DATA(arrayObjPtr);
+#endif
     ValueT* dst = &vec[0][0];
-    switch (dtype->type_num) {
-        case NPY_FLOAT:  CopyVecOp<NumPyToCpp<NPY_FLOAT>::type, ValueT>()(src, dst, M*N); break;
-        case NPY_DOUBLE: CopyVecOp<NumPyToCpp<NPY_DOUBLE>::type, ValueT>()(src, dst, M*N); break;
-        case NPY_INT16:  CopyVecOp<NumPyToCpp<NPY_INT16>::type, ValueT>()(src, dst, M*N); break;
-        case NPY_INT32:  CopyVecOp<NumPyToCpp<NPY_INT32>::type, ValueT>()(src, dst, M*N); break;
-        case NPY_INT64:  CopyVecOp<NumPyToCpp<NPY_INT64>::type, ValueT>()(src, dst, M*N); break;
-        case NPY_UINT32: CopyVecOp<NumPyToCpp<NPY_UINT32>::type, ValueT>()(src, dst, M*N); break;
-        case NPY_UINT64: CopyVecOp<NumPyToCpp<NPY_UINT64>::type, ValueT>()(src, dst, M*N); break;
-        default: break;
+    switch (arrayTypeId(arrayObj)) {
+    case DtId::FLOAT:  CopyVecOp<NumPyToCpp<DtId::FLOAT>::type, ValueT>()(src, dst, M*N); break;
+    case DtId::DOUBLE: CopyVecOp<NumPyToCpp<DtId::DOUBLE>::type, ValueT>()(src, dst, M*N); break;
+    case DtId::INT16:  CopyVecOp<NumPyToCpp<DtId::INT16>::type, ValueT>()(src, dst, M*N); break;
+    case DtId::INT32:  CopyVecOp<NumPyToCpp<DtId::INT32>::type, ValueT>()(src, dst, M*N); break;
+    case DtId::INT64:  CopyVecOp<NumPyToCpp<DtId::INT64>::type, ValueT>()(src, dst, M*N); break;
+    case DtId::UINT32: CopyVecOp<NumPyToCpp<DtId::UINT32>::type, ValueT>()(src, dst, M*N); break;
+    case DtId::UINT64: CopyVecOp<NumPyToCpp<DtId::UINT64>::type, ValueT>()(src, dst, M*N); break;
+    default: break;
     }
 }
 
@@ -1156,49 +1304,37 @@ meshToLevelSet(py::object pointsObj, py::object trianglesObj, py::object quadsOb
 
         // Raise a Python exception if the given NumPy array does not have dimensions M x N
         // or does not have an integer or floating-point data type.
-        static void validate2DNumPyArray(py::numeric::array arrayObj,
-            const int N, const char* desiredType)
+        static void validate2DNumPyArray(NumPyArrayType arrayObj,
+            const size_t N, const char* desiredType)
         {
-            PyArrayObject* arrayObjPtr = reinterpret_cast<PyArrayObject*>(arrayObj.ptr());
-
-            const PyArray_Descr* dtype = PyArray_DESCR(arrayObjPtr);
-            const py::object shape = arrayObj.attr("shape");
-            const int numDims = int(py::len(shape));
+            const auto dims = arrayDimensions(arrayObj);
 
             bool wrongArrayType = false;
             // Check array dimensions.
-            if (numDims != 2 || py::extract<int>(shape[1]) != N) {
+            if (dims.size() != 2 || dims[1] != N) {
                 wrongArrayType = true;
             } else {
                 // Check array data type.
-                switch (dtype->type_num) {
-                    case NPY_FLOAT: case NPY_DOUBLE: case NPY_INT16: //case NPY_HALF:
-                    case NPY_INT32: case NPY_INT64: case NPY_UINT32: case NPY_UINT64: break;
+                switch (arrayTypeId(arrayObj)) {
+                    case DtId::FLOAT: case DtId::DOUBLE: //case DtId::HALF:
+                    case DtId::INT16: case DtId::INT32: case DtId::INT64:
+                    case DtId::UINT32: case DtId::UINT64: break;
                     default: wrongArrayType = true; break;
                 }
             }
             if (wrongArrayType) {
                 // Generate an error message and raise a Python TypeError.
-                std::string arrayTypeName;
-                if (PyObject_HasAttrString(arrayObj.ptr(), "dtype")) {
-                    arrayTypeName = pyutil::str(arrayObj.attr("dtype"));
-                } else {
-                    arrayTypeName = "'_'";
-                    arrayTypeName[1] = dtype->kind;
-                }
                 std::ostringstream os;
                 os << "expected N x 3 numpy.ndarray of " << desiredType << ", found ";
-                switch (numDims) {
+                switch (dims.size()) {
                     case 0: os << "zero-dimensional"; break;
                     case 1: os << "one-dimensional"; break;
                     default:
-                        os << py::extract<int>(shape[0]);
-                        for (int i = 1; i < numDims; ++i) {
-                            os << " x " << py::extract<int>(shape[i]);
-                        }
+                        os << dims[0];
+                        for (size_t i = 1; i < dims.size(); ++i) { os << " x " << dims[i]; }
                         break;
                 }
-                os << " " << arrayTypeName << " array as argument 1 to "
+                os << " " << arrayTypeName(arrayObj) << " array as argument 1 to "
                     << pyutil::GridTraits<GridType>::name() << "." << methodName() << "()";
                 PyErr_SetString(PyExc_TypeError, os.str().c_str());
                 py::throw_error_already_set();
@@ -1222,7 +1358,7 @@ meshToLevelSet(py::object pointsObj, py::object trianglesObj, py::object quadsOb
     if (!pointsObj.is_none()) {
         // Extract a reference to (not a copy of) a NumPy array argument,
         // or throw an exception if the argument is not a NumPy array object.
-        py::numeric::array arrayObj = extractValueArg<GridType, py::numeric::array>(
+        auto arrayObj = extractValueArg<GridType, NumPyArrayType>(
             pointsObj, Local::methodName(), /*argIdx=*/1, "numpy.ndarray");
 
         // Throw an exception if the array has the wrong type or dimensions.
@@ -1235,7 +1371,7 @@ meshToLevelSet(py::object pointsObj, py::object trianglesObj, py::object quadsOb
     // Extract the list of triangle indices from the arguments to this method.
     std::vector<Vec3I> triangles;
     if (!trianglesObj.is_none()) {
-        py::numeric::array arrayObj = extractValueArg<GridType, py::numeric::array>(
+        auto arrayObj = extractValueArg<GridType, NumPyArrayType>(
             trianglesObj, Local::methodName(), /*argIdx=*/2, "numpy.ndarray");
         Local::validate2DNumPyArray(arrayObj, /*N=*/3, /*desiredType=*/"int");
         copyVecArray(arrayObj, triangles);
@@ -1244,7 +1380,7 @@ meshToLevelSet(py::object pointsObj, py::object trianglesObj, py::object quadsOb
     // Extract the list of quad indices from the arguments to this method.
     std::vector<Vec4I> quads;
     if (!quadsObj.is_none()) {
-        py::numeric::array arrayObj = extractValueArg<GridType, py::numeric::array>(
+        auto arrayObj = extractValueArg<GridType, NumPyArrayType>(
             quadsObj, Local::methodName(), /*argIdx=*/3, "numpy.ndarray");
         Local::validate2DNumPyArray(arrayObj, /*N=*/4, /*desiredType=*/"int");
         copyVecArray(arrayObj, quads);
@@ -1260,13 +1396,28 @@ inline py::object
 volumeToQuadMesh(const GridType& grid, py::object isovalueObj)
 {
     const double isovalue = pyutil::extractArg<double>(
-        isovalueObj, "convertToQuads", /*className=*/NULL, /*argIdx=*/2, "float");
+        isovalueObj, "convertToQuads", /*className=*/nullptr, /*argIdx=*/2, "float");
 
     // Mesh the input grid and populate lists of mesh vertices and face vertex indices.
     std::vector<Vec3s> points;
     std::vector<Vec4I> quads;
     tools::volumeToMesh(grid, points, quads, isovalue);
 
+#ifdef PY_OPENVDB_USE_BOOST_PYTHON_NUMPY
+    const py::object own;
+    auto dtype = py::numpy::dtype::get_builtin<Vec3s::value_type>();
+    auto shape = py::make_tuple(points.size(), 3);
+    auto stride = py::make_tuple(3 * sizeof(Vec3s::value_type), sizeof(Vec3s::value_type));
+    // Create a deep copy of the array (because the point vector will be destroyed
+    // when this function returns).
+    auto pointArrayObj = py::numpy::from_data(points.data(), dtype, shape, stride, own).copy();
+
+    dtype = py::numpy::dtype::get_builtin<Vec4I::value_type>();
+    shape = py::make_tuple(quads.size(), 4);
+    stride = py::make_tuple(4 * sizeof(Vec4I::value_type), sizeof(Vec4I::value_type));
+    auto quadArrayObj = py::numpy::from_data(
+        quads.data(), dtype, shape, stride, own).copy(); // deep copy
+#else // !defined PY_OPENVDB_USE_BOOST_PYTHON_NUMPY
     // Copy vertices into an N x 3 NumPy array.
     py::object pointArrayObj = py::numeric::array(py::list(), "float32");
     if (!points.empty()) {
@@ -1291,6 +1442,7 @@ volumeToQuadMesh(const GridType& grid, py::object isovalueObj)
             quadArrayObj = copyNumPyArray(arrayObj, NPY_CORDER);
         }
     }
+#endif // PY_OPENVDB_USE_BOOST_PYTHON_NUMPY
 
     return py::make_tuple(pointArrayObj, quadArrayObj);
 }
@@ -1301,9 +1453,9 @@ inline py::object
 volumeToMesh(const GridType& grid, py::object isovalueObj, py::object adaptivityObj)
 {
     const double isovalue = pyutil::extractArg<double>(
-        isovalueObj, "convertToPolygons", /*className=*/NULL, /*argIdx=*/2, "float");
+        isovalueObj, "convertToPolygons", /*className=*/nullptr, /*argIdx=*/2, "float");
     const double adaptivity = pyutil::extractArg<double>(
-        adaptivityObj, "convertToPolygons", /*className=*/NULL, /*argIdx=*/3, "float");
+        adaptivityObj, "convertToPolygons", /*className=*/nullptr, /*argIdx=*/3, "float");
 
     // Mesh the input grid and populate lists of mesh vertices and face vertex indices.
     std::vector<Vec3s> points;
@@ -1311,6 +1463,27 @@ volumeToMesh(const GridType& grid, py::object isovalueObj, py::object adaptivity
     std::vector<Vec4I> quads;
     tools::volumeToMesh(grid, points, triangles, quads, isovalue, adaptivity);
 
+#ifdef PY_OPENVDB_USE_BOOST_PYTHON_NUMPY
+    const py::object own;
+    auto dtype = py::numpy::dtype::get_builtin<Vec3s::value_type>();
+    auto shape = py::make_tuple(points.size(), 3);
+    auto stride = py::make_tuple(3 * sizeof(Vec3s::value_type), sizeof(Vec3s::value_type));
+    // Create a deep copy of the array (because the point vector will be destroyed
+    // when this function returns).
+    auto pointArrayObj = py::numpy::from_data(points.data(), dtype, shape, stride, own).copy();
+
+    dtype = py::numpy::dtype::get_builtin<Vec3I::value_type>();
+    shape = py::make_tuple(triangles.size(), 3);
+    stride = py::make_tuple(3 * sizeof(Vec3I::value_type), sizeof(Vec3I::value_type));
+    auto triangleArrayObj = py::numpy::from_data(
+        triangles.data(), dtype, shape, stride, own).copy(); // deep copy
+
+    dtype = py::numpy::dtype::get_builtin<Vec4I::value_type>();
+    shape = py::make_tuple(quads.size(), 4);
+    stride = py::make_tuple(4 * sizeof(Vec4I::value_type), sizeof(Vec4I::value_type));
+    auto quadArrayObj = py::numpy::from_data(
+        quads.data(), dtype, shape, stride, own).copy(); // deep copy
+#else // !defined PY_OPENVDB_USE_BOOST_PYTHON_NUMPY
     // Copy vertices into an N x 3 NumPy array.
     py::object pointArrayObj = py::numeric::array(py::list(), "float32");
     if (!points.empty()) {
@@ -1346,6 +1519,7 @@ volumeToMesh(const GridType& grid, py::object isovalueObj, py::object adaptivity
             quadArrayObj = copyNumPyArray(arrayObj, NPY_CORDER);
         }
     }
+#endif // PY_OPENVDB_USE_BOOST_PYTHON_NUMPY
 
     return py::make_tuple(pointArrayObj, triangleArrayObj, quadArrayObj);
 }
@@ -1360,7 +1534,7 @@ template<typename GridType, typename IterType>
 inline void
 applyMap(const char* methodName, GridType& grid, py::object funcObj)
 {
-    typedef typename GridType::ValueType ValueT;
+    using ValueT = typename GridType::ValueType;
 
     for (IterType it = grid.tree().template begin<IterType>(); it; ++it) {
         // Evaluate the functor.
@@ -1413,8 +1587,8 @@ mapAll(GridType& grid, py::object funcObj)
 template<typename GridType>
 struct TreeCombineOp
 {
-    typedef typename GridType::TreeType TreeT;
-    typedef typename GridType::ValueType ValueT;
+    using TreeT = typename GridType::TreeType;
+    using ValueT = typename GridType::ValueType;
 
     TreeCombineOp(py::object _op): op(_op) {}
     void operator()(const ValueT& a, const ValueT& b, ValueT& result)
@@ -1441,7 +1615,7 @@ template<typename GridType>
 inline void
 combine(GridType& grid, py::object otherGridObj, py::object funcObj)
 {
-    typedef typename GridType::Ptr GridPtr;
+    using GridPtr = typename GridType::Ptr;
     GridPtr otherGrid = extractValueArg<GridType, GridPtr>(otherGridObj,
         "combine", 1, pyutil::GridTraits<GridType>::name());
     TreeCombineOp<GridType> op(funcObj);
@@ -1478,7 +1652,7 @@ template<typename GridT, typename IterT> struct IterTraits
 
 template<typename GridT> struct IterTraits<GridT, typename GridT::ValueOnCIter>
 {
-    typedef typename GridT::ValueOnCIter IterT;
+    using IterT = typename GridT::ValueOnCIter;
     static std::string name() { return "ValueOnCIter"; }
     static std::string descr()
     {
@@ -1493,7 +1667,7 @@ template<typename GridT> struct IterTraits<GridT, typename GridT::ValueOnCIter>
 
 template<typename GridT> struct IterTraits<GridT, typename GridT::ValueOffCIter>
 {
-    typedef typename GridT::ValueOffCIter IterT;
+    using IterT = typename GridT::ValueOffCIter;
     static std::string name() { return "ValueOffCIter"; }
     static std::string descr()
     {
@@ -1508,7 +1682,7 @@ template<typename GridT> struct IterTraits<GridT, typename GridT::ValueOffCIter>
 
 template<typename GridT> struct IterTraits<GridT, typename GridT::ValueAllCIter>
 {
-    typedef typename GridT::ValueAllCIter IterT;
+    using IterT = typename GridT::ValueAllCIter;
     static std::string name() { return "ValueAllCIter"; }
     static std::string descr()
     {
@@ -1523,7 +1697,7 @@ template<typename GridT> struct IterTraits<GridT, typename GridT::ValueAllCIter>
 
 template<typename GridT> struct IterTraits<GridT, typename GridT::ValueOnIter>
 {
-    typedef typename GridT::ValueOnIter IterT;
+    using IterT = typename GridT::ValueOnIter;
     static std::string name() { return "ValueOnIter"; }
     static std::string descr()
     {
@@ -1538,7 +1712,7 @@ template<typename GridT> struct IterTraits<GridT, typename GridT::ValueOnIter>
 
 template<typename GridT> struct IterTraits<GridT, typename GridT::ValueOffIter>
 {
-    typedef typename GridT::ValueOffIter IterT;
+    using IterT = typename GridT::ValueOffIter;
     static std::string name() { return "ValueOffIter"; }
     static std::string descr()
     {
@@ -1553,7 +1727,7 @@ template<typename GridT> struct IterTraits<GridT, typename GridT::ValueOffIter>
 
 template<typename GridT> struct IterTraits<GridT, typename GridT::ValueAllIter>
 {
-    typedef typename GridT::ValueAllIter IterT;
+    using IterT = typename GridT::ValueAllIter;
     static std::string name() { return "ValueAllIter"; }
     static std::string descr()
     {
@@ -1574,7 +1748,7 @@ template<typename GridT> struct IterTraits<GridT, typename GridT::ValueAllIter>
 template<typename GridT, typename IterT>
 struct IterItemSetter
 {
-    typedef typename GridT::ValueType ValueT;
+    using ValueT = typename GridT::ValueType;
     static void setValue(const IterT& iter, const ValueT& val) { iter.setValue(val); }
     static void setActive(const IterT& iter, bool on) { iter.setActiveState(on); }
 };
@@ -1583,7 +1757,7 @@ struct IterItemSetter
 template<typename GridT, typename IterT>
 struct IterItemSetter<const GridT, IterT>
 {
-    typedef typename GridT::ValueType ValueT;
+    using ValueT = typename GridT::ValueType;
     static void setValue(const IterT&, const ValueT&)
     {
         PyErr_SetString(PyExc_AttributeError, "can't set attribute 'value'");
@@ -1605,10 +1779,10 @@ template<typename _GridT, typename _IterT>
 class IterValueProxy
 {
 public:
-    typedef _GridT GridT;
-    typedef _IterT IterT;
-    typedef typename GridT::ValueType ValueT;
-    typedef IterItemSetter<GridT, IterT> SetterT;
+    using GridT = _GridT;
+    using IterT = _IterT;
+    using ValueT = typename GridT::ValueType;
+    using SetterT = IterItemSetter<GridT, IterT>;
 
     IterValueProxy(typename GridT::ConstPtr grid, const IterT& iter): mGrid(grid), mIter(iter) {}
 
@@ -1630,7 +1804,7 @@ class IterValueProxy
     static const char* const * keys()
     {
         static const char* const sKeys[] = {
-            "value", "active", "depth", "min", "max", "count", NULL
+            "value", "active", "depth", "min", "max", "count", nullptr
         };
         return sKeys;
     }
@@ -1638,7 +1812,7 @@ class IterValueProxy
     /// Return @c true if the given string is a valid key.
     static bool hasKey(const std::string& key)
     {
-        for (int i = 0; keys()[i] != NULL; ++i) {
+        for (int i = 0; keys()[i] != nullptr; ++i) {
             if (key == keys()[i]) return true;
         }
         return false;
@@ -1648,7 +1822,7 @@ class IterValueProxy
     static py::list getKeys()
     {
         py::list keyList;
-        for (int i = 0; keys()[i] != NULL; ++i) keyList.append(keys()[i]);
+        for (int i = 0; keys()[i] != nullptr; ++i) keyList.append(keys()[i]);
         return keyList;
     }
 
@@ -1710,7 +1884,7 @@ class IterValueProxy
     {
         // valuesAsStrings = ["%s: %s" % key, repr(this[key]) for key in this.keys()]
         py::list valuesAsStrings;
-        for (int i = 0; this->keys()[i] != NULL; ++i) {
+        for (int i = 0; this->keys()[i] != nullptr; ++i) {
             py::str
                 key(this->keys()[i]),
                 val(this->getItem(key).attr("__repr__")());
@@ -1746,11 +1920,11 @@ template<typename _GridT, typename _IterT>
 class IterWrap
 {
 public:
-    typedef _GridT GridT;
-    typedef _IterT IterT;
-    typedef typename GridT::ValueType ValueT;
-    typedef IterValueProxy<GridT, IterT> IterValueProxyT;
-    typedef IterTraits<GridT, IterT> Traits;
+    using GridT = _GridT;
+    using IterT = _IterT;
+    using ValueT = typename GridT::ValueType;
+    using IterValueProxyT = IterValueProxy<GridT, IterT>;
+    using Traits = IterTraits<GridT, IterT>;
 
     IterWrap(typename GridT::ConstPtr grid, const IterT& iter): mGrid(grid), mIter(iter) {}
 
@@ -1853,7 +2027,7 @@ class IterWrap
 template<typename GridT>
 struct PickleSuite: public py::pickle_suite
 {
-    typedef typename GridT::Ptr GridPtrT;
+    using GridPtrT = typename GridT::Ptr;
 
     /// Return @c true, indicating that this pickler preserves a Grid's __dict__.
     static bool getstate_manages_dict() { return true; }
@@ -1926,10 +2100,10 @@ struct PickleSuite: public py::pickle_suite
             badState = true;
             if (PyBytes_Check(bytesObj.ptr())) {
                 // Convert the "bytes" sequence to a byte string.
-                char* buf = NULL;
+                char* buf = nullptr;
                 Py_ssize_t length = 0;
                 if (-1 != PyBytes_AsStringAndSize(bytesObj.ptr(), &buf, &length)) {
-                    if (buf != NULL && length > 0) {
+                    if (buf != nullptr && length > 0) {
                         serialized.assign(buf, buf + length);
                         badState = false;
                     }
@@ -1979,16 +2153,16 @@ template<typename GridType>
 inline void
 exportGrid()
 {
-    typedef typename GridType::ValueType ValueT;
-    typedef typename GridType::Ptr GridPtr;
-    typedef pyutil::GridTraits<GridType> Traits;
+    using ValueT = typename GridType::ValueType;
+    using GridPtr = typename GridType::Ptr;
+    using Traits = pyutil::GridTraits<GridType>;
 
-    typedef typename GridType::ValueOnCIter  ValueOnCIterT;
-    typedef typename GridType::ValueOffCIter ValueOffCIterT;
-    typedef typename GridType::ValueAllCIter ValueAllCIterT;
-    typedef typename GridType::ValueOnIter   ValueOnIterT;
-    typedef typename GridType::ValueOffIter  ValueOffIterT;
-    typedef typename GridType::ValueAllIter  ValueAllIterT;
+    using ValueOnCIterT = typename GridType::ValueOnCIter;
+    using ValueOffCIterT = typename GridType::ValueOffCIter;
+    using ValueAllCIterT = typename GridType::ValueAllCIter;
+    using ValueOnIterT = typename GridType::ValueOnIter;
+    using ValueOffIterT = typename GridType::ValueOffIter;
+    using ValueAllIterT = typename GridType::ValueAllIter;
 
     math::Transform::Ptr (GridType::*getTransform)() = &GridType::transformPtr;
 
@@ -2330,8 +2504,9 @@ exportGrid()
 
             ; // py::class_<Grid>
 
-#if DWA_BOOST_VERSION >= 1060000
-        // As of Boost 1.60, the GridPtr-to-Python object converter must be explicitly registered.
+#if DWA_BOOST_VERSION >= 1060000 && DWA_BOOST_VERSION < 1065000
+        // Boost versions 1.60 through 1.6x, for some x < 5, require the GridPtr-to-Python
+        // object converter to be explicitly registered.
         py::register_ptr_to_python<GridPtr>();
 #endif
 
diff --git a/openvdb/python/pyOpenVDBModule.cc b/openvdb/python/pyOpenVDBModule.cc
index 72602b3c..7920d9a7 100644
--- a/openvdb/python/pyOpenVDBModule.cc
+++ b/openvdb/python/pyOpenVDBModule.cc
@@ -30,16 +30,22 @@
 
 #include <cstring> // for strncmp(), strrchr(), etc.
 #include <limits>
+#include <string>
+#include <utility> // for std::make_pair()
 #include <boost/python.hpp>
 #include <boost/python/stl_iterator.hpp>
 #include <boost/python/exception_translator.hpp>
-#ifdef PY_OPENVDB_USE_NUMPY
-#define PY_ARRAY_UNIQUE_SYMBOL PY_OPENVDB_ARRAY_API
-#include <numpyconfig.h>
-#ifdef NPY_1_7_API_VERSION
-#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
+#ifndef DWA_BOOST_VERSION
+#include <boost/version.hpp>
+#define DWA_BOOST_VERSION (10 * BOOST_VERSION)
 #endif
-#include <arrayobject.h> // for import_array()
+#if defined PY_OPENVDB_USE_NUMPY && DWA_BOOST_VERSION < 1065000
+  #define PY_ARRAY_UNIQUE_SYMBOL PY_OPENVDB_ARRAY_API
+  #include <numpyconfig.h>
+  #ifdef NPY_1_7_API_VERSION
+    #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
+  #endif
+  #include <arrayobject.h> // for import_array()
 #endif
 #include "openvdb/openvdb.h"
 #include "pyopenvdb.h"
@@ -76,13 +82,13 @@ struct CoordConverter
         return obj.ptr();
     }
 
-    /// @return NULL if the given Python object is not convertible to a Coord.
+    /// @return nullptr if the given Python object is not convertible to a Coord.
     static void* convertible(PyObject* obj)
     {
-        if (!PySequence_Check(obj)) return NULL; // not a Python sequence
+        if (!PySequence_Check(obj)) return nullptr; // not a Python sequence
 
         Py_ssize_t len = PySequence_Length(obj);
-        if (len != 3 && len != 1) return NULL; // not the right length
+        if (len != 3 && len != 1) return nullptr; // not the right length
 
         return obj;
     }
@@ -92,8 +98,7 @@ struct CoordConverter
         py::converter::rvalue_from_python_stage1_data* data)
     {
         // Construct a Coord in the provided memory location.
-        typedef py::converter::rvalue_from_python_storage<openvdb::Coord>
-            StorageT;
+        using StorageT = py::converter::rvalue_from_python_storage<openvdb::Coord>;
         void* storage = reinterpret_cast<StorageT*>(data)->storage.bytes;
         new (storage) openvdb::Coord; // placement new
         data->convertible = storage;
@@ -163,17 +168,17 @@ struct VecConverter
 
     static void* convertible(PyObject* obj)
     {
-        if (!PySequence_Check(obj)) return NULL; // not a Python sequence
+        if (!PySequence_Check(obj)) return nullptr; // not a Python sequence
 
         Py_ssize_t len = PySequence_Length(obj);
-        if (len != VecT::size) return NULL;
+        if (len != VecT::size) return nullptr;
 
         // Check that all elements of the Python sequence are convertible
         // to the Vec's value type.
         py::object seq = pyutil::pyBorrow(obj);
         for (int i = 0; i < VecT::size; ++i) {
             if (!py::extract<typename VecT::value_type>(seq[i]).check()) {
-                return NULL;
+                return nullptr;
             }
         }
         return obj;
@@ -183,7 +188,7 @@ struct VecConverter
         py::converter::rvalue_from_python_stage1_data* data)
     {
         // Construct a Vec in the provided memory location.
-        typedef py::converter::rvalue_from_python_storage<VecT> StorageT;
+        using StorageT = py::converter::rvalue_from_python_storage<VecT>;
         void* storage = reinterpret_cast<StorageT*>(data)->storage.bytes;
         new (storage) VecT; // placement new
         data->convertible = storage;
@@ -263,14 +268,14 @@ struct MetaMapConverter
 
     static void* convertible(PyObject* obj)
     {
-        return (PyMapping_Check(obj) ? obj : NULL);
+        return (PyMapping_Check(obj) ? obj : nullptr);
     }
 
     static void construct(PyObject* obj,
         py::converter::rvalue_from_python_stage1_data* data)
     {
         // Construct a MetaMap in the provided memory location.
-        typedef py::converter::rvalue_from_python_storage<MetaMap> StorageT;
+        using StorageT = py::converter::rvalue_from_python_storage<MetaMap>;
         void* storage = reinterpret_cast<StorageT*>(data)->storage.bytes;
         new (storage) MetaMap; // placement new
         data->convertible = storage;
@@ -515,6 +520,11 @@ writeToFile(const std::string& filename, py::object gridOrSeqObj, py::object dic
 ////////////////////////////////////////
 
 
+std::string getLoggingLevel();
+void setLoggingLevel(py::object);
+void setProgramName(py::object, bool);
+
+
 std::string
 getLoggingLevel()
 {
@@ -590,7 +600,7 @@ struct GridClassDescr
             { "STAGGERED",  strdup(GridBase::gridClassToString(GRID_STAGGERED).c_str()) }
         };
         if (i >= 0 && i < sCount) return pyutil::CStringPair(&sStrings[i][0], &sStrings[i][1]);
-        return pyutil::CStringPair(static_cast<char**>(NULL), static_cast<char**>(NULL));
+        return pyutil::CStringPair(static_cast<char**>(nullptr), static_cast<char**>(nullptr));
     }
 };
 
@@ -633,7 +643,7 @@ struct VecTypeDescr
                 strdup(GridBase::vecTypeToString(openvdb::VEC_CONTRAVARIANT_ABSOLUTE).c_str()) }
         };
         if (i >= 0 && i < sCount) return std::make_pair(&sStrings[i][0], &sStrings[i][1]);
-        return pyutil::CStringPair(static_cast<char**>(NULL), static_cast<char**>(NULL));
+        return pyutil::CStringPair(static_cast<char**>(nullptr), static_cast<char**>(nullptr));
     }
 };
 
@@ -660,11 +670,15 @@ BOOST_PYTHON_MODULE(PY_OPENVDB_MODULE_NAME)
 
 #ifdef PY_OPENVDB_USE_NUMPY
     // Initialize NumPy.
+#ifdef PY_OPENVDB_USE_BOOST_PYTHON_NUMPY
+    boost::python::numpy::initialize();
+#else
 #if PY_MAJOR_VERSION >= 3
     if (_import_array()) {}
 #else
     import_array();
 #endif
+#endif
 #endif
 
     using namespace openvdb::OPENVDB_VERSION_NAME;
diff --git a/openvdb/python/test/TestOpenVDB.py b/openvdb/python/test/TestOpenVDB.py
index 72e93343..e87e26e5 100644
--- a/openvdb/python/test/TestOpenVDB.py
+++ b/openvdb/python/test/TestOpenVDB.py
@@ -495,7 +495,7 @@ def testCopyFromArray(self):
             return
 
         # Skip this test if the OpenVDB module was built without NumPy support.
-        arr = np.ndarray((1, 2, 1))
+        arr = np.zeros((1, 2, 1))
         grid = openvdb.FloatGrid()
         try:
             grid.copyFromArray(arr)
@@ -505,11 +505,11 @@ def testCopyFromArray(self):
         # Verify that a non-three-dimensional array can't be copied into a grid.
         grid = openvdb.FloatGrid()
         self.assertRaises(TypeError, lambda: grid.copyFromArray('abc'))
-        arr = np.ndarray((1, 2))
+        arr = np.zeros((1, 2))
         self.assertRaises(ValueError, lambda: grid.copyFromArray(arr))
 
         # Verify that complex-valued arrays are not supported.
-        arr = np.ndarray((1, 2, 1), dtype = complex)
+        arr = np.zeros((1, 2, 1), dtype = complex)
         grid = openvdb.FloatGrid()
         self.assertRaises(TypeError, lambda: grid.copyFromArray(arr))
 
@@ -591,7 +591,7 @@ def testCopyToArray(self):
             return
 
         # Skip this test if the OpenVDB module was built without NumPy support.
-        arr = np.ndarray((1, 2, 1))
+        arr = np.zeros((1, 2, 1))
         grid = openvdb.FloatGrid()
         try:
             grid.copyFromArray(arr)
@@ -601,11 +601,11 @@ def testCopyToArray(self):
         # Verify that a grid can't be copied into a non-three-dimensional array.
         grid = openvdb.FloatGrid()
         self.assertRaises(TypeError, lambda: grid.copyToArray('abc'))
-        arr = np.ndarray((1, 2))
+        arr = np.zeros((1, 2))
         self.assertRaises(ValueError, lambda: grid.copyToArray(arr))
 
         # Verify that complex-valued arrays are not supported.
-        arr = np.ndarray((1, 2, 1), dtype = complex)
+        arr = np.zeros((1, 2, 1), dtype = complex)
         grid = openvdb.FloatGrid()
         self.assertRaises(TypeError, lambda: grid.copyToArray(arr))
 
diff --git a/openvdb/tools/Filter.h b/openvdb/tools/Filter.h
index 700f686b..32f026a9 100644
--- a/openvdb/tools/Filter.h
+++ b/openvdb/tools/Filter.h
@@ -30,7 +30,7 @@
 //
 /// @author Ken Museth
 ///
-/// @file Filter.h
+/// @file tools/Filter.h
 ///
 /// @brief Filtering of VDB volumes. Note that only the values in the
 /// grid are changed, not its topology! All operations can optionally
@@ -40,9 +40,6 @@
 #define OPENVDB_TOOLS_FILTER_HAS_BEEN_INCLUDED
 
 #include <tbb/parallel_for.h>
-#include <boost/bind.hpp>
-#include <boost/function.hpp>
-#include <boost/type_traits/is_floating_point.hpp>
 #include <openvdb/Types.h>
 #include <openvdb/math/Math.h>
 #include <openvdb/math/Stencils.h>
@@ -51,6 +48,10 @@
 #include <openvdb/util/NullInterrupter.h>
 #include <openvdb/Grid.h>
 #include "Interpolation.h"
+#include <algorithm> // for std::max()
+#include <functional>
+#include <type_traits>
+
 
 namespace openvdb {
 OPENVDB_USE_VERSION_NAMESPACE
@@ -66,25 +67,26 @@ template<typename GridT,
 class Filter
 {
 public:
-    typedef GridT                                GridType;
-    typedef MaskT                                MaskType;
-    typedef typename GridType::TreeType          TreeType;
-    typedef typename TreeType::LeafNodeType      LeafType;
-    typedef typename GridType::ValueType         ValueType;
-    typedef typename MaskType::ValueType         AlphaType;
-    typedef typename tree::LeafManager<TreeType> LeafManagerType;
-    typedef typename LeafManagerType::LeafRange  RangeType;
-    typedef typename LeafManagerType::BufferType BufferType;
-    BOOST_STATIC_ASSERT(boost::is_floating_point<AlphaType>::value);
+    using GridType = GridT;
+    using MaskType = MaskT;
+    using TreeType = typename GridType::TreeType;
+    using LeafType = typename TreeType::LeafNodeType;
+    using ValueType = typename GridType::ValueType;
+    using AlphaType = typename MaskType::ValueType;
+    using LeafManagerType = typename tree::LeafManager<TreeType>;
+    using RangeType = typename LeafManagerType::LeafRange;
+    using BufferType = typename LeafManagerType::BufferType;
+    static_assert(std::is_floating_point<AlphaType>::value,
+        "openvdb::tools::Filter requires a mask grid with floating-point values");
 
     /// Constructor
     /// @param grid Grid to be filtered.
     /// @param interrupt Optional interrupter.
-    Filter(GridT& grid, InterruptT* interrupt = NULL)
+    Filter(GridT& grid, InterruptT* interrupt = nullptr)
         : mGrid(&grid)
         , mTask(0)
         , mInterrupter(interrupt)
-        , mMask(NULL)
+        , mMask(nullptr)
         , mGrainSize(1)
         , mMinMask(0)
         , mMaxMask(1)
@@ -143,7 +145,7 @@ class Filter
     /// @param width The width of the mean-value filter is 2*width+1 voxels.
     /// @param iterations Number of times the mean-value filter is applied.
     /// @param mask Optional alpha mask.
-    void mean(int width = 1, int iterations = 1, const MaskType* mask = NULL);
+    void mean(int width = 1, int iterations = 1, const MaskType* mask = nullptr);
 
     /// @brief One iteration of a fast separable Gaussian filter.
     ///
@@ -152,7 +154,7 @@ class Filter
     /// @param width The width of the mean-value filter is 2*width+1 voxels.
     /// @param iterations Number of times the mean-value filter is applied.
     /// @param mask Optional alpha mask.
-    void gaussian(int width = 1, int iterations = 1, const MaskType* mask = NULL);
+    void gaussian(int width = 1, int iterations = 1, const MaskType* mask = nullptr);
 
     /// @brief One iteration of a median-value filter
     ///
@@ -160,12 +162,12 @@ class Filter
     /// @param width The width of the mean-value filter is 2*width+1 voxels.
     /// @param iterations Number of times the mean-value filter is applied.
     /// @param mask Optional alpha mask.
-    void median(int width = 1, int iterations = 1, const MaskType* mask = NULL);
+    void median(int width = 1, int iterations = 1, const MaskType* mask = nullptr);
 
     /// Offsets (i.e. adds) a constant value to all active voxels.
     /// @param offset Offset in the same units as the grid.
     /// @param mask Optional alpha mask.
-    void offset(ValueType offset, const MaskType* mask = NULL);
+    void offset(ValueType offset, const MaskType* mask = nullptr);
 
     /// @brief Used internally by tbb::parallel_for()
     /// @param range Range of LeafNodes over which to multi-thread.
@@ -178,12 +180,12 @@ class Filter
     }
 
 private:
-    typedef typename TreeType::LeafNodeType                  LeafT;
-    typedef typename LeafT::ValueOnIter                      VoxelIterT;
-    typedef typename LeafT::ValueOnCIter                     VoxelCIterT;
-    typedef typename tree::LeafManager<TreeType>::BufferType BufferT;
-    typedef typename RangeType::Iterator                     LeafIterT;
-    typedef tools::AlphaMask<GridT, MaskT>                   AlphaMaskT;
+    using LeafT = typename TreeType::LeafNodeType;
+    using VoxelIterT = typename LeafT::ValueOnIter;
+    using VoxelCIterT = typename LeafT::ValueOnCIter;
+    using BufferT = typename tree::LeafManager<TreeType>::BufferType;
+    using LeafIterT = typename RangeType::Iterator;
+    using AlphaMaskT = tools::AlphaMask<GridT, MaskT>;
 
     void cook(LeafManagerType& leafs);
 
@@ -208,7 +210,7 @@ class Filter
     bool wasInterrupted();
 
     GridType*        mGrid;
-    typename boost::function<void (Filter*, const RangeType&)> mTask;
+    typename std::function<void (Filter*, const RangeType&)> mTask;
     InterruptT*      mInterrupter;
     const MaskType*  mMask;
     int              mGrainSize;
@@ -256,13 +258,13 @@ Filter<GridT, MaskT, InterruptT>::mean(int width, int iterations, const MaskType
     LeafManagerType leafs(mGrid->tree(), 1, mGrainSize==0);
 
     for (int i=0; i<iterations && !this->wasInterrupted(); ++i) {
-        mTask = boost::bind(&Filter::doBoxX, _1, _2, w);
+        mTask = std::bind(&Filter::doBoxX, std::placeholders::_1, std::placeholders::_2, w);
         this->cook(leafs);
 
-        mTask = boost::bind(&Filter::doBoxY, _1, _2, w);
+        mTask = std::bind(&Filter::doBoxY, std::placeholders::_1, std::placeholders::_2, w);
         this->cook(leafs);
 
-        mTask = boost::bind(&Filter::doBoxZ, _1, _2, w);
+        mTask = std::bind(&Filter::doBoxZ, std::placeholders::_1, std::placeholders::_2, w);
         this->cook(leafs);
     }
 
@@ -284,13 +286,13 @@ Filter<GridT, MaskT, InterruptT>::gaussian(int width, int iterations, const Mask
 
     for (int i=0; i<iterations; ++i) {
         for (int n=0; n<4 && !this->wasInterrupted(); ++n) {
-            mTask = boost::bind(&Filter::doBoxX, _1, _2, w);
+            mTask = std::bind(&Filter::doBoxX, std::placeholders::_1, std::placeholders::_2, w);
             this->cook(leafs);
 
-            mTask = boost::bind(&Filter::doBoxY, _1, _2, w);
+            mTask = std::bind(&Filter::doBoxY, std::placeholders::_1, std::placeholders::_2, w);
             this->cook(leafs);
 
-            mTask = boost::bind(&Filter::doBoxZ, _1, _2, w);
+            mTask = std::bind(&Filter::doBoxZ, std::placeholders::_1, std::placeholders::_2, w);
             this->cook(leafs);
         }
     }
@@ -309,7 +311,8 @@ Filter<GridT, MaskT, InterruptT>::median(int width, int iterations, const MaskTy
 
     LeafManagerType leafs(mGrid->tree(), 1, mGrainSize==0);
 
-    mTask = boost::bind(&Filter::doMedian, _1, _2, std::max(1, width));
+    mTask = std::bind(&Filter::doMedian,
+        std::placeholders::_1, std::placeholders::_2, std::max(1, width));
     for (int i=0; i<iterations && !this->wasInterrupted(); ++i) this->cook(leafs);
 
     if (mInterrupter) mInterrupter->end();
@@ -326,7 +329,7 @@ Filter<GridT, MaskT, InterruptT>::offset(ValueType value, const MaskType* mask)
 
     LeafManagerType leafs(mGrid->tree(), 0, mGrainSize==0);
 
-    mTask = boost::bind(&Filter::doOffset, _1, _2, value);
+    mTask = std::bind(&Filter::doOffset, std::placeholders::_1, std::placeholders::_2, value);
     this->cook(leafs);
 
     if (mInterrupter) mInterrupter->end();
diff --git a/openvdb/tools/LevelSetAdvect.h b/openvdb/tools/LevelSetAdvect.h
index 898ebec8..08fee77a 100644
--- a/openvdb/tools/LevelSetAdvect.h
+++ b/openvdb/tools/LevelSetAdvect.h
@@ -27,12 +27,10 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
-///////////////////////////////////////////////////////////////////////////
-//
+
 /// @author Ken Museth
 ///
-/// @file LevelSetAdvect.h
+/// @file tools/LevelSetAdvect.h
 ///
 /// @brief Hyperbolic advection of narrow-band level sets
 
@@ -45,8 +43,9 @@
 #include "LevelSetTracker.h"
 #include "VelocityFields.h" // for EnrightField
 #include <openvdb/math/FiniteDifference.h>
-#include <boost/math/constants/constants.hpp>
 //#include <openvdb/util/CpuTimer.h>
+#include <functional>
+
 
 namespace openvdb {
 OPENVDB_USE_VERSION_NAMESPACE
@@ -84,9 +83,9 @@ namespace tools {
 /// class Interrupter {
 ///   ...
 /// public:
-///   void start(const char* name = NULL)// called when computations begin
-///   void end()                         // called when computations end
-///   bool wasInterrupted(int percent=-1)// return true to break computation
+///   void start(const char* name = nullptr) // called when computations begin
+///   void end()                             // called when computations end
+///   bool wasInterrupted(int percent=-1)    // return true to break computation
 ///};
 /// @endcode
 ///
@@ -101,16 +100,16 @@ template<typename GridT,
 class LevelSetAdvection
 {
 public:
-    typedef GridT                              GridType;
-    typedef LevelSetTracker<GridT, InterruptT> TrackerT;
-    typedef typename TrackerT::LeafRange       LeafRange;
-    typedef typename TrackerT::LeafType        LeafType;
-    typedef typename TrackerT::BufferType      BufferType;
-    typedef typename TrackerT::ValueType       ValueType;
-    typedef typename FieldT::VectorType        VectorType;
+    using GridType = GridT;
+    using TrackerT = LevelSetTracker<GridT, InterruptT>;
+    using LeafRange = typename TrackerT::LeafRange;
+    using LeafType = typename TrackerT::LeafType;
+    using BufferType = typename TrackerT::BufferType;
+    using ValueType = typename TrackerT::ValueType;
+    using VectorType = typename FieldT::VectorType;
 
     /// Main constructor
-    LevelSetAdvection(GridT& grid, const FieldT& field, InterruptT* interrupt = NULL):
+    LevelSetAdvection(GridT& grid, const FieldT& field, InterruptT* interrupt = nullptr):
         mTracker(grid, interrupt), mField(field),
         mSpatialScheme(math::HJWENO5_BIAS),
         mTemporalScheme(math::TVD_RK2) {}
@@ -215,7 +214,7 @@ class LevelSetAdvection
         VectorType*        mVelocity;
         size_t*            mOffsets;
         const MapT*        mMap;
-        typename boost::function<void (Advect*, const LeafRange&)> mTask;
+        typename std::function<void (Advect*, const LeafRange&)> mTask;
         const bool         mIsMaster;
     }; // end of private Advect struct
 
@@ -329,8 +328,8 @@ LevelSetAdvection<GridT, FieldT, InterruptT>::
 Advect<MapT, SpatialScheme, TemporalScheme>::
 Advect(LevelSetAdvection& parent)
     : mParent(parent)
-    , mVelocity(NULL)
-    , mOffsets(NULL)
+    , mVelocity(nullptr)
+    , mOffsets(nullptr)
     , mMap(parent.mTracker.grid().transform().template constMap<MapT>().get())
     , mTask(0)
     , mIsMaster(true)
@@ -367,6 +366,8 @@ LevelSetAdvection<GridT, FieldT, InterruptT>::
 Advect<MapT, SpatialScheme, TemporalScheme>::
 advect(ValueType time0, ValueType time1)
 {
+    namespace ph = std::placeholders;
+
     //util::CpuTimer timer;
     size_t countCFL = 0;
     if ( math::isZero(time0 - time1) ) return countCFL;
@@ -385,7 +386,7 @@ advect(ValueType time0, ValueType time1)
         case math::TVD_RK1:
             // Perform one explicit Euler step: t1 = t0 + dt
             // Phi_t1(1) = Phi_t0(0) - dt * VdotG_t0(0)
-            mTask = boost::bind(&Advect::euler01, _1, _2, dt);
+            mTask = std::bind(&Advect::euler01, ph::_1, ph::_2, dt);
 
             // Cook and swap buffer 0 and 1 such that Phi_t1(0) and Phi_t0(1)
             this->cook("Advecting level set using TVD_RK1", 1);
@@ -393,14 +394,14 @@ advect(ValueType time0, ValueType time1)
         case math::TVD_RK2:
             // Perform one explicit Euler step: t1 = t0 + dt
             // Phi_t1(1) = Phi_t0(0) - dt * VdotG_t0(0)
-            mTask = boost::bind(&Advect::euler01, _1, _2, dt);
+            mTask = std::bind(&Advect::euler01, ph::_1, ph::_2, dt);
 
             // Cook and swap buffer 0 and 1 such that Phi_t1(0) and Phi_t0(1)
             this->cook("Advecting level set using TVD_RK1 (step 1 of 2)", 1);
 
             // Convex combine explict Euler step: t2 = t0 + dt
             // Phi_t2(1) = 1/2 * Phi_t0(1) + 1/2 * (Phi_t1(0) - dt * V.Grad_t1(0))
-            mTask = boost::bind(&Advect::euler12, _1, _2, dt);
+            mTask = std::bind(&Advect::euler12, ph::_1, ph::_2, dt);
 
             // Cook and swap buffer 0 and 1 such that Phi_t2(0) and Phi_t1(1)
             this->cook("Advecting level set using TVD_RK1 (step 2 of 2)", 1);
@@ -408,21 +409,21 @@ advect(ValueType time0, ValueType time1)
         case math::TVD_RK3:
             // Perform one explicit Euler step: t1 = t0 + dt
             // Phi_t1(1) = Phi_t0(0) - dt * VdotG_t0(0)
-            mTask = boost::bind(&Advect::euler01, _1, _2, dt);
+            mTask = std::bind(&Advect::euler01, ph::_1, ph::_2, dt);
 
             // Cook and swap buffer 0 and 1 such that Phi_t1(0) and Phi_t0(1)
             this->cook("Advecting level set using TVD_RK3 (step 1 of 3)", 1);
 
             // Convex combine explict Euler step: t2 = t0 + dt/2
             // Phi_t2(2) = 3/4 * Phi_t0(1) + 1/4 * (Phi_t1(0) - dt * V.Grad_t1(0))
-            mTask = boost::bind(&Advect::euler34, _1, _2, dt);
+            mTask = std::bind(&Advect::euler34, ph::_1, ph::_2, dt);
 
             // Cook and swap buffer 0 and 2 such that Phi_t2(0) and Phi_t1(2)
             this->cook("Advecting level set using TVD_RK3 (step 2 of 3)", 2);
 
             // Convex combine explict Euler step: t3 = t0 + dt
             // Phi_t3(2) = 1/3 * Phi_t0(1) + 2/3 * (Phi_t2(0) - dt * V.Grad_t2(0)
-            mTask = boost::bind(&Advect::euler13, _1, _2, dt);
+            mTask = std::bind(&Advect::euler13, ph::_1, ph::_2, dt);
 
             // Cook and swap buffer 0 and 2 such that Phi_t3(0) and Phi_t2(2)
             this->cook("Advecting level set using TVD_RK3 (step 3 of 3)", 2);
@@ -453,6 +454,8 @@ LevelSetAdvection<GridT, FieldT, InterruptT>::
 Advect<MapT, SpatialScheme, TemporalScheme>::
 sampleField(ValueType time0, ValueType time1)
 {
+    namespace ph = std::placeholders;
+
     const int grainSize = mParent.mTracker.getGrainSize();
     const size_t leafCount = mParent.mTracker.leafs().leafCount();
     if (leafCount==0) return ValueType(0.0);
@@ -462,9 +465,9 @@ sampleField(ValueType time0, ValueType time1)
 
     // Sample the velocity field
     if (mParent.mField.transform() == mParent.mTracker.grid().transform()) {
-        mTask = boost::bind(&Advect::sampleAligned, _1, _2, time0, time1);
+        mTask = std::bind(&Advect::sampleAligned, ph::_1, ph::_2, time0, time1);
     } else {
-        mTask = boost::bind(&Advect::sampleXformed, _1, _2, time0, time1);
+        mTask = std::bind(&Advect::sampleXformed, ph::_1, ph::_2, time0, time1);
     }
     assert(voxelCount == mParent.mTracker.grid().activeVoxelCount());
     mVelocity = new VectorType[ voxelCount ];
@@ -502,7 +505,7 @@ Advect<MapT, SpatialScheme, TemporalScheme>::
 sample(const LeafRange& range, ValueType time0, ValueType time1)
 {
     const bool isForward = time0 < time1;
-    typedef typename LeafType::ValueOnCIter VoxelIterT;
+    using VoxelIterT = typename LeafType::ValueOnCIter;
     const MapT& map = *mMap;
     const FieldT field( mParent.mField );
     mParent.mTracker.checkInterrupter();
@@ -529,8 +532,8 @@ clearField()
 {
     delete [] mOffsets;
     delete [] mVelocity;
-    mOffsets  = NULL;
-    mVelocity = NULL;
+    mOffsets = nullptr;
+    mVelocity = nullptr;
 }
 
 
@@ -570,10 +573,10 @@ LevelSetAdvection<GridT, FieldT, InterruptT>::
 Advect<MapT, SpatialScheme, TemporalScheme>::
 euler(const LeafRange& range, ValueType dt, Index phiBuffer, Index resultBuffer)
 {
-    typedef math::BIAS_SCHEME<SpatialScheme>                             SchemeT;
-    typedef typename SchemeT::template ISStencil<GridType>::StencilType  StencilT;
-    typedef typename LeafType::ValueOnCIter                              VoxelIterT;
-    typedef math::GradientBiased<MapT, SpatialScheme>                    GradT;
+    using SchemeT = math::BIAS_SCHEME<SpatialScheme>;
+    using StencilT = typename SchemeT::template ISStencil<GridType>::StencilType;
+    using VoxelIterT = typename LeafType::ValueOnCIter;
+    using GradT = math::GradientBiased<MapT, SpatialScheme>;
 
     static const ValueType Alpha = ValueType(Nominator)/ValueType(Denominator);
     static const ValueType Beta  = ValueType(1) - Alpha;
diff --git a/openvdb/tools/LevelSetFilter.h b/openvdb/tools/LevelSetFilter.h
index 44e4d75f..f0738c55 100644
--- a/openvdb/tools/LevelSetFilter.h
+++ b/openvdb/tools/LevelSetFilter.h
@@ -30,7 +30,7 @@
 //
 /// @author Ken Museth
 ///
-/// @file LevelSetFilter.h
+/// @file tools/LevelSetFilter.h
 ///
 /// @brief Performs various types of level set deformations with
 /// interface tracking. These unrestricted deformations include
@@ -42,10 +42,12 @@
 #ifndef OPENVDB_TOOLS_LEVELSETFILTER_HAS_BEEN_INCLUDED
 #define OPENVDB_TOOLS_LEVELSETFILTER_HAS_BEEN_INCLUDED
 
-#include <assert.h>
-#include <boost/type_traits/is_floating_point.hpp>
 #include "LevelSetTracker.h"
 #include "Interpolation.h"
+#include <algorithm> // for std::max()
+#include <functional>
+#include <type_traits>
+
 
 namespace openvdb {
 OPENVDB_USE_VERSION_NAMESPACE
@@ -64,13 +66,14 @@ template<typename GridT,
 class LevelSetFilter : public LevelSetTracker<GridT, InterruptT>
 {
 public:
-    typedef LevelSetTracker<GridT, InterruptT>              BaseType;
-    typedef GridT                                           GridType;
-    typedef MaskT                                           MaskType;
-    typedef typename GridType::TreeType                     TreeType;
-    typedef typename TreeType::ValueType                    ValueType;
-    typedef typename MaskType::ValueType                    AlphaType;
-    BOOST_STATIC_ASSERT(boost::is_floating_point<AlphaType>::value);
+    using BaseType = LevelSetTracker<GridT, InterruptT>;
+    using GridType = GridT;
+    using MaskType = MaskT;
+    using TreeType = typename GridType::TreeType;
+    using ValueType = typename TreeType::ValueType;
+    using AlphaType = typename MaskType::ValueType;
+    static_assert(std::is_floating_point<AlphaType>::value,
+        "LevelSetFilter requires a mask grid with floating-point values");
 
     /// @brief Main constructor from a grid
     /// @param grid The level set to be filtered.
@@ -83,7 +86,7 @@ class LevelSetFilter : public LevelSetTracker<GridT, InterruptT>
     {
     }
     /// @brief Default destructor
-    virtual ~LevelSetFilter() {}
+    ~LevelSetFilter() override {}
 
     /// @brief Return the minimum value of the mask to be used for the
     /// derivation of a smooth alpha value.
@@ -174,13 +177,13 @@ class LevelSetFilter : public LevelSetTracker<GridT, InterruptT>
     // Private struct that implements all the filtering.
     struct Filter
     {
-        typedef typename TreeType::LeafNodeType                  LeafT;
-        typedef typename LeafT::ValueOnIter                      VoxelIterT;
-        typedef typename LeafT::ValueOnCIter                     VoxelCIterT;
-        typedef typename tree::LeafManager<TreeType>::BufferType BufferT;
-        typedef typename tree::LeafManager<TreeType>::LeafRange  LeafRange;
-        typedef typename LeafRange::Iterator                     LeafIterT;
-        typedef tools::AlphaMask<GridT, MaskT>                   AlphaMaskT;
+        using LeafT = typename TreeType::LeafNodeType;
+        using VoxelIterT = typename LeafT::ValueOnIter;
+        using VoxelCIterT = typename LeafT::ValueOnCIter;
+        using BufferT = typename tree::LeafManager<TreeType>::BufferType;
+        using LeafRange = typename tree::LeafManager<TreeType>::LeafRange;
+        using LeafIterT = typename LeafRange::Iterator;
+        using AlphaMaskT = tools::AlphaMask<GridT, MaskT>;
 
         Filter(LevelSetFilter* parent, const MaskType* mask) : mParent(parent), mMask(mask) {}
         Filter(const Filter&) = default;
@@ -225,21 +228,21 @@ class LevelSetFilter : public LevelSetTracker<GridT, InterruptT>
             const ValueType frac;
         };
 
-        template <typename AvgT>
-        void box( const LeafRange& r, Int32 w);
+        template<typename AvgT>
+        void boxImpl(const LeafRange& r, Int32 w);
 
-        void boxX(const LeafRange& r, Int32 w) { this->box<Avg<0> >(r,w); }
-        void boxZ(const LeafRange& r, Int32 w) { this->box<Avg<1> >(r,w); }
-        void boxY(const LeafRange& r, Int32 w) { this->box<Avg<2> >(r,w); }
+        void boxXImpl(const LeafRange& r, Int32 w) { this->boxImpl<Avg<0> >(r,w); }
+        void boxZImpl(const LeafRange& r, Int32 w) { this->boxImpl<Avg<1> >(r,w); }
+        void boxYImpl(const LeafRange& r, Int32 w) { this->boxImpl<Avg<2> >(r,w); }
 
-        void median(const LeafRange&, int);
-        void meanCurvature(const LeafRange&);
-        void laplacian(const LeafRange&);
-        void offset(const LeafRange&, ValueType);
+        void medianImpl(const LeafRange&, int);
+        void meanCurvatureImpl(const LeafRange&);
+        void laplacianImpl(const LeafRange&);
+        void offsetImpl(const LeafRange&, ValueType);
 
         LevelSetFilter* mParent;
         const MaskType* mMask;
-        typename boost::function<void (Filter*, const LeafRange&)> mTask;
+        typename std::function<void (Filter*, const LeafRange&)> mTask;
     }; // end of private Filter struct
 
     AlphaType mMinMask, mMaxMask;
@@ -252,14 +255,14 @@ class LevelSetFilter : public LevelSetTracker<GridT, InterruptT>
 
 template<typename GridT, typename MaskT, typename InterruptT>
 inline void
-LevelSetFilter<GridT, MaskT, InterruptT>::
-Filter::median(int width)
+LevelSetFilter<GridT, MaskT, InterruptT>::Filter::median(int width)
 {
     mParent->startInterrupter("Median-value flow of level set");
 
     mParent->leafs().rebuildAuxBuffers(1, mParent->getGrainSize()==0);
 
-    mTask = boost::bind(&Filter::median, _1, _2, std::max(1, width));
+    mTask = std::bind(&Filter::medianImpl,
+        std::placeholders::_1, std::placeholders::_2, std::max(1, width));
     this->cook(true);
 
     mParent->track();
@@ -269,8 +272,7 @@ Filter::median(int width)
 
 template<typename GridT, typename MaskT, typename InterruptT>
 inline void
-LevelSetFilter<GridT, MaskT, InterruptT>::
-Filter::mean(int width)
+LevelSetFilter<GridT, MaskT, InterruptT>::Filter::mean(int width)
 {
     mParent->startInterrupter("Mean-value flow of level set");
 
@@ -281,8 +283,7 @@ Filter::mean(int width)
 
 template<typename GridT, typename MaskT, typename InterruptT>
 inline void
-LevelSetFilter<GridT, MaskT, InterruptT>::
-Filter::gaussian(int width)
+LevelSetFilter<GridT, MaskT, InterruptT>::Filter::gaussian(int width)
 {
     mParent->startInterrupter("Gaussian flow of level set");
 
@@ -293,20 +294,19 @@ Filter::gaussian(int width)
 
 template<typename GridT, typename MaskT, typename InterruptT>
 inline void
-LevelSetFilter<GridT, MaskT, InterruptT>::
-Filter::box(int width)
+LevelSetFilter<GridT, MaskT, InterruptT>::Filter::box(int width)
 {
     mParent->leafs().rebuildAuxBuffers(1, mParent->getGrainSize()==0);
 
     width = std::max(1, width);
 
-    mTask = boost::bind(&Filter::boxX, _1, _2, width);
+    mTask = std::bind(&Filter::boxXImpl, std::placeholders::_1, std::placeholders::_2, width);
     this->cook(true);
 
-    mTask = boost::bind(&Filter::boxY, _1, _2, width);
+    mTask = std::bind(&Filter::boxYImpl, std::placeholders::_1, std::placeholders::_2, width);
     this->cook(true);
 
-    mTask = boost::bind(&Filter::boxZ, _1, _2, width);
+    mTask = std::bind(&Filter::boxZImpl, std::placeholders::_1, std::placeholders::_2, width);
     this->cook(true);
 
     mParent->track();
@@ -314,14 +314,13 @@ Filter::box(int width)
 
 template<typename GridT, typename MaskT, typename InterruptT>
 inline void
-LevelSetFilter<GridT, MaskT, InterruptT>::
-Filter::meanCurvature()
+LevelSetFilter<GridT, MaskT, InterruptT>::Filter::meanCurvature()
 {
     mParent->startInterrupter("Mean-curvature flow of level set");
 
     mParent->leafs().rebuildAuxBuffers(1, mParent->getGrainSize()==0);
 
-    mTask = boost::bind(&Filter::meanCurvature, _1, _2);
+    mTask = std::bind(&Filter::meanCurvatureImpl, std::placeholders::_1, std::placeholders::_2);
     this->cook(true);
 
     mParent->track();
@@ -331,14 +330,13 @@ Filter::meanCurvature()
 
 template<typename GridT, typename MaskT, typename InterruptT>
 inline void
-LevelSetFilter<GridT, MaskT, InterruptT>::
-Filter::laplacian()
+LevelSetFilter<GridT, MaskT, InterruptT>::Filter::laplacian()
 {
     mParent->startInterrupter("Laplacian flow of level set");
 
     mParent->leafs().rebuildAuxBuffers(1, mParent->getGrainSize()==0);
 
-    mTask = boost::bind(&Filter::laplacian, _1, _2);
+    mTask = std::bind(&Filter::laplacianImpl, std::placeholders::_1, std::placeholders::_2);
     this->cook(true);
 
     mParent->track();
@@ -348,8 +346,7 @@ Filter::laplacian()
 
 template<typename GridT, typename MaskT, typename InterruptT>
 inline void
-LevelSetFilter<GridT, MaskT, InterruptT>::
-Filter::offset(ValueType value)
+LevelSetFilter<GridT, MaskT, InterruptT>::Filter::offset(ValueType value)
 {
     mParent->startInterrupter("Offsetting level set");
 
@@ -361,7 +358,8 @@ Filter::offset(ValueType value)
         const ValueType delta = openvdb::math::Min(offset-dist, CFL);
         dist += delta;
 
-        mTask = boost::bind(&Filter::offset, _1, _2, copysign(delta, value));
+        mTask = std::bind(&Filter::offsetImpl,
+            std::placeholders::_1, std::placeholders::_2, copysign(delta, value));
         this->cook(false);
 
         mParent->track();
@@ -376,8 +374,7 @@ Filter::offset(ValueType value)
 /// Performs parabolic mean-curvature diffusion
 template<typename GridT, typename MaskT, typename InterruptT>
 inline void
-LevelSetFilter<GridT, MaskT, InterruptT>::
-Filter::meanCurvature(const LeafRange& range)
+LevelSetFilter<GridT, MaskT, InterruptT>::Filter::meanCurvatureImpl(const LeafRange& range)
 {
     mParent->checkInterrupter();
     //const float CFL = 0.9f, dt = CFL * mDx * mDx / 6.0f;
@@ -417,8 +414,7 @@ Filter::meanCurvature(const LeafRange& range)
 /// performing Laplacian diffusion over mean curvature flow!
 template<typename GridT, typename MaskT, typename InterruptT>
 inline void
-LevelSetFilter<GridT, MaskT, InterruptT>::
-Filter::laplacian(const LeafRange& range)
+LevelSetFilter<GridT, MaskT, InterruptT>::Filter::laplacianImpl(const LeafRange& range)
 {
     mParent->checkInterrupter();
     //const float CFL = 0.9f, half_dt = CFL * mDx * mDx / 12.0f;
@@ -452,8 +448,8 @@ Filter::laplacian(const LeafRange& range)
 /// Offsets the values by a constant
 template<typename GridT, typename MaskT, typename InterruptT>
 inline void
-LevelSetFilter<GridT, MaskT, InterruptT>::
-Filter::offset(const LeafRange& range, ValueType offset)
+LevelSetFilter<GridT, MaskT, InterruptT>::Filter::offsetImpl(
+    const LeafRange& range, ValueType offset)
 {
     mParent->checkInterrupter();
     if (mMask) {
@@ -477,8 +473,7 @@ Filter::offset(const LeafRange& range, ValueType offset)
 /// Performs simple but slow median-value diffusion
 template<typename GridT, typename MaskT, typename InterruptT>
 inline void
-LevelSetFilter<GridT, MaskT, InterruptT>::
-Filter::median(const LeafRange& range, int width)
+LevelSetFilter<GridT, MaskT, InterruptT>::Filter::medianImpl(const LeafRange& range, int width)
 {
     mParent->checkInterrupter();
     typename math::DenseStencil<GridType> stencil(mParent->grid(), width);//creates local cache!
@@ -510,8 +505,7 @@ Filter::median(const LeafRange& range, int width)
 template<typename GridT, typename MaskT, typename InterruptT>
 template <typename AvgT>
 inline void
-LevelSetFilter<GridT, MaskT, InterruptT>::
-Filter::box(const LeafRange& range, Int32 w)
+LevelSetFilter<GridT, MaskT, InterruptT>::Filter::boxImpl(const LeafRange& range, Int32 w)
 {
     mParent->checkInterrupter();
     AvgT avg(mParent->grid(), w);
diff --git a/openvdb/tools/LevelSetMorph.h b/openvdb/tools/LevelSetMorph.h
index 03d4b770..5a5b9825 100644
--- a/openvdb/tools/LevelSetMorph.h
+++ b/openvdb/tools/LevelSetMorph.h
@@ -30,7 +30,7 @@
 
 /// @author Ken Museth
 ///
-/// @file LevelSetMorph.h
+/// @file tools/LevelSetMorph.h
 ///
 /// @brief Shape morphology of level sets. Morphing from a source
 /// narrow-band level sets to a target narrow-band level set.
@@ -41,13 +41,15 @@
 #include "LevelSetTracker.h"
 #include "Interpolation.h" // for BoxSampler, etc.
 #include <openvdb/math/FiniteDifference.h>
+#include <functional>
+#include <limits>
+
 
 namespace openvdb {
 OPENVDB_USE_VERSION_NAMESPACE
 namespace OPENVDB_VERSION_NAME {
 namespace tools {
 
-
 /// @brief Shape morphology of level sets. Morphing from a source
 /// narrow-band level sets to a target narrow-band level set.
 ///
@@ -72,13 +74,13 @@ template<typename GridT,
 class LevelSetMorphing
 {
 public:
-    typedef GridT                              GridType;
-    typedef typename GridT::TreeType           TreeType;
-    typedef LevelSetTracker<GridT, InterruptT> TrackerT;
-    typedef typename TrackerT::LeafRange       LeafRange;
-    typedef typename TrackerT::LeafType        LeafType;
-    typedef typename TrackerT::BufferType      BufferType;
-    typedef typename TrackerT::ValueType       ValueType;
+    using GridType = GridT;
+    using TreeType = typename GridT::TreeType;
+    using TrackerT = LevelSetTracker<GridT, InterruptT>;
+    using LeafRange = typename TrackerT::LeafRange;
+    using LeafType = typename TrackerT::LeafType;
+    using BufferType = typename TrackerT::BufferType;
+    using ValueType = typename TrackerT::ValueType;
 
     /// Main constructor
     LevelSetMorphing(GridT& sourceGrid, const GridT& targetGrid, InterruptT* interrupt = nullptr)
@@ -252,7 +254,7 @@ class LevelSetMorphing
         inline void euler34(const LeafRange& r, ValueType t) {this->euler<3,4>(r, t, 1, 2, 3);}
         inline void euler13(const LeafRange& r, ValueType t) {this->euler<1,3>(r, t, 1, 2, 3);}
 
-        typedef typename boost::function<void (Morph*, const LeafRange&)> FuncType;
+        using FuncType = typename std::function<void (Morph*, const LeafRange&)>;
         LevelSetMorphing* mParent;
         ValueType         mMinAbsS, mMaxAbsS;
         const MapT*       mMap;
@@ -393,6 +395,8 @@ LevelSetMorphing<GridT, InterruptT>::
 Morph<MapT, SpatialScheme, TemporalScheme>::
 advect(ValueType time0, ValueType time1)
 {
+    namespace ph = std::placeholders;
+
     // Make sure we have enough temporal auxiliary buffers for the time
     // integration AS WELL AS an extra buffer with the speed function!
     static const Index auxBuffers = 1 + (TemporalScheme == math::TVD_RK3 ? 2 : 1);
@@ -408,7 +412,7 @@ advect(ValueType time0, ValueType time1)
         case math::TVD_RK1:
             // Perform one explicit Euler step: t1 = t0 + dt
             // Phi_t1(1) = Phi_t0(0) - dt * Speed(2) * |Grad[Phi(0)]|
-            mTask = boost::bind(&Morph::euler01, _1, _2, dt, /*speed*/2);
+            mTask = std::bind(&Morph::euler01, ph::_1, ph::_2, dt, /*speed*/2);
 
             // Cook and swap buffer 0 and 1 such that Phi_t1(0) and Phi_t0(1)
             this->cook(PARALLEL_FOR, 1);
@@ -416,14 +420,14 @@ advect(ValueType time0, ValueType time1)
         case math::TVD_RK2:
             // Perform one explicit Euler step: t1 = t0 + dt
             // Phi_t1(1) = Phi_t0(0) - dt * Speed(2) * |Grad[Phi(0)]|
-            mTask = boost::bind(&Morph::euler01, _1, _2, dt, /*speed*/2);
+            mTask = std::bind(&Morph::euler01, ph::_1, ph::_2, dt, /*speed*/2);
 
             // Cook and swap buffer 0 and 1 such that Phi_t1(0) and Phi_t0(1)
             this->cook(PARALLEL_FOR, 1);
 
             // Convex combine explict Euler step: t2 = t0 + dt
             // Phi_t2(1) = 1/2 * Phi_t0(1) + 1/2 * (Phi_t1(0) - dt * Speed(2) * |Grad[Phi(0)]|)
-            mTask = boost::bind(&Morph::euler12, _1, _2, dt);
+            mTask = std::bind(&Morph::euler12, ph::_1, ph::_2, dt);
 
             // Cook and swap buffer 0 and 1 such that Phi_t2(0) and Phi_t1(1)
             this->cook(PARALLEL_FOR, 1);
@@ -431,21 +435,21 @@ advect(ValueType time0, ValueType time1)
         case math::TVD_RK3:
             // Perform one explicit Euler step: t1 = t0 + dt
             // Phi_t1(1) = Phi_t0(0) - dt * Speed(3) * |Grad[Phi(0)]|
-            mTask = boost::bind(&Morph::euler01, _1, _2, dt, /*speed*/3);
+            mTask = std::bind(&Morph::euler01, ph::_1, ph::_2, dt, /*speed*/3);
 
             // Cook and swap buffer 0 and 1 such that Phi_t1(0) and Phi_t0(1)
             this->cook(PARALLEL_FOR, 1);
 
             // Convex combine explict Euler step: t2 = t0 + dt/2
             // Phi_t2(2) = 3/4 * Phi_t0(1) + 1/4 * (Phi_t1(0) - dt * Speed(3) * |Grad[Phi(0)]|)
-            mTask = boost::bind(&Morph::euler34, _1, _2, dt);
+            mTask = std::bind(&Morph::euler34, ph::_1, ph::_2, dt);
 
             // Cook and swap buffer 0 and 2 such that Phi_t2(0) and Phi_t1(2)
             this->cook(PARALLEL_FOR, 2);
 
             // Convex combine explict Euler step: t3 = t0 + dt
             // Phi_t3(2) = 1/3 * Phi_t0(1) + 2/3 * (Phi_t2(0) - dt * Speed(3) * |Grad[Phi(0)]|)
-            mTask = boost::bind(&Morph::euler13, _1, _2, dt);
+            mTask = std::bind(&Morph::euler13, ph::_1, ph::_2, dt);
 
             // Cook and swap buffer 0 and 2 such that Phi_t3(0) and Phi_t2(2)
             this->cook(PARALLEL_FOR, 2);
@@ -475,6 +479,8 @@ LevelSetMorphing<GridT, InterruptT>::
 Morph<MapT, SpatialScheme, TemporalScheme>::
 sampleSpeed(ValueType time0, ValueType time1, Index speedBuffer)
 {
+    namespace ph = std::placeholders;
+
     mMaxAbsS = mMinAbsS;
     const size_t leafCount = mParent->mTracker.leafs().leafCount();
     if (leafCount==0 || time0 >= time1) return ValueType(0);
@@ -482,9 +488,9 @@ sampleSpeed(ValueType time0, ValueType time1, Index speedBuffer)
     const math::Transform& xform  = mParent->mTracker.grid().transform();
     if (mParent->mTarget->transform() == xform &&
         (mParent->mMask == nullptr || mParent->mMask->transform() == xform)) {
-        mTask = boost::bind(&Morph::sampleAlignedSpeed, _1, _2, speedBuffer);
+        mTask = std::bind(&Morph::sampleAlignedSpeed, ph::_1, ph::_2, speedBuffer);
     } else {
-        mTask = boost::bind(&Morph::sampleXformedSpeed, _1, _2, speedBuffer);
+        mTask = std::bind(&Morph::sampleXformedSpeed, ph::_1, ph::_2, speedBuffer);
     }
     this->cook(PARALLEL_REDUCE);
     if (math::isApproxEqual(mMinAbsS, mMaxAbsS)) return ValueType(0);//speed is essentially zero
@@ -503,8 +509,9 @@ LevelSetMorphing<GridT, InterruptT>::
 Morph<MapT, SpatialScheme, TemporalScheme>::
 sampleXformedSpeed(const LeafRange& range, Index speedBuffer)
 {
-    typedef typename LeafType::ValueOnCIter VoxelIterT;
-    typedef tools::GridSampler<typename GridT::ConstAccessor, tools::BoxSampler> SamplerT;
+    using VoxelIterT = typename LeafType::ValueOnCIter;
+    using SamplerT = tools::GridSampler<typename GridT::ConstAccessor, tools::BoxSampler>;
+
     const MapT& map = *mMap;
     mParent->mTracker.checkInterrupter();
 
@@ -552,7 +559,8 @@ LevelSetMorphing<GridT, InterruptT>::
 Morph<MapT, SpatialScheme, TemporalScheme>::
 sampleAlignedSpeed(const LeafRange& range, Index speedBuffer)
 {
-    typedef typename LeafType::ValueOnCIter VoxelIterT;
+    using VoxelIterT = typename LeafType::ValueOnCIter;
+
     mParent->mTracker.checkInterrupter();
 
     typename GridT::ConstAccessor target = mParent->mTarget->getAccessor();
@@ -610,7 +618,8 @@ cook(ThreadingMode mode, size_t swapBuffer)
     } else if (mode == PARALLEL_REDUCE) {
         tbb::parallel_reduce(range, *this);
     } else {
-        throw std::runtime_error("Undefined threading mode");
+        OPENVDB_THROW(ValueError, "expected threading mode " << int(PARALLEL_FOR)
+            << " or " << int(PARALLEL_REDUCE) << ", got " << int(mode));
     }
 
     mParent->mTracker.leafs().swapLeafBuffer(swapBuffer, grainSize == 0);
@@ -628,10 +637,10 @@ Morph<MapT, SpatialScheme, TemporalScheme>::
 euler(const LeafRange& range, ValueType dt,
       Index phiBuffer, Index resultBuffer, Index speedBuffer)
 {
-    typedef math::BIAS_SCHEME<SpatialScheme>                             SchemeT;
-    typedef typename SchemeT::template ISStencil<GridType>::StencilType  StencilT;
-    typedef typename LeafType::ValueOnCIter                              VoxelIterT;
-    typedef math::GradientNormSqrd<MapT, SpatialScheme>                  NumGrad;
+    using SchemeT = math::BIAS_SCHEME<SpatialScheme>;
+    using StencilT = typename SchemeT::template ISStencil<GridType>::StencilType;
+    using VoxelIterT = typename LeafType::ValueOnCIter;
+    using NumGrad = math::GradientNormSqrd<MapT, SpatialScheme>;
 
     static const ValueType Alpha = ValueType(Nominator)/ValueType(Denominator);
     static const ValueType Beta  = ValueType(1) - Alpha;
diff --git a/openvdb/tools/LevelSetTracker.h b/openvdb/tools/LevelSetTracker.h
index d2a5d614..477416a4 100644
--- a/openvdb/tools/LevelSetTracker.h
+++ b/openvdb/tools/LevelSetTracker.h
@@ -30,7 +30,7 @@
 
 /// @author Ken Museth
 ///
-/// @file LevelSetTracker.h
+/// @file tools/LevelSetTracker.h
 ///
 /// @brief Performs multi-threaded interface tracking of narrow band
 /// level sets. This is the building-block for most level set
@@ -40,9 +40,6 @@
 #define OPENVDB_TOOLS_LEVEL_SET_TRACKER_HAS_BEEN_INCLUDED
 
 #include <tbb/parallel_for.h>
-#include <boost/bind.hpp>
-#include <boost/function.hpp>
-#include <type_traits>
 #include <openvdb/Types.h>
 #include <openvdb/math/Math.h>
 #include <openvdb/math/FiniteDifference.h>
@@ -56,6 +53,9 @@
 #include "ChangeBackground.h"// for changeLevelSetBackground
 #include "Morphology.h"//for dilateActiveValues
 #include "Prune.h"// for pruneLevelSet
+#include <functional>
+#include <type_traits>
+
 
 namespace openvdb {
 OPENVDB_USE_VERSION_NAMESPACE
@@ -67,14 +67,14 @@ template<typename GridT, typename InterruptT = util::NullInterrupter>
 class LevelSetTracker
 {
 public:
-    typedef GridT                                GridType;
-    typedef typename GridT::TreeType             TreeType;
-    typedef typename TreeType::LeafNodeType      LeafType;
-    typedef typename TreeType::ValueType         ValueType;
-    typedef typename tree::LeafManager<TreeType> LeafManagerType; // leafs + buffers
-    typedef typename LeafManagerType::LeafRange  LeafRange;
-    typedef typename LeafManagerType::BufferType BufferType;
-    typedef typename TreeType::template ValueConverter<ValueMask>::Type MaskTreeType;
+    using GridType = GridT;
+    using TreeType = typename GridT::TreeType;
+    using LeafType = typename TreeType::LeafNodeType;
+    using ValueType = typename TreeType::ValueType;
+    using LeafManagerType = typename tree::LeafManager<TreeType>; // leafs + buffers
+    using LeafRange = typename LeafManagerType::LeafRange;
+    using BufferType = typename LeafManagerType::BufferType;
+    using MaskTreeType = typename TreeType::template ValueConverter<ValueMask>::Type;
     static_assert(std::is_floating_point<ValueType>::value,
         "LevelSetTracker requires a level set grid with floating-point values");
 
@@ -209,11 +209,12 @@ class LevelSetTracker
              typename MaskT>
     struct Normalizer
     {
-        typedef math::BIAS_SCHEME<SpatialScheme>                             SchemeT;
-        typedef typename SchemeT::template ISStencil<GridType>::StencilType  StencilT;
-        typedef typename MaskT::LeafNodeType MaskLeafT;
-        typedef typename MaskLeafT::ValueOnCIter MaskIterT;
-        typedef typename LeafType::ValueOnCIter VoxelIterT;
+        using SchemeT = math::BIAS_SCHEME<SpatialScheme>;
+        using StencilT = typename SchemeT::template ISStencil<GridType>::StencilType;
+        using MaskLeafT = typename MaskT::LeafNodeType;
+        using MaskIterT = typename MaskLeafT::ValueOnCIter;
+        using VoxelIterT = typename LeafType::ValueOnCIter;
+
         Normalizer(LevelSetTracker& tracker, const MaskT* mask);
         void normalize();
         void operator()(const LeafRange& r) const {mTask(const_cast<Normalizer*>(this), r);}
@@ -229,7 +230,7 @@ class LevelSetTracker
         LevelSetTracker& mTracker;
         const MaskT*     mMask;
         const ValueType  mDt, mInvDx;
-        typename boost::function<void (Normalizer*, const LeafRange&)> mTask;
+        typename std::function<void (Normalizer*, const LeafRange&)> mTask;
     }; // Normalizer struct
 
     template<math::BiasedGradientScheme SpatialScheme, typename MaskT>
@@ -458,7 +459,7 @@ inline void
 LevelSetTracker<GridT, InterruptT>::
 Trim::operator()(const LeafRange& range) const
 {
-    typedef typename LeafType::ValueOnIter VoxelIterT;
+    using VoxelIterT = typename LeafType::ValueOnIter;
     mTracker.checkInterrupter();
     const ValueType gamma = mTracker.mGrid->background();
 
@@ -502,6 +503,8 @@ LevelSetTracker<GridT, InterruptT>::
 Normalizer<SpatialScheme, TemporalScheme, MaskT>::
 normalize()
 {
+    namespace ph = std::placeholders;
+
     /// Make sure we have enough temporal auxiliary buffers
     mTracker.mLeafs->rebuildAuxBuffers(TemporalScheme == math::TVD_RK3 ? 2 : 1);
 
@@ -512,7 +515,7 @@ normalize()
         case math::TVD_RK1:
             // Perform one explicit Euler step: t1 = t0 + dt
             // Phi_t1(0) = Phi_t0(0) - dt * VdotG_t0(1)
-            mTask = boost::bind(&Normalizer::euler01, _1, _2);
+            mTask = std::bind(&Normalizer::euler01, ph::_1, ph::_2);
 
             // Cook and swap buffer 0 and 1 such that Phi_t1(0) and Phi_t0(1)
             this->cook("Normalizing level set using TVD_RK1", 1);
@@ -520,14 +523,14 @@ normalize()
         case math::TVD_RK2:
             // Perform one explicit Euler step: t1 = t0 + dt
             // Phi_t1(1) = Phi_t0(0) - dt * VdotG_t0(1)
-            mTask = boost::bind(&Normalizer::euler01, _1, _2);
+            mTask = std::bind(&Normalizer::euler01, ph::_1, ph::_2);
 
             // Cook and swap buffer 0 and 1 such that Phi_t1(0) and Phi_t0(1)
             this->cook("Normalizing level set using TVD_RK1 (step 1 of 2)", 1);
 
             // Convex combine explicit Euler step: t2 = t0 + dt
             // Phi_t2(1) = 1/2 * Phi_t0(1) + 1/2 * (Phi_t1(0) - dt * V.Grad_t1(0))
-            mTask = boost::bind(&Normalizer::euler12, _1, _2);
+            mTask = std::bind(&Normalizer::euler12, ph::_1, ph::_2);
 
             // Cook and swap buffer 0 and 1 such that Phi_t2(0) and Phi_t1(1)
             this->cook("Normalizing level set using TVD_RK1 (step 2 of 2)", 1);
@@ -535,21 +538,21 @@ normalize()
         case math::TVD_RK3:
             // Perform one explicit Euler step: t1 = t0 + dt
             // Phi_t1(1) = Phi_t0(0) - dt * VdotG_t0(1)
-            mTask = boost::bind(&Normalizer::euler01, _1, _2);
+            mTask = std::bind(&Normalizer::euler01, ph::_1, ph::_2);
 
             // Cook and swap buffer 0 and 1 such that Phi_t1(0) and Phi_t0(1)
             this->cook("Normalizing level set using TVD_RK3 (step 1 of 3)", 1);
 
             // Convex combine explicit Euler step: t2 = t0 + dt/2
             // Phi_t2(2) = 3/4 * Phi_t0(1) + 1/4 * (Phi_t1(0) - dt * V.Grad_t1(0))
-            mTask = boost::bind(&Normalizer::euler34, _1, _2);
+            mTask = std::bind(&Normalizer::euler34, ph::_1, ph::_2);
 
             // Cook and swap buffer 0 and 2 such that Phi_t2(0) and Phi_t1(2)
             this->cook("Normalizing level set using TVD_RK3 (step 2 of 3)", 2);
 
             // Convex combine explicit Euler step: t3 = t0 + dt
             // Phi_t3(2) = 1/3 * Phi_t0(1) + 2/3 * (Phi_t2(0) - dt * V.Grad_t2(0)
-            mTask = boost::bind(&Normalizer::euler13, _1, _2);
+            mTask = std::bind(&Normalizer::euler13, ph::_1, ph::_2);
 
             // Cook and swap buffer 0 and 2 such that Phi_t3(0) and Phi_t2(2)
             this->cook("Normalizing level set using TVD_RK3 (step 3 of 3)", 2);
@@ -596,7 +599,7 @@ LevelSetTracker<GridT, InterruptT>::
 Normalizer<SpatialScheme, TemporalScheme, MaskT>::
 eval(StencilT& stencil, const ValueType* phi, ValueType* result, Index n) const
 {
-    typedef typename math::ISGradientNormSqrd<SpatialScheme> GradientT;
+    using GradientT = typename math::ISGradientNormSqrd<SpatialScheme>;
     static const ValueType alpha = ValueType(Nominator)/ValueType(Denominator);
     static const ValueType beta  = ValueType(1) - alpha;
 
@@ -618,7 +621,7 @@ LevelSetTracker<GridT,InterruptT>::
 Normalizer<SpatialScheme, TemporalScheme, MaskT>::
 euler(const LeafRange& range, Index phiBuffer, Index resultBuffer)
 {
-    typedef typename LeafType::ValueOnCIter VoxelIterT;
+    using VoxelIterT = typename LeafType::ValueOnCIter;
 
     mTracker.checkInterrupter();
 
diff --git a/openvdb/tools/ParticlesToLevelSet.h b/openvdb/tools/ParticlesToLevelSet.h
index c7c25489..81d8bc75 100644
--- a/openvdb/tools/ParticlesToLevelSet.h
+++ b/openvdb/tools/ParticlesToLevelSet.h
@@ -30,7 +30,7 @@
 
 /// @author Ken Museth
 ///
-/// @file ParticlesToLevelSet.h
+/// @file tools/ParticlesToLevelSet.h
 ///
 /// @brief This tool converts particles (with position, radius and velocity)
 /// into a signed distance field encoded as a narrow band level set.
@@ -53,7 +53,7 @@
 /// class ParticleList {
 ///   ...
 /// public:
-///   typedef openvdb::Vec3R  PosType;
+///   using PosType = openvdb::Vec3R;
 ///
 ///   // Return the total number of particles in list.
 ///   // Always required!
@@ -100,11 +100,6 @@
 
 #include <tbb/parallel_reduce.h>
 #include <tbb/blocked_range.h>
-#include <boost/bind.hpp>
-#include <boost/function.hpp>
-#include <boost/type_traits/is_floating_point.hpp>
-#include <boost/utility/enable_if.hpp>
-#include <boost/mpl/if.hpp>
 #include <openvdb/Types.h>
 #include <openvdb/Grid.h>
 #include <openvdb/math/Math.h>
@@ -114,6 +109,9 @@
 #include "PointPartitioner.h"
 #include "Prune.h"
 #include "SignedFloodFill.h"
+#include <iostream>
+#include <type_traits>
+
 
 namespace openvdb {
 OPENVDB_USE_VERSION_NAMESPACE
@@ -134,16 +132,17 @@ template<typename SdfGridT,
 class ParticlesToLevelSet
 {
 public:
-    typedef typename boost::is_void<AttributeT>::type DisableT;
-    typedef InterrupterT                          InterrupterType;
+    using DisableT = typename std::is_void<AttributeT>::type;
+    using InterrupterType = InterrupterT;
 
-    typedef SdfGridT                              SdfGridType;
-    typedef typename SdfGridT::ValueType          SdfType;
+    using SdfGridType = SdfGridT;
+    using SdfType = typename SdfGridT::ValueType;
 
-    typedef typename boost::mpl::if_<DisableT, size_t, AttributeT>::type  AttType;
-    typedef typename SdfGridT::template ValueConverter<AttType>::Type AttGridType;
+    using AttType = typename std::conditional<DisableT::value, size_t, AttributeT>::type;
+    using AttGridType = typename SdfGridT::template ValueConverter<AttType>::Type;
 
-    BOOST_STATIC_ASSERT(boost::is_floating_point<SdfType>::value);
+    static_assert(std::is_floating_point<SdfType>::value,
+        "ParticlesToLevelSet requires an SDF grid with floating-point values");
 
     /// @brief Constructor using an exiting signed distance,
     /// i.e. narrow band level set, grid.
@@ -252,8 +251,8 @@ class ParticlesToLevelSet
     void rasterizeTrails(const ParticleListT& pa, Real delta=1.0);
 
 private:
-    typedef p2ls_internal::BlindData<SdfType, AttType> BlindType;
-    typedef typename SdfGridT::template ValueConverter<BlindType>::Type BlindGridType;
+    using BlindType = p2ls_internal::BlindData<SdfType, AttType>;
+    using BlindGridType = typename SdfGridT::template ValueConverter<BlindType>::Type;
 
     /// Class with multi-threaded implementation of particle rasterization
     template<typename ParticleListT, typename GridT> struct Raster;
@@ -352,9 +351,9 @@ ParticlesToLevelSet<SdfGridT, AttributeT, InterrupterT>::finalize(bool prune)
         if (prune) tools::prune(mBlindGrid->tree());
     }
 
-    typedef typename SdfGridType::TreeType   SdfTreeT;
-    typedef typename AttGridType::TreeType   AttTreeT;
-    typedef typename BlindGridType::TreeType BlindTreeT;
+    using SdfTreeT = typename SdfGridType::TreeType;
+    using AttTreeT = typename AttGridType::TreeType;
+    using BlindTreeT = typename BlindGridType::TreeType;
     // Use topology copy constructors since output grids have the same topology as mBlindDataGrid
     const BlindTreeT& tree = mBlindGrid->tree();
 
@@ -371,10 +370,10 @@ ParticlesToLevelSet<SdfGridT, AttributeT, InterrupterT>::finalize(bool prune)
     // Extract the level set and IDs from mBlindDataGrid. We will
     // explore the fact that by design active values always live
     // at the leaf node level, i.e. level sets have no active tiles!
-    typedef typename BlindTreeT::LeafCIter    LeafIterT;
-    typedef typename BlindTreeT::LeafNodeType LeafT;
-    typedef typename SdfTreeT::LeafNodeType   SdfLeafT;
-    typedef typename AttTreeT::LeafNodeType   AttLeafT;
+    using LeafIterT = typename BlindTreeT::LeafCIter;
+    using LeafT = typename BlindTreeT::LeafNodeType;
+    using SdfLeafT = typename SdfTreeT::LeafNodeType;
+    using AttLeafT = typename AttTreeT::LeafNodeType;
     for (LeafIterT n = tree.cbeginLeaf(); n; ++n) {
         const LeafT& leaf = *n;
         const openvdb::Coord xyz = leaf.origin();
@@ -414,15 +413,15 @@ template<typename SdfGridT, typename AttributeT, typename InterrupterT>
 template<typename ParticleListT, typename GridT>
 struct ParticlesToLevelSet<SdfGridT, AttributeT, InterrupterT>::Raster
 {
-    typedef typename boost::is_void<AttributeT>::type DisableT;
-    typedef ParticlesToLevelSet<SdfGridT, AttributeT, InterrupterT> ParticlesToLevelSetT;
-    typedef typename ParticlesToLevelSetT::SdfType   SdfT;//type of signed distance values
-    typedef typename ParticlesToLevelSetT::AttType   AttT;//type of particle attribute
-    typedef typename GridT::ValueType                ValueT;
-    typedef typename GridT::Accessor                 AccessorT;
-    typedef typename GridT::TreeType                 TreeT;
-    typedef typename TreeT::LeafNodeType             LeafNodeT;
-    typedef PointPartitioner<Index32, LeafNodeT::LOG2DIM> PointPartitionerT;
+    using DisableT = typename std::is_void<AttributeT>::type;
+    using ParticlesToLevelSetT = ParticlesToLevelSet<SdfGridT, AttributeT, InterrupterT>;
+    using SdfT = typename ParticlesToLevelSetT::SdfType; // type of signed distance values
+    using AttT = typename ParticlesToLevelSetT::AttType; // type of particle attribute
+    using ValueT = typename GridT::ValueType;
+    using AccessorT = typename GridT::Accessor;
+    using TreeT = typename GridT::TreeType;
+    using LeafNodeT = typename TreeT::LeafNodeType;
+    using PointPartitionerT = PointPartitioner<Index32, LeafNodeT::LOG2DIM>;
 
 
     /// @brief Main constructor
@@ -473,7 +472,7 @@ struct ParticlesToLevelSet<SdfGridT, AttributeT, InterrupterT>::Raster
         if (mParent.mInterrupter) {
             mParent.mInterrupter->start("Rasterizing particles to level set using spheres");
         }
-        mTask = boost::bind(&Raster::rasterSpheres, _1, _2);
+        mTask = std::bind(&Raster::rasterSpheres, std::placeholders::_1, std::placeholders::_2);
         this->cook();
         if (mParent.mInterrupter) mParent.mInterrupter->end();
     }
@@ -492,7 +491,8 @@ struct ParticlesToLevelSet<SdfGridT, AttributeT, InterrupterT>::Raster
                 mParent.mInterrupter->start(
                     "Rasterizing particles to level set using const spheres");
             }
-            mTask = boost::bind(&Raster::rasterFixedSpheres, _1, _2, SdfT(radius));
+            mTask = std::bind(&Raster::rasterFixedSpheres,
+                std::placeholders::_1, std::placeholders::_2, SdfT(radius));
             this->cook();
             if (mParent.mInterrupter) mParent.mInterrupter->end();
         }
@@ -517,7 +517,8 @@ struct ParticlesToLevelSet<SdfGridT, AttributeT, InterrupterT>::Raster
         if (mParent.mInterrupter) {
             mParent.mInterrupter->start("Rasterizing particles to level set using trails");
         }
-        mTask = boost::bind(&Raster::rasterTrails, _1, _2, SdfT(delta));
+        mTask = std::bind(&Raster::rasterTrails,
+            std::placeholders::_1, std::placeholders::_2, SdfT(delta));
         this->cook();
         if (mParent.mInterrupter) mParent.mInterrupter->end();
     }
@@ -747,22 +748,22 @@ struct ParticlesToLevelSet<SdfGridT, AttributeT, InterrupterT>::Raster
         }//end loop over x
         return true;
     }
-    typedef typename boost::function<void (Raster*, const tbb::blocked_range<size_t>&)> FuncType;
+    using FuncType = typename std::function<void (Raster*, const tbb::blocked_range<size_t>&)>;
 
-    template <typename DisableType>
-    typename boost::enable_if<DisableType>::type
-    getAtt(size_t, AttT&) const {;}
+    template<typename DisableType>
+    typename std::enable_if<DisableType::value>::type
+    getAtt(size_t, AttT&) const {}
 
-    template <typename DisableType>
-    typename boost::disable_if<DisableType>::type
+    template<typename DisableType>
+    typename std::enable_if<!DisableType::value>::type
     getAtt(size_t n, AttT& a) const { mParticles.getAtt(n, a); }
 
-    template <typename T>
-    typename boost::enable_if<boost::is_same<T,ValueT>, ValueT>::type
+    template<typename T>
+    typename std::enable_if<std::is_same<T, ValueT>::value, ValueT>::type
     Merge(T s, const AttT&) const { return s; }
 
-    template <typename T>
-    typename boost::disable_if<boost::is_same<T,ValueT>, ValueT>::type
+    template<typename T>
+    typename std::enable_if<!std::is_same<T, ValueT>::value, ValueT>::type
     Merge(T s, const AttT& a) const { return ValueT(s,a); }
 
     ParticlesToLevelSetT& mParent;
@@ -787,9 +788,9 @@ template<typename VisibleT, typename BlindT>
 class BlindData
 {
 public:
-    typedef VisibleT type;
-    typedef VisibleT VisibleType;
-    typedef BlindT   BlindType;
+    using type = VisibleT;
+    using VisibleType = VisibleT;
+    using BlindType = BlindT;
 
     BlindData() {}
     explicit BlindData(VisibleT v) : mVisible(v), mBlind(zeroVal<BlindType>()) {}
diff --git a/openvdb/tools/VolumeAdvect.h b/openvdb/tools/VolumeAdvect.h
index c648e1a5..c96197b4 100644
--- a/openvdb/tools/VolumeAdvect.h
+++ b/openvdb/tools/VolumeAdvect.h
@@ -32,7 +32,7 @@
 //
 /// @author Ken Museth
 ///
-/// @file VolumeAdvect.h
+/// @file tools/VolumeAdvect.h
 ///
 /// @brief Sparse hyperbolic advection of volumes, e.g. a density or
 ///        velocity (vs a level set interface).
@@ -41,8 +41,6 @@
 #define OPENVDB_TOOLS_VOLUME_ADVECT_HAS_BEEN_INCLUDED
 
 #include <tbb/parallel_for.h>
-#include <boost/bind.hpp>
-#include <boost/function.hpp>
 #include <openvdb/Types.h>
 #include <openvdb/math/Math.h>
 #include <openvdb/util/NullInterrupter.h>
@@ -51,56 +49,57 @@
 #include "Morphology.h"//for dilateActiveValues and dilateVoxels
 #include "Prune.h"// for prune
 #include "Statistics.h" // for extrema
+#include <functional>
+
 
 namespace openvdb {
 OPENVDB_USE_VERSION_NAMESPACE
 namespace OPENVDB_VERSION_NAME {
-namespace tools {      
+namespace tools {
 
-   
 namespace Scheme {
     /// @brief Numerical advections schemes.
     enum SemiLagrangian { SEMI, MID, RK3, RK4, MAC, BFECC };
     /// @brief Flux-limiters employed to stabalize the second-order
     /// advection schemes MacCormack and BFECC.
-    enum Limiter { NO_LIMITER, CLAMP, REVERT }; 
+    enum Limiter { NO_LIMITER, CLAMP, REVERT };
 }
-    
+
 /// @brief Performs advections of an arbitrary type of volume in a
 ///        static velocity field. The advections are performed by means
 ///        of various derivatives of Semi-Lagrangian integration, i.e.
 ///        backwards tracking along the hyperbolic characteristics
-///        followed by interpolation.     
+///        followed by interpolation.
 ///
 /// @note  Optionally a limiter can be combined with the higher-order
 ///        integration schemes MacCormack and BFECC. There are two
 ///        types of limiters (CLAMP and REVERT) that supress
 ///        non-physical oscillations by means of either claminging or
 ///        reverting to a first-order schemes when the function is not
-///        bounded by the cell values used for tri-linear interpolation. 
-///    
+///        bounded by the cell values used for tri-linear interpolation.
+///
 /// @verbatim The supported integrations schemes:
-///    
+///
 ///    ================================================================
 ///    |  Lable | Accuracy |  Integration Scheme   |  Interpolations  |
 ///    |        |Time/Space|                       |  velocity/volume |
-///    ================================================================    
-///    |  SEMI  |   1/1    | Semi-Lagrangian       |        1/1       | 
+///    ================================================================
+///    |  SEMI  |   1/1    | Semi-Lagrangian       |        1/1       |
 ///    |  MID   |   2/1    | Mid-Point             |        2/1       |
 ///    |  RK3   |   3/1    | 3rd Order Runge-Kutta |        3/1       |
 ///    |  RK4   |   4/1    | 4th Order Runge-Kutta |        4/1       |
 ///    |  MAC   |   2/2    | MacCormack            |        2/2       |
-///    |  BFECC |   2/2    | BFECC                 |        3/2       |           
+///    |  BFECC |   2/2    | BFECC                 |        3/2       |
 ///    ================================================================
 /// @endverbatim
-    
+
 template<typename VelocityGridT = Vec3fGrid,
          bool StaggeredVelocity = false,
          typename InterrupterType = util::NullInterrupter>
 class VolumeAdvection
 {
 public:
-    
+
     /// @brief Constructor
     ///
     /// @param velGrid     Velocity grid responsible for the (passive) advection.
@@ -108,7 +107,7 @@ class VolumeAdvection
     ///
     /// @note The velocity field is assumed to be constant for the duration of the
     ///       advection.
-    VolumeAdvection(const VelocityGridT& velGrid, InterrupterType* interrupter = NULL)
+    VolumeAdvection(const VelocityGridT& velGrid, InterrupterType* interrupter = nullptr)
         : mVelGrid(velGrid)
         , mInterrupter(interrupter)
         , mIntegrator( Scheme::SEMI )
@@ -129,7 +128,7 @@ class VolumeAdvection
     ///
     /// @note This is the optimal order in smooth regions. In
     /// non-smooth regions the flux-limiter will drop the order of
-    /// accuracy to add numerical dissipation. 
+    /// accuracy to add numerical dissipation.
     int spatialOrder() const { return (mIntegrator == Scheme::MAC ||
                                        mIntegrator == Scheme::BFECC) ? 2 : 1; }
 
@@ -166,7 +165,7 @@ class VolumeAdvection
     /// the current settings.
     bool isLimiterOn() const { return this->spatialOrder()>1 &&
                                       mLimiter != Scheme::NO_LIMITER; }
-    
+
     /// @return the grain-size used for multi-threading
     /// @note A grainsize of 0 implies serial execution
     size_t getGrainSize() const { return mGrainSize; }
@@ -245,7 +244,7 @@ class VolumeAdvection
             this->template cook<VolumeGridT, VolumeSamplerT>(*tmpGrid, *outGrid, dt);
             outGrid.swap( tmpGrid );
         }
-        
+
         return outGrid;
     }
 
@@ -318,7 +317,7 @@ class VolumeAdvection
     void stop() const
     {
         if (mInterrupter) mInterrupter->end();
-    }      
+    }
     bool interrupt() const
     {
         if (mInterrupter && util::wasInterrupted(mInterrupter)) {
@@ -327,7 +326,7 @@ class VolumeAdvection
         }
         return false;
     }
-    
+
     template<typename VolumeGridT, typename VolumeSamplerT>
     void cook(VolumeGridT& outGrid, const VolumeGridT& inGrid, double dt)
     {
@@ -361,7 +360,7 @@ class VolumeAdvection
             Advect<VolumeGridT, 1, VolumeSamplerT> adv(inGrid, *this);
             adv.cook(outGrid, dt);
             break;
-        } 
+        }
         default:
             OPENVDB_THROW(ValueError, "Spatial difference scheme not supported!");
         }
@@ -380,22 +379,22 @@ class VolumeAdvection
     size_t                 mGrainSize;
     int                    mSubSteps;
 };//end of VolumeAdvection class
-    
+
 // Private class that implements the multi-threaded advection
 template<typename VelocityGridT, bool StaggeredVelocity, typename InterrupterType>
 template<typename VolumeGridT, size_t OrderRK, typename SamplerT>
 struct VolumeAdvection<VelocityGridT, StaggeredVelocity, InterrupterType>::Advect
 {
-    typedef typename VolumeGridT::TreeType      TreeT;
-    typedef typename VolumeGridT::ConstAccessor AccT;
-    typedef typename TreeT::ValueType            ValueT;
-    typedef typename tree::LeafManager<TreeT>    LeafManagerT;
-    typedef typename LeafManagerT::LeafNodeType  LeafNodeT;
-    typedef typename LeafManagerT::LeafRange     LeafRangeT;
-    typedef VelocityIntegrator<VelocityGridT, StaggeredVelocity> VelocityIntegratorT;
-    typedef typename VelocityIntegratorT::ElementType RealT;
-    typedef typename TreeT::LeafNodeType::ValueOnIter VoxelIterT;
-    
+    using TreeT = typename VolumeGridT::TreeType;
+    using AccT = typename VolumeGridT::ConstAccessor;
+    using ValueT = typename TreeT::ValueType;
+    using LeafManagerT = typename tree::LeafManager<TreeT>;
+    using LeafNodeT = typename LeafManagerT::LeafNodeType;
+    using LeafRangeT = typename LeafManagerT::LeafRange;
+    using VelocityIntegratorT = VelocityIntegrator<VelocityGridT, StaggeredVelocity>;
+    using RealT = typename VelocityIntegratorT::ElementType;
+    using VoxelIterT = typename TreeT::LeafNodeType::ValueOnIter;
+
     Advect(const VolumeGridT& inGrid, const VolumeAdvection& parent)
         : mTask(0)
         , mInGrid(&inGrid)
@@ -418,37 +417,39 @@ struct VolumeAdvection<VelocityGridT, StaggeredVelocity, InterrupterType>::Advec
     }
     void cook(VolumeGridT& outGrid, double time_step)
     {
+        namespace ph = std::placeholders;
+
         mParent->start("Advecting volume");
         LeafManagerT manager(outGrid.tree(), mParent->spatialOrder()==2 ? 1 : 0);
         const LeafRangeT range = manager.leafRange(mParent->mGrainSize);
         const RealT dt = static_cast<RealT>(-time_step);//method of characteristics backtracks
         if (mParent->mIntegrator == Scheme::MAC) {
-            mTask = boost::bind(&Advect::rk,  _1, _2, dt, 0, mInGrid);//out[0]=forward 
+            mTask = std::bind(&Advect::rk, ph::_1, ph::_2, dt, 0, mInGrid);//out[0]=forward
             this->cook(range);
-            mTask = boost::bind(&Advect::rk,  _1, _2,-dt, 1, &outGrid);//out[1]=backward
+            mTask = std::bind(&Advect::rk, ph::_1, ph::_2,-dt, 1, &outGrid);//out[1]=backward
             this->cook(range);
-            mTask = boost::bind(&Advect::mac, _1, _2);//out[0] = out[0] + (in[0] - out[1])/2
+            mTask = std::bind(&Advect::mac, ph::_1, ph::_2);//out[0] = out[0] + (in[0] - out[1])/2
             this->cook(range);
         } else if (mParent->mIntegrator == Scheme::BFECC) {
-            mTask = boost::bind(&Advect::rk, _1, _2, dt, 0, mInGrid);//out[0]=forward
+            mTask = std::bind(&Advect::rk, ph::_1, ph::_2, dt, 0, mInGrid);//out[0]=forward
             this->cook(range);
-            mTask = boost::bind(&Advect::rk, _1, _2,-dt, 1, &outGrid);//out[1]=backward
+            mTask = std::bind(&Advect::rk, ph::_1, ph::_2,-dt, 1, &outGrid);//out[1]=backward
             this->cook(range);
-            mTask = boost::bind(&Advect::bfecc, _1, _2);//out[0] = (3*in[0] - out[1])/2
+            mTask = std::bind(&Advect::bfecc, ph::_1, ph::_2);//out[0] = (3*in[0] - out[1])/2
             this->cook(range);
-            mTask = boost::bind(&Advect::rk, _1, _2, dt, 1, &outGrid);//out[1]=forward
+            mTask = std::bind(&Advect::rk, ph::_1, ph::_2, dt, 1, &outGrid);//out[1]=forward
             this->cook(range);
             manager.swapLeafBuffer(1);// out[0] = out[1]
         } else {// SEMI, MID, RK3 and RK4
-            mTask = boost::bind(&Advect::rk, _1, _2,  dt, 0, mInGrid);//forward
+            mTask = std::bind(&Advect::rk, ph::_1, ph::_2,  dt, 0, mInGrid);//forward
             this->cook(range);
         }
 
         if (mParent->spatialOrder()==2) manager.removeAuxBuffers();
-        
-        mTask = boost::bind(&Advect::limiter, _1, _2, dt);// out[0] = limiter( out[0] ) 
+
+        mTask = std::bind(&Advect::limiter, ph::_1, ph::_2, dt);// out[0] = limiter( out[0] )
         this->cook(range);
-        
+
         mParent->stop();
     }
     // Last step of the MacCormack scheme: out[0] = out[0] + (in[0] - out[1])/2
@@ -461,7 +462,7 @@ struct VolumeAdvection<VelocityGridT, StaggeredVelocity, InterrupterType>::Advec
             ValueT* out0 = leafIter.buffer( 0 ).data();// forward
             const ValueT* out1 = leafIter.buffer( 1 ).data();// backward
             const LeafNodeT* leaf = acc.probeConstLeaf( leafIter->origin() );
-            if (leaf !=NULL) {
+            if (leaf != nullptr) {
                 const ValueT* in0 = leaf->buffer().data();
                 for (VoxelIterT voxelIter = leafIter->beginValueOn(); voxelIter; ++voxelIter) {
                     const Index i = voxelIter.pos();
@@ -485,7 +486,7 @@ struct VolumeAdvection<VelocityGridT, StaggeredVelocity, InterrupterType>::Advec
             ValueT* out0 = leafIter.buffer( 0 ).data();// forward
             const ValueT* out1 = leafIter.buffer( 1 ).data();// backward
             const LeafNodeT* leaf = acc.probeConstLeaf(leafIter->origin());
-            if (leaf !=NULL) {
+            if (leaf != nullptr) {
                 const ValueT* in0 = leaf->buffer().data();
                 for (VoxelIterT voxelIter = leafIter->beginValueOn(); voxelIter; ++voxelIter) {
                     const Index i = voxelIter.pos();
@@ -544,7 +545,7 @@ struct VolumeAdvection<VelocityGridT, StaggeredVelocity, InterrupterType>::Advec
                         value = BoxSampler::trilinearInterpolation( data, iPos );
                     }
                 }
-                
+
                 if (math::isApproxEqual(value, backg, math::Delta<ValueT>::value())) {
                     value = backg;
                     leafIter->setValueOff( voxelIter.pos() );
@@ -553,13 +554,13 @@ struct VolumeAdvection<VelocityGridT, StaggeredVelocity, InterrupterType>::Advec
         }//loop over leaf nodes
     }
     // Public member data of the private Advect class
-    
-    typename boost::function<void (Advect*, const LeafRangeT&)> mTask;
+
+    typename std::function<void (Advect*, const LeafRangeT&)> mTask;
     const VolumeGridT*        mInGrid;
     const VelocityIntegratorT mVelocityInt;// lightweight!
     const VolumeAdvection*    mParent;
-};// end of private member class Advect    
-    
+};// end of private member class Advect
+
 } // namespace tools
 } // namespace OPENVDB_VERSION_NAME
 } // namespace openvdb
diff --git a/openvdb_houdini/houdini/AttributeTransferUtil.h b/openvdb_houdini/houdini/AttributeTransferUtil.h
index b9aa4a07..834c07a9 100644
--- a/openvdb_houdini/houdini/AttributeTransferUtil.h
+++ b/openvdb_houdini/houdini/AttributeTransferUtil.h
@@ -1143,7 +1143,9 @@ TransferPrimitiveAttributesOp<GridType>::operator()(const GA_SplittableRange& ra
 
     GA_Offset start, end, source, target, v0, v1, v2;
     const GA_Primitive * primRef = nullptr;
+#if UT_MAJOR_VERSION_INT <= 15
     GA_Primitive::const_iterator vtxIt;
+#endif
 
     typename GridType::ConstAccessor acc = mIndexGrid.getConstAccessor();
     const openvdb::math::Transform& transform = mIndexGrid.transform();
diff --git a/openvdb_houdini/houdini/ParmFactory.cc b/openvdb_houdini/houdini/ParmFactory.cc
index 7cb29000..19c42ad1 100644
--- a/openvdb_houdini/houdini/ParmFactory.cc
+++ b/openvdb_houdini/houdini/ParmFactory.cc
@@ -47,17 +47,81 @@
 #include <UT/UT_IntArray.h>
 #include <UT/UT_Version.h>
 #include <UT/UT_WorkArgs.h>
-#include <cstring> // for ::strdup()
+#include <algorithm> // for std::for_each(), std::max(), std::remove(), std::sort()
+#include <cstdint> // for std::uintptr_t()
+#include <cstdlib> // for std::atoi()
+#include <cstring> // for std::strcmp(), ::strdup()
 #include <limits>
+#include <ostream>
 #include <sstream>
 
 namespace houdini_utils {
 
 namespace {
-/// PRM_SpareData token name for parameter documentation wiki markup
-char const * const PARM_DOC_TOKEN = "houdini_utils::doc";
+
+// PRM_SpareData token names
+
+// SOP input index specifier
+/// @todo Is there an existing constant for this token?
+char const * const kSopInputToken = "sop_input";
+// Parameter documentation wiki markup
+char const * const kParmDocToken = "houdini_utils::doc";
+// String-encoded GA_AttributeOwner
+char const * const kAttrOwnerToken = "houdini_utils::attr_owner";
+// Pointer to an AttrFilterFunc
+char const * const kAttrFilterToken = "houdini_utils::attr_filter";
+
+
+// Add an integer value (encoded into a string) to a PRM_SpareData map
+// under the given token name.
+inline void
+setSpareInteger(PRM_SpareData* spare, const char* token, int value)
+{
+    if (spare && token) {
+        spare->addTokenValue(token, std::to_string(value).c_str());
+    }
+}
+
+// Retrieve the integer value with the given token name from a PRM_SpareData map.
+// If no such token exists, return the specified default integer value.
+inline int
+getSpareInteger(const PRM_SpareData* spare, const char* token, int deflt = 0)
+{
+    if (!spare || !token) return deflt;
+    char const * const str = spare->getValue(token);
+    return str ? std::atoi(str) : deflt;
+}
+
+
+// Add a pointer (encoded into a string) to a PRM_SpareData map
+// under the given token name.
+inline void
+setSparePointer(PRM_SpareData* spare, const char* token, const void* ptr)
+{
+    if (spare && token) {
+        spare->addTokenValue(token,
+            std::to_string(reinterpret_cast<std::uintptr_t>(ptr)).c_str());
+    }
 }
 
+// Retrieve the pointer with the given token name from a PRM_SpareData map.
+// If no such token exists, return the specified default pointer.
+inline const void*
+getSparePointer(const PRM_SpareData* spare, const char* token, const void* deflt = nullptr)
+{
+    if (!spare || !token) return deflt;
+    if (sizeof(std::uintptr_t) > sizeof(unsigned long long)) {
+        throw std::range_error{"houdini_utils::ParmFactory: can't decode pointer from string"};
+    }
+    if (const char* str = spare->getValue(token)) {
+        auto intPtr = static_cast<std::uintptr_t>(std::stoull(str));
+        return reinterpret_cast<void*>(intPtr);
+    }
+    return deflt;
+}
+
+} // anonymous namespace
+
 
 ParmList&
 ParmList::add(const PRM_Template& p)
@@ -210,6 +274,10 @@ struct ParmFactory::Impl
         const_cast<PRM_Name*>(name)->harden();
     }
 
+    static PRM_SpareData* getSopInputSpareData(size_t inp); ///< @todo return a const pointer?
+    static void getAttrChoices(void* op, PRM_Name* choices, int maxChoices,
+        const PRM_SpareData*, const PRM_Parm*);
+
     PRM_Callback               callbackFunc;
     const PRM_ChoiceList*      choicelist;
     const PRM_ConditionalBase* conditional;
@@ -234,6 +302,109 @@ PRM_SpareData* const ParmFactory::Impl::sSOPInputSpareData[4] = {
         &SOP_Node::theThirdInput, &SOP_Node::theFourthInput};
 
 
+// Return one of the predefined PRM_SpareData maps that specify a SOP input number,
+// or construct new PRM_SpareData if none exists for the given input number.
+PRM_SpareData*
+ParmFactory::Impl::getSopInputSpareData(size_t inp)
+{
+    if (inp < 4) return Impl::sSOPInputSpareData[inp];
+
+    auto spare = new PRM_SpareData{SOP_Node::theFirstInput};
+    spare->addTokenValue(kSopInputToken, std::to_string(inp).c_str());
+    return spare;
+}
+
+
+// PRM_ChoiceGenFunc invoked by ParmFactory::setAttrChoiceList()
+void
+ParmFactory::Impl::getAttrChoices(void* op, PRM_Name* choices, int maxChoices,
+    const PRM_SpareData* spare, const PRM_Parm* parm)
+{
+    if (!op || !choices || !parm) return;
+    // This function can only be used in SOPs, because it calls SOP_Node::fillAttribNameMenu().
+    if (static_cast<OP_Node*>(op)->getOpTypeID() != SOP_OPTYPE_ID) return;
+
+    auto* sop = static_cast<SOP_Node*>(op);
+
+    // Extract the SOP input number, the attribute class, and an optional
+    // pointer to a filter functor from the spare data.
+    const int inp = getSpareInteger(spare, kSopInputToken);
+    const int attrOwner = getSpareInteger(spare, kAttrOwnerToken, GA_ATTRIB_INVALID);
+    const auto* attrFilter =
+        static_cast<const AttrFilterFunc*>(getSparePointer(spare, kAttrFilterToken));
+
+    // Marshal pointers to the filter functor and the parameter and SOP for which this function
+    // is being called into blind data that can be passed to SOP_Node::fillAttribNameMenu().
+    struct AttrFilterData {
+        const AttrFilterFunc* func;
+        const PRM_Parm* parm;
+        const SOP_Node* sop;
+    };
+    AttrFilterData cbData{attrFilter, parm, sop};
+
+    // Define a filter callback function to be passed to SOP_Node::fillAttribNameMenu().
+    // Because the latter uses a C-style callback mechanism, this callback must be
+    // equivalent to a static function pointer (as a non-capturing lambda is).
+    auto cb = [](const GA_Attribute* aAttr, void* aData) -> bool {
+        if (!aAttr) return false;
+        // Cast the blind data pointer supplied by SOP_Node::fillAttribNameMenu().
+        const auto* data = static_cast<AttrFilterData*>(aData);
+        if (!data || !data->func) return true; // no filter; accept all attributes
+        // Invoke the filter functor and return the result.
+        return (*(data->func))(*aAttr, *(data->parm), *(data->sop));
+    };
+
+    // Invoke SOP_Node::fillAttribNameMenu() for the appropriate attribute class.
+    switch (attrOwner) {
+        case GA_ATTRIB_VERTEX:
+        case GA_ATTRIB_POINT:
+        case GA_ATTRIB_PRIMITIVE:
+        case GA_ATTRIB_DETAIL:
+            if (cbData.func) {
+                sop->fillAttribNameMenu(choices, maxChoices,
+                    static_cast<GA_AttributeOwner>(attrOwner), inp, cb, &cbData);
+            } else {
+                sop->fillAttribNameMenu(choices, maxChoices,
+                    static_cast<GA_AttributeOwner>(attrOwner), inp);
+            }
+            break;
+        default: // all attributes
+        {
+            // To collect all classes of attributes, call SOP_Node::fillAttribNameMenu()
+            // once for each class.  Each call appends zero or more PRM_Names to the list
+            // as well as an end-of-list terminator.
+            auto* head = choices;
+            int count = 0, maxCount = maxChoices;
+            for (auto owner:
+                { GA_ATTRIB_VERTEX, GA_ATTRIB_POINT, GA_ATTRIB_PRIMITIVE, GA_ATTRIB_DETAIL })
+            {
+                int numAdded = (cbData.func ?
+                    sop->fillAttribNameMenu(head, maxCount, owner, inp, cb, &cbData) :
+                    sop->fillAttribNameMenu(head, maxCount, owner, inp));
+                if (numAdded > 0) {
+                    // SOP_Node::fillAttribNameMenu() returns the number of entries added
+                    // to the list, not including the terminator.
+                    // Advance the list head pointer so that the next entry to be added
+                    // (if any) overwrites the terminator.
+                    count += numAdded;
+                    head += numAdded;
+                    maxCount -= numAdded;
+                }
+            }
+            if (count) {
+                // Sort the list by name to reproduce the behavior of SOP_Node::allAttribMenu.
+                std::sort(choices, choices + count,
+                    [](const PRM_Name& n1, const PRM_Name& n2) {
+                        return (0 > std::strcmp(n1.getToken(), n2.getToken()));
+                    }
+                );
+            }
+            break;
+        }
+    }
+}
+
+
 ////////////////////////////////////////
 
 
@@ -368,21 +539,40 @@ ParmFactory::setChoiceListItems(PRM_ChoiceListType typ, const std::vector<std::s
     return doSetChoiceList(typ, items, /*paired=*/true);
 }
 
+
 ParmFactory&
-ParmFactory::setGroupChoiceList(int inputIndex, PRM_ChoiceListType typ)
+ParmFactory::setGroupChoiceList(size_t inputIndex, PRM_ChoiceListType typ)
 {
-    if (0 <= inputIndex && inputIndex < 4) {
-        mImpl->choicelist = new PRM_ChoiceList(typ, PrimGroupMenu.getChoiceGenerator());
+    mImpl->choicelist = new PRM_ChoiceList(typ, PrimGroupMenu.getChoiceGenerator());
+
 #if (UT_VERSION_INT >= 0x0e000075) // 14.0.117 or later
-        setSpareData(SOP_Node::getGroupSelectButton(GA_GROUP_PRIMITIVE,
-            nullptr, inputIndex, Impl::sSOPInputSpareData[inputIndex]));
+    setSpareData(SOP_Node::getGroupSelectButton(GA_GROUP_PRIMITIVE, nullptr,
+        static_cast<int>(inputIndex), mImpl->getSopInputSpareData(inputIndex)));
 #else
-        setSpareData(Impl::sSOPInputSpareData[inputIndex]);
+    setSpareData(mImpl->getSopInputSpareData(inputIndex));
 #endif
+
+    return *this;
+}
+
+
+ParmFactory&
+ParmFactory::setAttrChoiceList(size_t inputIndex, GA_AttributeOwner attrOwner,
+    PRM_ChoiceListType typ, AttrFilterFunc attrFilter)
+{
+    setChoiceList(new PRM_ChoiceList{typ, Impl::getAttrChoices});
+
+    mImpl->spareData = new PRM_SpareData;
+    setSpareInteger(mImpl->spareData, kSopInputToken, int(inputIndex));
+    setSpareInteger(mImpl->spareData, kAttrOwnerToken, static_cast<int>(attrOwner));
+    if (attrFilter) {
+        setSparePointer(mImpl->spareData, kAttrFilterToken, new AttrFilterFunc{attrFilter});
     }
+
     return *this;
 }
 
+
 ParmFactory&
 ParmFactory::setConditional(const PRM_ConditionalBase* c) { mImpl->conditional = c; return *this; }
 
@@ -437,7 +627,7 @@ ParmFactory&
 ParmFactory::setDocumentation(const char* doc)
 {
     if (!mImpl->spareData) { mImpl->spareData = new PRM_SpareData; }
-    mImpl->spareData->addTokenValue(PARM_DOC_TOKEN, ::strdup(doc ? doc : ""));
+    mImpl->spareData->addTokenValue(kParmDocToken, ::strdup(doc ? doc : ""));
     return *this;
 }
 
@@ -469,7 +659,7 @@ ParmFactory::setRange(const PRM_Range* r) { mImpl->range = r; return *this; }
 ParmFactory&
 ParmFactory::setSpareData(const std::map<std::string, std::string>& items)
 {
-    typedef std::map<std::string, std::string> StringMap;
+    using StringMap = std::map<std::string, std::string>;
     if (!items.empty()) {
         if (!mImpl->spareData) { mImpl->spareData = new PRM_SpareData; }
         for (StringMap::const_iterator i = items.begin(), e = items.end(); i != e; ++i) {
@@ -587,11 +777,11 @@ documentParms(std::ostream& os, PRM_Template const * const parmList, int level =
 
         UT_String parmDoc;
         const PRM_SpareData* const spare = parm->getSparePtr();
-        if (spare && spare->getValue(PARM_DOC_TOKEN)) {
+        if (spare && spare->getValue(kParmDocToken)) {
             // If the parameter was documented with setDocumentation(), use that text.
-            // (This relies on PARM_DOC_TOKEN not being paired with nullptr.
+            // (This relies on kParmDocToken not being paired with nullptr.
             // ParmFactory::setDocumentation(), at least, ensures that it isn't.)
-            parmDoc = spare->getValue(PARM_DOC_TOKEN);
+            parmDoc = spare->getValue(kParmDocToken);
             // If the text is empty, suppress this parameter.
             if (!parmDoc.isstring()) continue;
         } else {
@@ -1083,22 +1273,12 @@ namespace {
 // (this functionality was added to SOP_Node::primGroupMenu some time ago,
 // possibly as early as Houdini 12.5)
 
-inline int
-lookupGroupInput(const PRM_SpareData *spare)
-{
-    const char  *istring;
-    if (!spare) return 0;
-    istring = spare->getValue("sop_input");
-    return istring ? atoi(istring) : 0;
-}
-
-
 void
 sopBuildGridMenu(void *data, PRM_Name *menuEntries, int themenusize,
     const PRM_SpareData *spare, const PRM_Parm *parm)
 {
     SOP_Node* sop = CAST_SOPNODE((OP_Node *)data);
-    int inputIndex = lookupGroupInput(spare);
+    int inputIndex = getSopInputIndex(spare);
 
     const GU_Detail* gdp = sop->getInputLastGeo(inputIndex, CHgetEvalTime());
 
diff --git a/openvdb_houdini/houdini/ParmFactory.h b/openvdb_houdini/houdini/ParmFactory.h
index c7c3c48c..561515b1 100644
--- a/openvdb_houdini/houdini/ParmFactory.h
+++ b/openvdb_houdini/houdini/ParmFactory.h
@@ -40,6 +40,7 @@
 #include <OP/OP_Operator.h>
 #include <PRM/PRM_Include.h>
 #include <PRM/PRM_SpareData.h>
+#include <GA/GA_Attribute.h>
 #include <SOP/SOP_Node.h>
 #if defined(PRODDEV_BUILD) || defined(DWREAL_IS_DOUBLE)
   // OPENVDB_HOUDINI_API, which has no meaning in a DWA build environment but
@@ -52,8 +53,10 @@
 #else
   #include <openvdb/Platform.h>
 #endif
-#include <boost/shared_ptr.hpp>
+#include <exception>
+#include <functional>
 #include <map>
+#include <memory>
 #include <string>
 #include <vector>
 
@@ -68,6 +71,7 @@
 
 class GU_Detail;
 class OP_OperatorTable;
+class PRM_Parm;
 
 namespace houdini_utils {
 
@@ -78,7 +82,7 @@ class ParmFactory;
 class OPENVDB_HOUDINI_API ParmList
 {
 public:
-    typedef std::vector<PRM_Template> PrmTemplateVec;
+    using PrmTemplateVec = std::vector<PRM_Template>;
 
     ParmList() {}
 
@@ -120,7 +124,7 @@ class OPENVDB_HOUDINI_API ParmList
 
 private:
     struct SwitcherInfo { size_t parmIdx; std::vector<PRM_Default> folders; bool exclusive; };
-    typedef std::vector<SwitcherInfo> SwitcherStack;
+    using SwitcherStack = std::vector<SwitcherInfo>;
 
     void incFolderParmCount();
     SwitcherInfo* getCurrentSwitcher();
@@ -171,19 +175,18 @@ class OPENVDB_HOUDINI_API ParmFactory
     /// @param items   a list of token, label, token, label,... string pairs
     /// @note The @a items array must be null-terminated.
     ParmFactory& setChoiceListItems(PRM_ChoiceListType typ, const char* const* items);
-    /// @brief Specify a menu that is populated with the primitive groups of the selected input.
-    /// @param inputIndex   specifies the zero based index of the input that should be used to get
-    /// the items from, must be in the range of [0..3], inclusive
-    /// @param typ          specifies the menu behavior (toggle, replace, etc.)
-    /// @details This method provides a more flexible alternative to
-    /// @c setChoiceList(&houdini_utils::PrimGroupMenuInput1),
-    /// @c setChoiceList(&houdini_utils::PrimGroupMenuInput2), etc.
+
+    /// @brief Specify a menu of primitive group names for this parameter.
     ///
-    /// Calling this with a single input index is equivalent to calling
-    /// @c setChoiceList with the corresponding @c houdini_utils::PrimGroupMenuInput1, etc.
+    /// @param inputIndex  the zero-based index of the input from which to get primitive groups
+    /// @param typ         the menu behavior (toggle, replace, etc.)
+    ///
+    /// @details Calling this method with the default (toggle) behavior is equivalent
+    /// to calling @c setChoiceList(&houdini_utils::PrimGroupMenuInput1),
+    /// @c setChoiceList(&houdini_utils::PrimGroupMenuInput2), etc.
     ///
     /// @par Example
-    /// To limit the choice from the menu to a single primitive, replace
+    /// To limit the user to choosing a single primitive group, replace
     /// @code
     /// parms.add(houdini_utils::ParmFactory(PRM_STRING, "reference", "Reference")
     ///     .setChoiceList(&houdini_utils::PrimGroupMenuInput2);
@@ -193,7 +196,45 @@ class OPENVDB_HOUDINI_API ParmFactory
     /// parms.add(houdini_utils::ParmFactory(PRM_STRING, "reference", "Reference")
     ///     .setGroupChoiceList(1, PRM_CHOICELIST_REPLACE); // input index is zero based
     /// @endcode
-    ParmFactory& setGroupChoiceList(int inputIndex, PRM_ChoiceListType typ = PRM_CHOICELIST_TOGGLE);
+    ParmFactory& setGroupChoiceList(size_t inputIndex,
+        PRM_ChoiceListType typ = PRM_CHOICELIST_TOGGLE);
+
+    /// @brief Functor to filter a list of attributes from a SOP's input
+    /// @details Arguments to the functor are an attribute to be filtered
+    /// and the parameter and SOP for which the filter is being called.
+    /// The functor should return @c true for attributes that should be added
+    /// to the list and @c false for attributes that should be ignored.
+    using AttrFilterFunc =
+        std::function<bool (const GA_Attribute&, const PRM_Parm&, const SOP_Node&)>;
+
+    /// @brief Specify a menu of attribute names for this parameter.
+    ///
+    /// @param inputIndex  the zero-based index of the input from which to get attributes
+    /// @param attrOwner   the class of attribute with which to populate the menu:
+    ///     either per-vertex (@c GA_ATTRIB_VERTEX), per-point (@c GA_ATTRIB_POINT),
+    ///     per-primitive (@c GA_ATTRIB_PRIMITIVE), global (@c GA_ATTRIB_GLOBAL),
+    ///     or all of the above (@c GA_ATTRIB_INVALID or any other value)
+    /// @param typ         the menu behavior (toggle, replace, etc.)
+    /// @param attrFilter  an optional filter functor that returns @c true for each
+    ///     attribute that should appear in the menu; the functor will be moved,
+    ///     if possible, or else copied
+    ///
+    /// @note This method is supported only for SOPs.
+    ///
+    /// @par Example
+    /// Create a menu that allows multiple selection from among all the string attributes
+    /// on a SOP's first input:
+    /// @code
+    /// houdini_utils::ParmList parms;
+    /// parms.add(houdini_utils::ParmFactory(PRM_STRING, "stringattr", "String Attribute")
+    ///     .setAttrChoiceList(/*input=*/0, GA_ATTRIB_INVALID, PRM_CHOICELIST_TOGGLE,
+    ///         [](const GA_Attribute& attr, const PRM_Parm&, const SOP_Node&) {
+    ///             return (attr.getStorageClass() == GA_STORECLASS_STRING);
+    ///         }));
+    /// @endcode
+    ParmFactory& setAttrChoiceList(size_t inputIndex, GA_AttributeOwner attrOwner,
+        PRM_ChoiceListType typ = PRM_CHOICELIST_TOGGLE,
+        AttrFilterFunc attrFilter = AttrFilterFunc{});
 
 
 #if defined(GCC3)
@@ -236,7 +277,7 @@ class OPENVDB_HOUDINI_API ParmFactory
     /// @details If the string is null, the floating-point value will be used
     /// (but rounded if this parameter is integer-valued).
     /// @note The string pointer must not point to a temporary.
-    ParmFactory& setDefault(fpreal, const char* = NULL, CH_StringMeaning = CH_STRING_LITERAL);
+    ParmFactory& setDefault(fpreal, const char* = nullptr, CH_StringMeaning = CH_STRING_LITERAL);
     /// @brief Specify a default string value for this parameter.
     ParmFactory& setDefault(const std::string&, CH_StringMeaning = CH_STRING_LITERAL);
     /// @brief Specify default numeric values for the vector elements of this parameter
@@ -297,7 +338,7 @@ class OPENVDB_HOUDINI_API ParmFactory
 
 private:
     struct Impl;
-    boost::shared_ptr<Impl> mImpl;
+    std::shared_ptr<Impl> mImpl;
 
     // For internal use only, and soon to be removed:
     ParmFactory& doSetChoiceList(PRM_ChoiceListType, const std::vector<std::string>&, bool);
@@ -309,7 +350,7 @@ class OPENVDB_HOUDINI_API ParmFactory
 
 
 class OpPolicy;
-typedef boost::shared_ptr<OpPolicy> OpPolicyPtr;
+using OpPolicyPtr = std::shared_ptr<OpPolicy>;
 
 
 /// @brief Helper class to simplify operator registration
@@ -435,7 +476,7 @@ class OPENVDB_HOUDINI_API OpFactory
         ParmList&, OP_OperatorTable&, OpFlavor);
 
     struct Impl;
-    boost::shared_ptr<Impl> mImpl;
+    std::shared_ptr<Impl> mImpl;
 };
 
 
@@ -478,10 +519,10 @@ class OPENVDB_HOUDINI_API DWAOpPolicy: public OpPolicy
     /// @details The operator's type name is generated from its English name
     /// by prepending "DW_" and removing non-alphanumeric characters.
     /// For example, "My Node" becomes "DW_MyNode".
-    virtual std::string getName(const OpFactory&, const std::string& english);
+    std::string getName(const OpFactory&, const std::string& english) override;
 
     /// @brief Return a help URL for the operator defined by the given factory.
-    virtual std::string getHelpURL(const OpFactory&);
+    std::string getHelpURL(const OpFactory&) override;
 };
 
 /// @brief Default policies for DWA R&D operator types
@@ -492,21 +533,21 @@ class DWALevel1RnDOpPolicy : public DWAOpPolicy
 {
 public:
     /// @brief Level 1: show-wide
-    virtual std::string getIconName(const OpFactory&) { return "DreamWorks_L1_RnD"; }
+    std::string getIconName(const OpFactory&) override { return "DreamWorks_L1_RnD"; }
 };
 
 class DWALevel2RnDOpPolicy : public DWAOpPolicy
 {
 public:
     /// @brief Level 2: global
-    virtual std::string getIconName(const OpFactory&) { return "DreamWorks_L2_RnD"; }
+    std::string getIconName(const OpFactory&) override { return "DreamWorks_L2_RnD"; }
 };
 
 class DWALevel3RnDOpPolicy : public DWAOpPolicy
 {
 public:
     /// @brief Level 3: depot, map, most stable
-    virtual std::string getIconName(const OpFactory&) { return "DreamWorks_L3_RnD"; }
+    std::string getIconName(const OpFactory&) override { return "DreamWorks_L3_RnD"; }
 };
 
 ////////////////////////////////////////
diff --git a/openvdb_houdini/houdini/SOP_OpenVDB_Fracture.cc b/openvdb_houdini/houdini/SOP_OpenVDB_Fracture.cc
index cf46cc1b..d8c55989 100644
--- a/openvdb_houdini/houdini/SOP_OpenVDB_Fracture.cc
+++ b/openvdb_houdini/houdini/SOP_OpenVDB_Fracture.cc
@@ -712,7 +712,6 @@ SOP_OpenVDB_Fracture::process(
 
     if (cutterObjects > 1) {
         GA_Offset start, end;
-        GA_Primitive::const_iterator vtxIt;
         GA_SplittableRange range(cutterGeo->getPrimitiveRange());
 
         for (int classId = 0; classId < cutterObjects; ++classId) {
