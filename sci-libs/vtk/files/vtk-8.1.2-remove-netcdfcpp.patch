From 72b934161e48785a9140bb0bf1cdc5a3c6312cd3 Mon Sep 17 00:00:00 2001
From: Ben Boeckel <ben.boeckel@kitware.com>
Date: Wed, 3 Oct 2018 13:27:54 -0400
Subject: [PATCH 1/9] vtkMPASReader: replace malloc/free with new[]/delete[]

---
 IO/NetCDF/vtkMPASReader.cxx | 107 ++++++++++++------------------------
 1 file changed, 35 insertions(+), 72 deletions(-)

diff --git a/IO/NetCDF/vtkMPASReader.cxx b/IO/NetCDF/vtkMPASReader.cxx
index 1aaa50c4a68..e8bbe0651d0 100644
--- a/IO/NetCDF/vtkMPASReader.cxx
+++ b/IO/NetCDF/vtkMPASReader.cxx
@@ -194,17 +194,6 @@ bool vtkMPASReader::Internal::isExtraDim(const string &name)
   return name != "nCells" && name != "nVertices" && name != "Time";
 }
 
-//----------------------------------------------------------------------------
-// Macro to check malloc didn't return an error
-//----------------------------------------------------------------------------
-
-#define CHECK_MALLOC(ptr) \
-  if ((ptr) == nullptr)                          \
-  {                                              \
-  vtkErrorMacro( << "malloc failed!" << endl);   \
-  return(0);                                     \
-  }
-
 
 //----------------------------------------------------------------------------
 //  Macro to check if the named NetCDF dimension exists
@@ -386,13 +375,13 @@ void vtkMPASReader::DestroyData()
   this->Internals->cellArrays.clear();
   this->Internals->pointArrays.clear();
 
-  free(this->CellMap);
+  delete [] this->CellMap;
   this->CellMap = nullptr;
 
-  free(this->PointMap);
+  delete [] this->PointMap;
   this->PointMap = nullptr;
 
-  free(this->MaximumLevelPoint);
+  delete [] this->MaximumLevelPoint;
   this->MaximumLevelPoint = nullptr;
 }
 
@@ -445,22 +434,22 @@ void vtkMPASReader::ReleaseNcData()
   this->CellDataArraySelection->RemoveAllArrays();
   this->UpdateDimensions(true); // Reset extra dimension list.
 
-  free(this->PointX);
+  delete [] this->PointX;
   this->PointX = nullptr;
-  free(this->PointY);
+  delete [] this->PointY;
   this->PointY = nullptr;
-  free(this->PointZ);
+  delete [] this->PointZ;
   this->PointZ = nullptr;
 
-  free(this->OrigConnections);
+  delete [] this->OrigConnections;
   this->OrigConnections = nullptr;
-  free(this->ModConnections);
+  delete [] this->ModConnections;
   this->ModConnections = nullptr;
-  free(this->CellMap);
+  delete [] this->CellMap;
   this->CellMap = nullptr;
-  free(this->PointMap);
+  delete [] this->PointMap;
   this->PointMap = nullptr;
-  free(this->MaximumLevelPoint);
+  delete [] this->MaximumLevelPoint;
   this->MaximumLevelPoint = nullptr;
 
   delete this->Internals->ncFile;
@@ -957,9 +946,7 @@ int vtkMPASReader::AllocSphericalGeometry()
   NcFile* ncFile = this->Internals->ncFile;
 
   CHECK_VAR(ncFile, "xCell");
-  this->PointX = (double*)malloc((this->NumberOfPoints+this->PointOffset) *
-                                 sizeof(double));
-  CHECK_MALLOC(this->PointX);
+  this->PointX = new double [this->NumberOfPoints+this->PointOffset];
   NcVar*  xCellVar = ncFile->get_var("xCell");
   if (!this->ValidateDimensions(xCellVar, false, 1, "nCells"))
   {
@@ -970,9 +957,7 @@ int vtkMPASReader::AllocSphericalGeometry()
   this->PointX[0] = 0.0;
 
   CHECK_VAR(ncFile, "yCell");
-  this->PointY = (double*)malloc((this->NumberOfPoints+this->PointOffset) *
-                                 sizeof(double));
-  CHECK_MALLOC(this->PointY);
+  this->PointY = new double[this->NumberOfPoints+this->PointOffset];
   NcVar*  yCellVar = ncFile->get_var("yCell");
   if (!this->ValidateDimensions(yCellVar, false, 1, "nCells"))
   {
@@ -983,9 +968,7 @@ int vtkMPASReader::AllocSphericalGeometry()
   this->PointY[0] = 0.0;
 
   CHECK_VAR(ncFile, "zCell");
-  this->PointZ = (double*)malloc((this->NumberOfPoints+this->PointOffset) *
-                                 sizeof(double));
-  CHECK_MALLOC(this->PointZ);
+  this->PointZ = new double[this->NumberOfPoints+this->PointOffset];
   NcVar*  zCellVar = ncFile->get_var("zCell");
   if (!this->ValidateDimensions(zCellVar, false, 1, "nCells"))
   {
@@ -996,9 +979,7 @@ int vtkMPASReader::AllocSphericalGeometry()
   this->PointZ[0] = 0.0;
 
   CHECK_VAR(ncFile, "cellsOnVertex");
-  this->OrigConnections = (int *) malloc(this->NumberOfCells *
-                                         this->PointsPerCell * sizeof(int));
-  CHECK_MALLOC(this->OrigConnections);
+  this->OrigConnections = new int[this->NumberOfCells * this->PointsPerCell];
   NcVar *connectionsVar = ncFile->get_var("cellsOnVertex");
   // TODO Spec says dims should be '3', 'nVertices', but my example files
   // use nVertices, vertexDegree...
@@ -1013,9 +994,7 @@ int vtkMPASReader::AllocSphericalGeometry()
   if (isNcVar(ncFile, "maxLevelCell"))
   {
     this->IncludeTopography = true;
-    this->MaximumLevelPoint = (int*)malloc((this->NumberOfPoints +
-                                            this->PointOffset) * sizeof(int));
-    CHECK_MALLOC(this->MaximumLevelPoint);
+    this->MaximumLevelPoint = new int[this->NumberOfPoints + this->PointOffset];
     NcVar *maxLevelPointVar = ncFile->get_var("maxLevelCell");
     if (!this->ValidateDimensions(maxLevelPointVar, false, 1, "nCells"))
     {
@@ -1061,8 +1040,7 @@ int vtkMPASReader::AllocProjectedGeometry()
   this->ModNumCells = (int)floor(this->NumberOfCells*(1.0 + BLOATFACTOR))+1;
 
   CHECK_VAR(ncFile, "lonCell");
-  this->PointX = (double*)malloc(this->ModNumPoints * sizeof(double));
-  CHECK_MALLOC(this->PointX);
+  this->PointX = new double[this->ModNumPoints];
   NcVar*  xCellVar = ncFile->get_var("lonCell");
   if (!this->ValidateDimensions(xCellVar, false, 1, "nCells"))
   {
@@ -1073,8 +1051,7 @@ int vtkMPASReader::AllocProjectedGeometry()
   this->PointX[0] = 0.0;
 
   CHECK_VAR(ncFile, "latCell");
-  this->PointY = (double*)malloc(this->ModNumPoints * sizeof(double));
-  CHECK_MALLOC(this->PointY);
+  this->PointY = new double[this->ModNumPoints];
   NcVar*  yCellVar = ncFile->get_var("latCell");
   if (!this->ValidateDimensions(yCellVar, false, 1, "nCells"))
   {
@@ -1085,9 +1062,7 @@ int vtkMPASReader::AllocProjectedGeometry()
   this->PointY[0] = 0.0;
 
   CHECK_VAR(ncFile, "cellsOnVertex");
-  this->OrigConnections = (int *) malloc(this->NumberOfCells * this->PointsPerCell *
-                                         sizeof(int));
-  CHECK_MALLOC(this->OrigConnections);
+  this->OrigConnections = new int[this->NumberOfCells * this->PointsPerCell];
   NcVar *connectionsVar = ncFile->get_var("cellsOnVertex");
   // TODO Spec says dims should be '3', 'nVertices', but my example files
   // use nVertices, vertexDegree...
@@ -1103,24 +1078,17 @@ int vtkMPASReader::AllocProjectedGeometry()
   // eliminating wraparound in the lat/lon projection) plus additional
   // cells added when mirroring cells that had previously wrapped around
 
-  this->ModConnections = (int *) malloc(this->ModNumCells * this->PointsPerCell
-                                        * sizeof(int));
-  CHECK_MALLOC(this->ModConnections);
+  this->ModConnections = new int[this->ModNumCells * this->PointsPerCell];
 
   // allocate an array to map the extra points and cells to the original
   // so that when obtaining data, we know where to get it
-  this->PointMap = (int*)malloc((int)floor(this->NumberOfPoints*BLOATFACTOR)
-                                * sizeof(int));
-  CHECK_MALLOC(this->PointMap);
-  this->CellMap = (int*)malloc((int)floor(this->NumberOfCells*BLOATFACTOR)
-                               * sizeof(int));
-  CHECK_MALLOC(this->CellMap);
+  this->PointMap = new int[(size_t)floor(this->NumberOfPoints * BLOATFACTOR)];
+  this->CellMap = new int[(size_t)floor(this->NumberOfCells * BLOATFACTOR)];
 
   if (isNcVar(ncFile, "maxLevelCell"))
   {
     this->IncludeTopography = true;
-    this->MaximumLevelPoint = (int*)malloc((this->NumberOfPoints + this->NumberOfPoints) * sizeof(int));
-    CHECK_MALLOC(this->MaximumLevelPoint);
+    this->MaximumLevelPoint = new int[this->NumberOfPoints + this->NumberOfPoints];
     NcVar *maxLevelPointVar = ncFile->get_var("maxLevelCell");
     if (!this->ValidateDimensions(maxLevelPointVar, false, 1, "nCells"))
     {
@@ -1158,8 +1126,7 @@ int vtkMPASReader::AllocPlanarGeometry()
   NcFile* ncFile = this->Internals->ncFile;
 
   CHECK_VAR(ncFile, "xCell");
-  this->PointX = (double*)malloc(this->NumberOfPoints * sizeof(double));
-  CHECK_MALLOC(this->PointX);
+  this->PointX = new double[this->NumberOfPoints];
   NcVar*  xCellVar = ncFile->get_var("xCell");
   if (!this->ValidateDimensions(xCellVar, false, 1, "nCells"))
   {
@@ -1170,8 +1137,7 @@ int vtkMPASReader::AllocPlanarGeometry()
   this->PointX[0] = 0.0;
 
   CHECK_VAR(ncFile, "yCell");
-  this->PointY = (double*)malloc(this->NumberOfPoints * sizeof(double));
-  CHECK_MALLOC(this->PointY);
+  this->PointY = new double[this->NumberOfPoints];
   NcVar*  yCellVar = ncFile->get_var("yCell");
   if (!this->ValidateDimensions(yCellVar, false, 1, "nCells"))
   {
@@ -1182,8 +1148,7 @@ int vtkMPASReader::AllocPlanarGeometry()
   this->PointY[0] = 0.0;
 
   CHECK_VAR(ncFile, "zCell");
-  this->PointZ = (double*)malloc(this->NumberOfPoints * sizeof(double));
-  CHECK_MALLOC(this->PointZ);
+  this->PointZ = new double[this->NumberOfPoints];
   NcVar *zCellVar = ncFile->get_var("zCell");
   if (!this->ValidateDimensions(zCellVar, false, 1, "nCells"))
   {
@@ -1194,9 +1159,7 @@ int vtkMPASReader::AllocPlanarGeometry()
   this->PointZ[0] = 0.0;
 
   CHECK_VAR(ncFile, "cellsOnVertex");
-  this->OrigConnections = (int *) malloc(this->NumberOfCells * this->PointsPerCell *
-                                         sizeof(int));
-  CHECK_MALLOC(this->OrigConnections);
+  this->OrigConnections = new int[this->NumberOfCells * this->PointsPerCell];
   NcVar *connectionsVar = ncFile->get_var("cellsOnVertex");
   // TODO Spec says dims should be '3', 'nVertices', but my example files
   // use nVertices, vertexDegree...
@@ -1211,9 +1174,7 @@ int vtkMPASReader::AllocPlanarGeometry()
   if (isNcVar(ncFile, "maxLevelCell"))
   {
     this->IncludeTopography = true;
-    this->MaximumLevelPoint = (int*)malloc(2 * this->NumberOfPoints *
-                                           sizeof(int));
-    CHECK_MALLOC(this->MaximumLevelPoint);
+    this->MaximumLevelPoint = new int[2 * this->NumberOfPoints];
     NcVar *maxLevelPointVar = ncFile->get_var("maxLevelCell");
     if (!this->ValidateDimensions(maxLevelPointVar, false, 1, "nCells"))
     {
@@ -1623,17 +1584,17 @@ void vtkMPASReader::OutputPoints()
 
   if (this->PointX)
   {
-    free(this->PointX);
+    delete [] this->PointX;
     this->PointX = nullptr;
   }
   if (this->PointY)
   {
-    free(this->PointY);
+    delete [] this->PointY;
     this->PointY = nullptr;
   }
   if (this->PointZ)
   {
-    free(this->PointZ);
+    delete [] this->PointZ;
     this->PointZ = nullptr;
   }
 }
@@ -1915,8 +1876,10 @@ void vtkMPASReader::OutputCells()
     }
   }
 
-  free(this->ModConnections); this->ModConnections = nullptr;
-  free(this->OrigConnections); this->OrigConnections = nullptr;
+  delete [] this->ModConnections;
+  this->ModConnections = nullptr;
+  delete [] this->OrigConnections;
+  this->OrigConnections = nullptr;
 
   vtkDebugMacro(<< "Leaving OutputCells..." << endl);
 }

From 2506c23fe6c01ce6ab1f0526e59da2bb4a837c4d Mon Sep 17 00:00:00 2001
From: Ben Boeckel <ben.boeckel@kitware.com>
Date: Wed, 3 Oct 2018 14:53:12 -0400
Subject: [PATCH 2/9] vtkMPASReader: remove `using namespace std;`

---
 IO/NetCDF/vtkMPASReader.cxx | 24 +++++++++++-------------
 1 file changed, 11 insertions(+), 13 deletions(-)

diff --git a/IO/NetCDF/vtkMPASReader.cxx b/IO/NetCDF/vtkMPASReader.cxx
index e8bbe0651d0..11861f16309 100644
--- a/IO/NetCDF/vtkMPASReader.cxx
+++ b/IO/NetCDF/vtkMPASReader.cxx
@@ -100,8 +100,6 @@ PURPOSE.  See the above copyright notice for more information.
 #include <string>
 #include <vector>
 
-using namespace std;
-
 // In VTK commit 64cb89e3e6ae08f440eb6d4cbfb308c41ab7d258, a lot of signatures
 // in the netcdf library changed size values from 'long' to 'size_t'. However,
 // upstream versions of netcdf are using long. The following typedef resolves
@@ -189,7 +187,7 @@ class vtkMPASReader::Internal
   vtkTimeStamp extraDimTime;
 };
 
-bool vtkMPASReader::Internal::isExtraDim(const string &name)
+bool vtkMPASReader::Internal::isExtraDim(const std::string &name)
 {
   return name != "nCells" && name != "nVertices" && name != "Time";
 }
@@ -859,7 +857,7 @@ int vtkMPASReader::BuildVarArrays()
   for (size_t v = 0; v < this->Internals->pointVars.size(); v++)
   {
     NcVar *var = this->Internals->pointVars[v];
-    string name = this->UseDimensionedArrayNames ? dimensionedArrayName(var)
+    std::string name = this->UseDimensionedArrayNames ? dimensionedArrayName(var)
                                                  : var->name();
     this->PointDataArraySelection->EnableArray(name.c_str());
     // Register the dimensions:
@@ -873,7 +871,7 @@ int vtkMPASReader::BuildVarArrays()
   for (size_t v = 0; v < this->Internals->cellVars.size(); v++)
   {
     NcVar *var = this->Internals->cellVars[v];
-    string name = this->UseDimensionedArrayNames ? dimensionedArrayName(var)
+    std::string name = this->UseDimensionedArrayNames ? dimensionedArrayName(var)
                                                  : var->name();
     this->CellDataArraySelection->EnableArray(name.c_str());
     // Register the dimensions:
@@ -1316,8 +1314,8 @@ void vtkMPASReader::FixPoints()
       const double thresh = .06981317007977; // 4 degrees
       for (int k = 0; k < this->PointsPerCell; k++)
       {
-        double ydiff = abs(this->PointY[conns[k]]
-                           - this->PointY[conns[lastk]]);
+        double ydiff = std::abs(this->PointY[conns[k]]
+                                - this->PointY[conns[lastk]]);
         // Don't look at cells at map border
         if (ydiff > thresh)
         {
@@ -1394,7 +1392,7 @@ int vtkMPASReader::EliminateXWrap()
     bool xWrap = false;
     for (int k = 0; k < this->PointsPerCell; k++)
     {
-      if (abs(this->PointX[conns[k]] - this->PointX[conns[lastk]]) > tolerance)
+      if (std::abs(this->PointX[conns[k]] - this->PointX[conns[lastk]]) > tolerance)
       {
         xWrap = true;
         break;
@@ -1416,7 +1414,7 @@ int vtkMPASReader::EliminateXWrap()
         int neigh = conns[k];
 
         // add a new point, figure out east or west
-        if (abs(this->PointX[neigh] - anchorX) > tolerance)
+        if (std::abs(this->PointX[neigh] - anchorX) > tolerance)
         {
           modConns[k] = this->AddMirrorPoint(neigh, anchorX, xLength);
         }
@@ -1443,7 +1441,7 @@ int vtkMPASReader::EliminateXWrap()
         int neigh = conns[k];
 
         // add a new point for neighbor, figure out east or west
-        if (abs(this->PointX[neigh] - anchorX) > tolerance)
+        if (std::abs(this->PointX[neigh] - anchorX) > tolerance)
         {
           addedConns[k] = this->AddMirrorPoint(neigh, anchorX, xLength);
         }
@@ -1812,7 +1810,7 @@ void vtkMPASReader::OutputCells()
       // Take the min of the this->MaximumLevelPoint of each point
       for (int k = 1; k < this->PointsPerCell; k++)
       {
-        minLevel = min(minLevel, this->MaximumLevelPoint[connections[k]]);
+        minLevel = std::min(minLevel, this->MaximumLevelPoint[connections[k]]);
       }
     }
 
@@ -2648,7 +2646,7 @@ int vtkMPASReader::GetDimensionCurrentIndex(const std::string &dim)
 }
 
 //----------------------------------------------------------------------------
-void vtkMPASReader::SetDimensionCurrentIndex(const string &dim, int idx)
+void vtkMPASReader::SetDimensionCurrentIndex(const std::string &dim, int idx)
 {
   this->UpdateDimensions();
 
@@ -2664,7 +2662,7 @@ void vtkMPASReader::SetDimensionCurrentIndex(const string &dim, int idx)
 }
 
 //----------------------------------------------------------------------------
-int vtkMPASReader::GetDimensionSize(const string &dim)
+int vtkMPASReader::GetDimensionSize(const std::string &dim)
 {
   this->UpdateDimensions();
 

From cc59c8be49958a66f36c5ba4479ce1a64ed04a6a Mon Sep 17 00:00:00 2001
From: Ben Boeckel <ben.boeckel@kitware.com>
Date: Mon, 15 Oct 2018 10:12:23 -0400
Subject: [PATCH 3/9] vtkMPASReader: use vtkIdType for the number of dimensions

---
 IO/NetCDF/vtkMPASReader.cxx | 2 +-
 IO/NetCDF/vtkMPASReader.h   | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/IO/NetCDF/vtkMPASReader.cxx b/IO/NetCDF/vtkMPASReader.cxx
index 11861f16309..103da999821 100644
--- a/IO/NetCDF/vtkMPASReader.cxx
+++ b/IO/NetCDF/vtkMPASReader.cxx
@@ -2611,7 +2611,7 @@ void vtkMPASReader::SetCellArrayStatus(const char* name, int status)
 }
 
 //----------------------------------------------------------------------------
-int vtkMPASReader::GetNumberOfDimensions()
+vtkIdType vtkMPASReader::GetNumberOfDimensions()
 {
   this->UpdateDimensions();
   return this->Internals->extraDims->GetNumberOfTuples();
diff --git a/IO/NetCDF/vtkMPASReader.h b/IO/NetCDF/vtkMPASReader.h
index 26f1b719033..06e2918c0d5 100644
--- a/IO/NetCDF/vtkMPASReader.h
+++ b/IO/NetCDF/vtkMPASReader.h
@@ -177,7 +177,7 @@ class VTKIONETCDF_EXPORT vtkMPASReader : public vtkUnstructuredGridAlgorithm
    * in the dimensions, and Set/GetDimensionCurrentIndex controls the value
    * to fix a given dimension at when extracting slices of data.
    */
-  int GetNumberOfDimensions();
+  vtkIdType GetNumberOfDimensions();
   std::string GetDimensionName(int idx);
   vtkStringArray* GetAllDimensions();
   int GetDimensionCurrentIndex(const std::string &dim);

From 4418b352d799ea56e8032b6f61990c87742d108e Mon Sep 17 00:00:00 2001
From: Ben Boeckel <ben.boeckel@kitware.com>
Date: Mon, 15 Oct 2018 10:12:35 -0400
Subject: [PATCH 4/9] vtkMPASReader: cast dimension sizes

---
 IO/NetCDF/vtkMPASReader.cxx | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/IO/NetCDF/vtkMPASReader.cxx b/IO/NetCDF/vtkMPASReader.cxx
index 103da999821..2f59462ae89 100644
--- a/IO/NetCDF/vtkMPASReader.cxx
+++ b/IO/NetCDF/vtkMPASReader.cxx
@@ -2642,7 +2642,7 @@ int vtkMPASReader::GetDimensionCurrentIndex(const std::string &dim)
   {
     return -1;
   }
-  return it->second.curIdx;
+  return static_cast<int>(it->second.curIdx);
 }
 
 //----------------------------------------------------------------------------
@@ -2672,7 +2672,7 @@ int vtkMPASReader::GetDimensionSize(const std::string &dim)
   {
     return -1;
   }
-  return it->second.dimSize;
+  return static_cast<int>(it->second.dimSize);
 }
 
 //----------------------------------------------------------------------------

From d6540e77cf6852f292c09bfb02e58f04f9ace6a1 Mon Sep 17 00:00:00 2001
From: Ben Boeckel <ben.boeckel@kitware.com>
Date: Mon, 15 Oct 2018 11:31:38 -0400
Subject: [PATCH 5/9] vtkMPASReader: remove dependency on netcdfcpp

---
 IO/NetCDF/vtkMPASReader.cxx | 1832 ++++++++++++++++++++---------------
 IO/NetCDF/vtkMPASReader.h   |   66 +-
 2 files changed, 1084 insertions(+), 814 deletions(-)

diff --git a/IO/NetCDF/vtkMPASReader.cxx b/IO/NetCDF/vtkMPASReader.cxx
index 2f59462ae89..a99db76e675 100644
--- a/IO/NetCDF/vtkMPASReader.cxx
+++ b/IO/NetCDF/vtkMPASReader.cxx
@@ -85,7 +85,7 @@ PURPOSE.  See the above copyright notice for more information.
 #include "vtkToolkits.h"
 #include "vtkUnstructuredGrid.h"
 
-#include "vtk_netcdfcpp.h"
+#include "vtk_netcdf.h"
 
 #include <algorithm>
 #include <cfloat>
@@ -100,19 +100,6 @@ PURPOSE.  See the above copyright notice for more information.
 #include <string>
 #include <vector>
 
-// In VTK commit 64cb89e3e6ae08f440eb6d4cbfb308c41ab7d258, a lot of signatures
-// in the netcdf library changed size values from 'long' to 'size_t'. However,
-// upstream versions of netcdf are using long. The following typedef resolves
-// this issue.
-// We cannot just check for VTK_USE_SYSTEM_NETCDF because ParaView's superbuild
-// installs a "system" netcdf with the same modifications...
-#if defined(VTK_NETCDFCPP_USE_SIZE_T) || defined(VTK_NETCDF_USE_SIZE_T)
-typedef size_t nc_size_t;
-#else
-typedef long nc_size_t;
-#endif
-
-
 // Restricted to the supported NcType-convertible types.
 #define vtkNcTemplateMacro(call)                                               \
   vtkTemplateMacroCase(VTK_DOUBLE, double, call);                              \
@@ -133,27 +120,74 @@ typedef long nc_size_t;
 
 namespace {
 
-std::string dimensionedArrayName(NcVar *var)
+struct DimMetaData
 {
-  std::ostringstream out;
-  out << var->name() << "(";
-  for (int dim = 0; dim < var->num_dims(); ++dim)
+  long curIdx;
+  size_t dimSize;
+};
+
+//------------------------------------------------------------------------------
+inline int NcTypeToVtkType(nc_type type)
+{
+  switch (type)
   {
-    if (dim != 0)
-    {
-      out << ", ";
-    }
-    out << var->get_dim(dim)->name();
+    case NC_BYTE:
+      return VTK_SIGNED_CHAR;
+    case NC_CHAR:
+      return VTK_CHAR;
+    case NC_SHORT:
+      return VTK_SHORT;
+    case NC_INT:
+      return VTK_INT;
+    case NC_FLOAT:
+      return VTK_FLOAT;
+    case NC_DOUBLE:
+      return VTK_DOUBLE;
+    case NC_NAT:
+    default: // Shouldn't happen...
+      vtkGenericWarningMacro(<<"Invalid NcType: " << type);
+      return VTK_VOID;
   }
-  out << ")";
-  return out.str();
 }
 
-struct DimMetaData
+template<typename T>
+int nc_get_vara(int ncid, int varid, size_t start[], size_t count[], T *data);
+
+template<>
+int nc_get_vara(int ncid, int varid, size_t start[], size_t count[], double *data)
 {
-  long curIdx;
-  long dimSize;
-};
+  return nc_get_vara_double(ncid, varid, start, count, data);
+}
+
+template<>
+int nc_get_vara(int ncid, int varid, size_t start[], size_t count[], float *data)
+{
+  return nc_get_vara_float(ncid, varid, start, count, data);
+}
+
+template<>
+int nc_get_vara(int ncid, int varid, size_t start[], size_t count[], int *data)
+{
+  return nc_get_vara_int(ncid, varid, start, count, data);
+}
+
+template<>
+int nc_get_vara(int ncid, int varid, size_t start[], size_t count[], short *data)
+{
+  return nc_get_vara_short(ncid, varid, start, count, data);
+}
+
+template<>
+int nc_get_vara(int ncid, int varid, size_t start[], size_t count[], char *data)
+{
+  return nc_get_vara_text(ncid, varid, start, count, data);
+}
+
+template<>
+int nc_get_vara(int ncid, int varid, size_t start[], size_t count[], signed char *data)
+{
+  return nc_get_vara_schar(ncid, varid, start, count, data);
+}
 
 } // end anon namespace
 
@@ -167,12 +201,58 @@ class vtkMPASReader::Internal
   // variableIndex --> vtkDataArray
   typedef std::map<int, vtkSmartPointer<vtkDataArray> > ArrayMap;
   typedef std::map<std::string, DimMetaData> DimMetaDataMap;
-  Internal() : ncFile(nullptr) {}
-  ~Internal() { delete ncFile; }
+  Internal(vtkMPASReader *r) : ncFile(-1), reader(r) {}
+  ~Internal()
+  {
+    close();
+  }
+
+  bool open(const char* file)
+  {
+    int mode = NC_NOWRITE | NC_64BIT_OFFSET | NC_NETCDF4 | NC_CLASSIC_MODEL;
+    int ncid;
+    if (nc_err(nc_open(file, mode, &ncid)))
+    {
+      return false;
+    }
+    ncFile = ncid;
+    return true;
+  }
+  void close()
+  {
+    if (ncFile != -1)
+    {
+      nc_err(nc_close(ncFile));
+      ncFile = -1;
+    }
+  }
+
+  bool nc_err(int nc_ret, bool msg_on_err = true) const;
+
+  std::string dimensionedArrayName(int nc_var) const;
+  bool ValidateDimensions(int nc_var, bool silent, int ndims, ...) const;
+  size_t GetCursorForDimension(int nc_dim);
+  size_t GetCountForDimension(int nc_dim) const;
+  long InitializeDimension(int nc_dim);
+  vtkIdType ComputeNumberOfTuples(int nc_var) const;
+
+  template <typename ValueType>
+  bool LoadDataArray(int nc_var, vtkDataArray *array, bool resize = true);
+
+  template <typename ValueType>
+  int LoadPointVarDataImpl(int nc_var, vtkDataArray *array);
+
+  template <typename ValueType>
+  int LoadCellVarDataImpl(int nc_var, vtkDataArray *array);
+
+  int nc_var_id(const char* name, bool msg_on_err = true) const;
+  int nc_dim_id(const char* name, bool msg_on_err = true) const;
+  int nc_att_id(const char* name, bool msg_on_err = true) const;
 
-  NcFile* ncFile;
-  std::vector<NcVar*> pointVars;
-  std::vector<NcVar*> cellVars;
+  int ncFile;
+  vtkMPASReader *reader;
+  std::vector<int> pointVars;
+  std::vector<int> cellVars;
   ArrayMap pointArrays;
   ArrayMap cellArrays;
 
@@ -192,47 +272,584 @@ bool vtkMPASReader::Internal::isExtraDim(const std::string &name)
   return name != "nCells" && name != "nVertices" && name != "Time";
 }
 
+bool vtkMPASReader::Internal::nc_err(int nc_ret, bool msg_on_err) const
+{
+  if (nc_ret == NC_NOERR)
+  {
+    return false;
+  }
 
-//----------------------------------------------------------------------------
-//  Macro to check if the named NetCDF dimension exists
-//----------------------------------------------------------------------------
+  if (msg_on_err)
+  {
+    vtkErrorWithObjectMacro(reader, << "NetCDF error: " << nc_strerror(nc_ret));
+  }
+  return true;
+}
+
+std::string vtkMPASReader::Internal::dimensionedArrayName(int nc_var) const
+{
+  char name[NC_MAX_NAME + 1];
+  if (nc_err(nc_inq_varname(ncFile, nc_var, name)))
+  {
+    return "";
+  }
+
+  int ndims;
+  if (nc_err(nc_inq_varndims(ncFile, nc_var, &ndims)))
+  {
+    return "";
+  }
+  int dims[NC_MAX_VAR_DIMS];
+  if (nc_err(nc_inq_vardimid(ncFile, nc_var, dims)))
+  {
+    return "";
+  }
+
+  std::ostringstream out;
+  out << name << "(";
+
+  for (int dim = 0; dim < ndims; ++dim)
+  {
+    if (dim != 0)
+    {
+      out << ", ";
+    }
+
+    if (nc_err(nc_inq_dimname(ncFile, dims[dim], name)))
+    {
+      return "";
+    }
+    out << name;
+  }
+  out << ")";
+  return out.str();
+}
+
+//------------------------------------------------------------------------------
+// Returns true if the dimensions in var match the expected args, or prints a
+// warning and returns false if any are incorrect.
+// ndims is the number of dimensions, and the variatic args must be
+// C-strings identifying the expected dimensions.
+// If silent is true, no warnings are printed.
+//------------------------------------------------------------------------------
+bool vtkMPASReader::Internal::ValidateDimensions(int nc_var, bool silent, int ndims, ...) const
+{
+  int nc_ndims;
+  if (nc_err(nc_inq_varndims(ncFile, nc_var, &nc_ndims)))
+  {
+    return false;
+  }
+
+  if (nc_ndims != ndims)
+  {
+    if (!silent)
+    {
+      char name[NC_MAX_NAME + 1];
+      if (nc_err(nc_inq_varname(ncFile, nc_var, name)))
+      {
+        return false;
+      }
+      vtkWarningWithObjectMacro(reader,
+          << "Expected variable '" << name << "' to have "
+          << ndims << " dimension(s), but it has " << nc_ndims
+          << ".");
+    }
+    return false;
+  }
+
+  int dims[NC_MAX_VAR_DIMS];
+  if (nc_err(nc_inq_vardimid(ncFile, nc_var, dims)))
+  {
+    return false;
+  }
+
+  va_list args;
+  va_start(args, ndims);
+
+  for (int i = 0; i < ndims; ++i)
+  {
+    char nc_name[NC_MAX_NAME + 1];
+    if (nc_err(nc_inq_dimname(ncFile, dims[i], nc_name)))
+    {
+      va_end(args);
+      return false;
+    }
+    std::string dimName(va_arg(args, const char *));
+    if (dimName != nc_name)
+    {
+      if (!silent)
+      {
+        char name[NC_MAX_NAME + 1];
+        if (nc_err(nc_inq_varname(ncFile, nc_var, name)))
+        {
+          return false;
+        }
+        vtkWarningWithObjectMacro(reader,
+            << "Expected variable '" << name << "' to have '"
+            << dimName << "' at dimension index " << i << ", not '"
+            << nc_name << "'.");
+      }
+      va_end(args);
+      return false;
+    }
+  }
+
+  va_end(args);
+
+  return true;
+}
+
+//------------------------------------------------------------------------------
+// Return the cursor position for the specified dimension.
+//------------------------------------------------------------------------------
+size_t vtkMPASReader::Internal::GetCursorForDimension(int nc_dim)
+{
+  char name[NC_MAX_NAME + 1];
+  if (nc_err(nc_inq_dimname(ncFile, nc_dim, name)))
+  {
+    return static_cast<size_t>(-1);
+  }
+  std::string dimName = name;
+  if (dimName == "nCells" || dimName == "nVertices")
+  {
+    return 0;
+  }
+  else if (dimName == "Time")
+  {
+    return std::min(static_cast<long>(std::floor(reader->DTime)),
+                    static_cast<long>(reader->NumberOfTimeSteps-1));
+  }
+  else if (reader->ShowMultilayerView &&
+           dimName == reader->VerticalDimension)
+  {
+    return 0;
+  }
+  else
+  {
+    return InitializeDimension(nc_dim);
+  }
+}
+
+//------------------------------------------------------------------------------
+// Return the number of values to read for the specified dimension.
+//------------------------------------------------------------------------------
+size_t vtkMPASReader::Internal::GetCountForDimension(int nc_dim) const
+{
+  char name[NC_MAX_NAME + 1];
+  if (nc_err(nc_inq_dimname(ncFile, nc_dim, name)))
+  {
+    return static_cast<size_t>(-1);
+  }
+  std::string dimName = name;
+  if (dimName == "nCells")
+  {
+    return reader->NumberOfPoints;
+  }
+  else if (dimName == "nVertices")
+  {
+    return reader->NumberOfCells;
+  }
+  else if (reader->ShowMultilayerView && dimName == reader->VerticalDimension)
+  {
+    return reader->MaximumNVertLevels;
+  }
+  else
+  {
+    return 1;
+  }
+}
+
+//------------------------------------------------------------------------------
+// For an arbitrary (i.e. not nCells, nVertices, or Time) dimension, extract
+// the dimension's metadata into memory (if needed) and return the last used
+// index into the dimension values, or 0 if the dimension is new.
+// For an arbitrary (i.e. not nCells, nVertices, or Time) dimension, extract
+//------------------------------------------------------------------------------
+long vtkMPASReader::Internal::InitializeDimension(int nc_dim)
+{
+  char name[NC_MAX_NAME + 1];
+  if (nc_err(nc_inq_dimname(ncFile, nc_dim, name)))
+  {
+    return false;
+  }
+  Internal::DimMetaDataMap::const_iterator match =
+      dimMetaDataMap.find(name);
+
+  long result = 0;
+  if (match == dimMetaDataMap.end())
+  {
+    DimMetaData metaData;
+    metaData.curIdx = result;
+    if (nc_err(nc_inq_dimlen(ncFile, nc_dim, &metaData.dimSize)))
+    {
+      return -1;
+    }
+
+    dimMetaDataMap.insert(
+          std::make_pair(std::string(name), metaData));
+    dimMetaDataTime.Modified();
+  }
+  else
+  {
+    result = match->second.curIdx;
+  }
+
+  return result;
+}
+
+//------------------------------------------------------------------------------
+vtkIdType vtkMPASReader::Internal::ComputeNumberOfTuples(int nc_var) const
+{
+  int numDims;
+  if (nc_err(nc_inq_varndims(ncFile, nc_var, &numDims)))
+  {
+    return 0;
+  }
+  int dims[NC_MAX_VAR_DIMS];
+  if (nc_err(nc_inq_vardimid(ncFile, nc_var, dims)))
+  {
+    return 0;
+  }
+  vtkIdType size = 0;
+  for (int dim = 0; dim < numDims; ++dim)
+  {
+    vtkIdType count = static_cast<vtkIdType>(GetCountForDimension(dims[dim]));
+    if (size == 0)
+    {
+      size = count;
+    }
+    else
+    {
+      size *= count;
+    }
+  }
+  return size;
+}
+
+//------------------------------------------------------------------------------
+template <typename ValueType>
+bool vtkMPASReader::Internal::LoadDataArray(int nc_var, vtkDataArray *array, bool resize)
+{
+  nc_type var_type;
+  if (nc_err(nc_inq_vartype(ncFile, nc_var, &var_type)))
+  {
+    return false;
+  }
+  if (array->GetDataType() != NcTypeToVtkType(var_type))
+  {
+    vtkWarningWithObjectMacro(reader, "Invalid array type.");
+    return false;
+  }
+
+  int numDims;
+  if (nc_err(nc_inq_varndims(ncFile, nc_var, &numDims)))
+  {
+    return false;
+  }
+  int dims[NC_MAX_VAR_DIMS];
+  if (nc_err(nc_inq_vardimid(ncFile, nc_var, dims)))
+  {
+    return false;
+  }
+  std::vector<size_t> cursor;
+  std::vector<size_t> counts;
+  vtkIdType size = 0;
+
+  for (int dim = 0; dim < numDims; ++dim)
+  {
+    cursor.push_back(GetCursorForDimension(dims[dim]));
+    counts.push_back(GetCountForDimension(dims[dim]));
+    if (size == 0)
+    {
+      size = counts.back();
+    }
+    else
+    {
+      size *= counts.back();
+    }
+  }
+
+  if (resize)
+  {
+    array->SetNumberOfComponents(1);
+    array->SetNumberOfTuples(size);
+  }
+  else
+  {
+    if (array->GetNumberOfComponents() != 1)
+    {
+      vtkWarningWithObjectMacro(reader, "Invalid number of components: "
+                      << array->GetNumberOfComponents() << ".");
+      return false;
+    }
+    else if (array->GetNumberOfTuples() < size)
+    {
+      vtkWarningWithObjectMacro(reader, "Array only has " << array->GetNumberOfTuples()
+                      << " allocated, but we need " << size << ".");
+      return false;
+    }
+  }
+
+  ValueType *dataBlock = static_cast<ValueType*>(array->GetVoidPointer(0));
+  if (!dataBlock)
+  {
+    vtkWarningWithObjectMacro(reader, "GetVoidPointer returned nullptr.");
+    return false;
+  }
+
+  if (nc_err(nc_get_vara<ValueType>(ncFile, nc_var, &cursor[0], &counts[0], dataBlock)))
+  {
+    vtkWarningWithObjectMacro(reader, "Reading " << size << " elements failed.");
+    return false;
+  }
+
+  return true;
+}
+
+//------------------------------------------------------------------------------
+template <typename ValueType>
+int vtkMPASReader::Internal::LoadPointVarDataImpl(int nc_var, vtkDataArray *array)
+{
+  // Don't resize, we've preallocated extra room for multilayer (if needed):
+  if (!LoadDataArray<ValueType>(nc_var, array, /*resize=*/false))
+  {
+    return 0;
+  }
+
+  // Check if this variable contains the vertical dimension:
+  bool hasVerticalDimension = false;
+  int numDims;
+  if (nc_err(nc_inq_varndims(ncFile, nc_var, &numDims)))
+  {
+    return 0;
+  }
+  if (reader->ShowMultilayerView)
+  {
+    char name[NC_MAX_NAME + 1];
+    int dims[NC_MAX_VAR_DIMS];
+    if (nc_err(nc_inq_vardimid(ncFile, nc_var, dims)))
+    {
+      return 0;
+    }
+    for (int d = 0; d < numDims; ++d)
+    {
+      if (nc_err(nc_inq_dimname(ncFile, dims[d], name)))
+      {
+        return 0;
+      }
+      if (reader->VerticalDimension == name)
+      {
+        hasVerticalDimension = true;
+        break;
+      }
+    }
+  }
+
+  vtkIdType varSize = ComputeNumberOfTuples(nc_var);
+  ValueType *dataBlock = static_cast<ValueType*>(array->GetVoidPointer(0));
+  std::vector<ValueType> tempData; // Used for Multilayer
+
+  // singlelayer
+  if (!reader->ShowMultilayerView)
+  {
+    // Account for point offset:
+    if (reader->PointOffset != 0)
+    {
+      assert(reader->NumberOfPoints <= static_cast<size_t>(array->GetNumberOfTuples()) &&
+             "Source array too small.");
+      assert(reader->PointOffset + reader->NumberOfPoints <=
+             static_cast<size_t>(array->GetNumberOfTuples()) && "Destination array too small.");
+      if (reader->PointOffset < reader->NumberOfPoints)
+      {
+        std::copy_backward(dataBlock, dataBlock + reader->NumberOfPoints,
+                           dataBlock + reader->PointOffset +
+                           reader->NumberOfPoints);
+      }
+      else
+      {
+        std::copy(dataBlock, dataBlock + reader->NumberOfPoints,
+                  dataBlock + reader->PointOffset);
+      }
+    }
+    dataBlock[0] = dataBlock[1];
+    // data is all in place, don't need to do next step
+  }
+  else
+  { // multilayer
+    if (reader->MaximumPoints == 0)
+    {
+      return 0; // No points
+    }
+
+    tempData.resize(reader->MaximumPoints);
+    size_t vertPointOffset = reader->MaximumNVertLevels * reader->PointOffset;
+    ValueType *dataPtr = &tempData[0] + vertPointOffset;
+
+    assert(varSize < array->GetNumberOfTuples());
+    assert(varSize < static_cast<vtkIdType>(reader->MaximumPoints -
+                                            vertPointOffset));
+    std::copy(dataBlock, dataBlock + varSize, dataPtr);
+
+    if (!hasVerticalDimension)
+    {
+      // need to replicate data over all vertical layers
+      // layout in memory needs to be:
+      // pt1, pt1, ..., (VertLevels times), pt2, pt2, ..., (VertLevels times),
+      // need to go backwards through the points in order to not overwrite
+      // anything.
+      for(size_t i = reader->NumberOfPoints; i > 0; i--)
+      {
+        // point to copy
+        ValueType pt = *(dataPtr + i - 1);
+
+        // where to start copying
+        ValueType *copyPtr = dataPtr + (i-1)*reader->MaximumNVertLevels;
+
+        std::fill(copyPtr, copyPtr + reader->MaximumNVertLevels, pt);
+      }
+    }
+  }
+
+  vtkDebugWithObjectMacro(reader, <<"Got point data.");
+
+  size_t i = 0;
+  size_t k = 0;
+
+  if (reader->ShowMultilayerView)
+  {
+    // put in dummy points
+    assert(reader->MaximumNVertLevels * 2 <= static_cast<size_t>(reader->MaximumPoints));
+    assert(reader->MaximumNVertLevels <= static_cast<size_t>(array->GetNumberOfTuples()));
+    std::copy(tempData.begin() + reader->MaximumNVertLevels,
+              tempData.begin() + (2*reader->MaximumNVertLevels),
+              dataBlock);
+
+    // write highest level dummy point (duplicate of last level)
+    assert(reader->MaximumNVertLevels < static_cast<size_t>(array->GetNumberOfTuples()));
+    assert(2*reader->MaximumNVertLevels - 1 < static_cast<size_t>(reader->MaximumPoints));
+    dataBlock[reader->MaximumNVertLevels] =
+        tempData[2*reader->MaximumNVertLevels - 1];
+
+    vtkDebugWithObjectMacro(reader, <<"Wrote dummy point data.");
+
+    // put in other points
+    for (size_t j = reader->PointOffset;
+         j < reader->NumberOfPoints + reader->PointOffset;
+         j++)
+    {
+
+      i = j*(reader->MaximumNVertLevels+1);
+      k = j*(reader->MaximumNVertLevels);
+
+      // write data for one point -- lowest level to highest
+      assert(k + reader->MaximumNVertLevels <= static_cast<size_t>(reader->MaximumPoints));
+      assert(i + reader->MaximumNVertLevels <= static_cast<size_t>(array->GetNumberOfTuples()));
+      std::copy(tempData.begin() + k,
+                tempData.begin() + k + reader->MaximumNVertLevels,
+                dataBlock + i);
+
+      // for last layer of points, repeat last level's values
+      // Need Mark's input on reader one
+      dataBlock[i++] = tempData[--k];
+      //vtkDebugWithObjectMacro(reader, << "Wrote j:" << j << endl);
+    }
+  }
+
+  vtkDebugWithObjectMacro(reader, <<"Wrote next points.");
+
+  vtkDebugWithObjectMacro(reader, <<"NumberOfPoints: " << reader->NumberOfPoints << " "
+                <<"CurrentExtraPoint: " << reader->CurrentExtraPoint);
+
+  // put out data for extra points
+  for (size_t j = reader->PointOffset + reader->NumberOfPoints;
+       j < reader->CurrentExtraPoint;
+       j++)
+  {
+    // use map to find out what point data we are using
+    if (!reader->ShowMultilayerView)
+    {
+      k = reader->PointMap[j - reader->NumberOfPoints - reader->PointOffset];
+      assert(j < array->GetNumberOfTuples());
+      assert(k < array->GetNumberOfTuples());
+      dataBlock[j] = dataBlock[k];
+    }
+    else
+    {
+      k = reader->PointMap[j - reader->NumberOfPoints - reader->PointOffset] *
+          reader->MaximumNVertLevels;
+      // write data for one point -- lowest level to highest
+      assert(k + reader->MaximumNVertLevels <= static_cast<size_t>(reader->MaximumPoints));
+      assert(i + reader->MaximumNVertLevels <= static_cast<size_t>(array->GetNumberOfTuples()));
+      std::copy(tempData.begin() + k,
+                tempData.begin() + k + reader->MaximumNVertLevels,
+                dataBlock + i);
+
+      // for last layer of points, repeat last level's values
+      // Need Mark's input on this one
+      dataBlock[i++] = tempData[--k];
+    }
+  }
+
+  vtkDebugWithObjectMacro(reader, <<"wrote extra point data.");
+  return 1;
+}
+
+//------------------------------------------------------------------------------
+template <typename ValueType>
+int vtkMPASReader::Internal::LoadCellVarDataImpl(int nc_var, vtkDataArray *array)
+{
+  // Don't resize, we've preallocated extra room for multilayer (if needed):
+  if (!LoadDataArray<ValueType>(nc_var, array, /*resize=*/false))
+  {
+    return 0;
+  }
+
+  ValueType *dataBlock = static_cast<ValueType*>(array->GetVoidPointer(0));
+
+  // put out data for extra cells
+  for (size_t j = reader->CellOffset + reader->NumberOfCells;
+       j < reader->CurrentExtraCell;
+       j++)
+  {
+    // use map to find out what cell data we are using
+    if (!reader->ShowMultilayerView)
+    {
+      size_t k = reader->CellMap[j - reader->NumberOfCells - reader->CellOffset];
+      assert(j < array->GetNumberOfTuples());
+      assert(k < array->GetNumberOfTuples());
+      dataBlock[j] = dataBlock[k];
+    }
+    else
+    {
+      size_t i = j*reader->MaximumNVertLevels;
+      size_t k = reader->CellMap[j - reader->NumberOfCells - reader->CellOffset] *
+                    reader->MaximumNVertLevels;
 
-#define CHECK_DIM(ncFile, name) \
-  if (!isNcDim(ncFile, name))                                       \
-  {                                                                 \
-  vtkErrorMacro( << "Cannot find dimension: " << name << endl);     \
-  return 0;                                                         \
+      // write data for one cell -- lowest level to highest
+      assert(i < array->GetNumberOfTuples());
+      assert(k + reader->MaximumNVertLevels <= static_cast<size_t>(array->GetNumberOfTuples()));
+      std::copy(dataBlock + k, dataBlock + k + reader->MaximumNVertLevels,
+                dataBlock + i);
+    }
   }
 
-//----------------------------------------------------------------------------
-// Macro to check if the named NetCDF variable exists
-//----------------------------------------------------------------------------
-
-#define CHECK_VAR(ncFile, name)                                    \
-  if (!isNcVar(ncFile, name))                                      \
-  {                                                                \
-  vtkErrorMacro( << "Cannot find variable: " << name << endl);     \
-  return 0;                                                        \
-  }
+  vtkDebugWithObjectMacro(reader, <<"Stored data.");
 
+  return 1;
+}
 
 //----------------------------------------------------------------------------
 // Function to check if there is a NetCDF variable by that name
 //-----------------------------------------------------------------------------
 
-static bool isNcVar(NcFile *ncFile, NcToken name)
+int vtkMPASReader::Internal::nc_var_id(const char* name, bool msg_on_err) const
 {
-  int num_vars = ncFile->num_vars();
-  for (int i = 0; i < num_vars; i++)
+  int varid;
+  if (nc_err(nc_inq_varid(ncFile, name, &varid), msg_on_err))
   {
-    NcVar* ncVar = ncFile->get_var(i);
-    if ((strcmp(ncVar->name(), name)) == 0)
-    {
-      // we have a match, so return
-      return true;
-    }
+    return -1;
   }
-  return false;
+  return varid;
 }
 
 
@@ -240,42 +857,53 @@ static bool isNcVar(NcFile *ncFile, NcToken name)
 // Check if there is a NetCDF dimension by that name
 //----------------------------------------------------------------------------
 
-static bool isNcDim(NcFile *ncFile, NcToken name)
+int vtkMPASReader::Internal::nc_dim_id(const char* name, bool msg_on_err) const
 {
-  int num_dims = ncFile->num_dims();
-  //cerr << "looking for: " << name << endl;
-  for (int i = 0; i < num_dims; i++)
+  int dimid;
+  if (nc_err(nc_inq_dimid(ncFile, name, &dimid), msg_on_err))
   {
-    NcDim* ncDim = ncFile->get_dim(i);
-    //cerr << "checking " << ncDim->name() << endl;
-    const char* ncDimName = ncDim->name();
-    if ((ncDimName && strcmp(ncDimName, name)) == 0)
-    {
-      // we have a match, so return
-      return true;
-    }
+    return -1;
   }
-  return false;
+  return dimid;
 }
 
 //----------------------------------------------------------------------------
 // Check if there is a NetCDF attribute by that name
 //----------------------------------------------------------------------------
 
-static bool isNcAtt(NcFile *ncFile, NcToken name)
+int vtkMPASReader::Internal::nc_att_id(const char* name, bool msg_on_err) const
 {
-  int num_atts = ncFile->num_atts();
-  for (int i = 0; i < num_atts; i++)
+  int attid;
+  if (nc_err(nc_inq_attid(ncFile, NC_GLOBAL, name, &attid), msg_on_err))
   {
-    NcAtt *ncAtt = ncFile->get_att(i);
-    if ((strcmp(ncAtt->name(), name)) == 0)
-    {
-      return true;
-    }
+    return -1;
   }
-  return false;
+  return attid;
 }
 
+//----------------------------------------------------------------------------
+//  Macro to check if the named NetCDF dimension exists
+//----------------------------------------------------------------------------
+
+#define CHECK_DIM(name, out) \
+  if ((out = this->Internals->nc_dim_id(name)) == -1)               \
+  {                                                                 \
+  vtkErrorMacro( << "Cannot find dimension: " << name << endl);     \
+  return 0;                                                         \
+  }
+
+//----------------------------------------------------------------------------
+// Macro to check if the named NetCDF variable exists
+//----------------------------------------------------------------------------
+
+#define CHECK_VAR(name, out)                                       \
+  if ((out = this->Internals->nc_var_id(name)) == -1)              \
+  {                                                                \
+  vtkErrorMacro( << "Cannot find variable: " << name << endl);     \
+  return 0;                                                        \
+  }
+
+
 //-----------------------------------------------------------------------------
 //  Function to convert cartesian coordinates to spherical, for use in
 //  computing points in different layers of multilayer spherical view
@@ -335,7 +963,7 @@ vtkStandardNewMacro(vtkMPASReader);
 
 vtkMPASReader::vtkMPASReader()
 {
-  this->Internals = new vtkMPASReader::Internal;
+  this->Internals = new vtkMPASReader::Internal(this);
 
   // Debugging
   //this->DebugOn();
@@ -393,8 +1021,7 @@ vtkMPASReader::~vtkMPASReader()
 
   this->SetFileName(nullptr);
 
-  delete this->Internals->ncFile;
-  this->Internals->ncFile = nullptr;
+  this->Internals->close();
 
   this->DestroyData();
 
@@ -450,8 +1077,7 @@ void vtkMPASReader::ReleaseNcData()
   delete [] this->MaximumLevelPoint;
   this->MaximumLevelPoint = nullptr;
 
-  delete this->Internals->ncFile;
-  this->Internals->ncFile = nullptr;
+  this->Internals->close();
 }
 
 //----------------------------------------------------------------------------
@@ -482,8 +1108,7 @@ int vtkMPASReader::RequestInformation(
   // Get ParaView information pointer
   vtkInformation* outInfo = outVector->GetInformationObject(0);
 
-  this->Internals->ncFile = new NcFile(this->FileName);
-  if (!this->Internals->ncFile->is_valid())
+  if (!this->Internals->open(this->FileName))
   {
     vtkErrorMacro( << "Couldn't open file: " << this->FileName << endl);
     this->ReleaseNcData();
@@ -523,7 +1148,7 @@ int vtkMPASReader::RequestInformation(
     // Tell the pipeline what steps are available
     std::vector<double> timeSteps;
     timeSteps.reserve(this->NumberOfTimeSteps);
-    for (int i = 0; i < this->NumberOfTimeSteps; ++i)
+    for (size_t i = 0; i < this->NumberOfTimeSteps; ++i)
     {
       timeSteps.push_back(static_cast<double>(i));
     }
@@ -587,8 +1212,11 @@ int vtkMPASReader::RequestData(vtkInformation *vtkNotUsed(reqInfo),
       vtkDataArray *array = this->LoadPointVarData(var);
       if (!array)
       {
-        vtkWarningMacro(<< "Error loading point variable '"
-                        << this->Internals->pointVars[var]->name() << "'.");
+        char name[NC_MAX_NAME + 1];
+        if (!this->Internals->nc_err(nc_inq_varname(this->Internals->ncFile, this->Internals->pointVars[var], name)))
+        {
+          vtkWarningMacro(<< "Error loading point variable '" << name << "'.");
+        }
         continue;
       }
       output->GetPointData()->AddArray(array);
@@ -603,8 +1231,11 @@ int vtkMPASReader::RequestData(vtkInformation *vtkNotUsed(reqInfo),
       vtkDataArray *array = this->LoadCellVarData(var);
       if (!array)
       {
-        vtkWarningMacro(<< "Error loading point variable '"
-                        << this->Internals->pointVars[var]->name() << "'.");
+        char name[NC_MAX_NAME + 1];
+        if (!this->Internals->nc_err(nc_inq_varname(this->Internals->ncFile, this->Internals->pointVars[var], name)))
+        {
+          vtkWarningMacro(<< "Error loading point variable '" << name << "'.");
+        }
         continue;
       }
       output->GetCellData()->AddArray(array);
@@ -674,30 +1305,40 @@ void vtkMPASReader::SetDefaults() {
 
 int vtkMPASReader::GetNcDims()
 {
-  NcFile *pnf = this->Internals->ncFile;
+  int dimid;
 
-  CHECK_DIM(pnf, "nCells");
-  NcDim* nCells = pnf->get_dim("nCells");
-  this->NumberOfPoints = nCells->size();
+  CHECK_DIM("nCells", dimid);
+  if (this->Internals->nc_err(nc_inq_dimlen(this->Internals->ncFile, dimid, &this->NumberOfPoints)))
+  {
+    return 0;
+  }
   this->PointOffset = 1;
 
-  CHECK_DIM(pnf, "nVertices");
-  NcDim* nVertices = pnf->get_dim("nVertices");
-  this->NumberOfCells = nVertices->size();
+  CHECK_DIM("nVertices", dimid);
+  if (this->Internals->nc_err(nc_inq_dimlen(this->Internals->ncFile, dimid, &this->NumberOfCells)))
+  {
+    return 0;
+  }
   this->CellOffset = 0;
 
-  CHECK_DIM(pnf, "vertexDegree");
-  NcDim* vertexDegree = pnf->get_dim("vertexDegree");
-  this->PointsPerCell = vertexDegree->size();
+  CHECK_DIM("vertexDegree", dimid);
+  if (this->Internals->nc_err(nc_inq_dimlen(this->Internals->ncFile, dimid, &this->PointsPerCell)))
+  {
+    return 0;
+  }
 
-  CHECK_DIM(pnf, "Time");
-  NcDim* Time = pnf->get_dim("Time");
-  this->NumberOfTimeSteps = Time->size();
+  CHECK_DIM("Time", dimid);
+  if (this->Internals->nc_err(nc_inq_dimlen(this->Internals->ncFile, dimid, &this->NumberOfTimeSteps)))
+  {
+    return 0;
+  }
 
-  if (isNcDim(pnf, this->VerticalDimension.c_str()))
+  if ((dimid = this->Internals->nc_dim_id(this->VerticalDimension.c_str())) != -1)
   {
-    NcDim* nVertLevels = pnf->get_dim(this->VerticalDimension.c_str());
-    this->MaximumNVertLevels = nVertLevels->size();
+    if (this->Internals->nc_err(nc_inq_dimlen(this->Internals->ncFile, dimid, &this->MaximumNVertLevels)))
+    {
+      return 0;
+    }
   }
   else
   {
@@ -710,9 +1351,9 @@ int vtkMPASReader::GetNcDims()
 //----------------------------------------------------------------------------
 int vtkMPASReader::GetNcAtts()
 {
-  NcFile *pnf = this->Internals->ncFile;
-
-  if (!isNcAtt(pnf, "on_a_sphere"))
+  int attid = -1;
+  nc_inq_attid(this->Internals->ncFile, NC_GLOBAL, "on_a_sphere", &attid);
+  if (attid == -1)
   {
     vtkWarningMacro("Attribute 'on_a_sphere' missing in file " << this->FileName
                     << ". Assuming \"YES\".");
@@ -720,11 +1361,20 @@ int vtkMPASReader::GetNcAtts()
   }
   else
   {
-    NcAtt *onASphere = pnf->get_att("on_a_sphere");
-    char *onASphereString = onASphere->as_string(0);
-    this->OnASphere = (strcmp(onASphereString, "YES") == 0);
-    delete [] onASphereString;
-    onASphereString = nullptr;
+    size_t attlen;
+    if (this->Internals->nc_err(nc_inq_attlen(this->Internals->ncFile, NC_GLOBAL, "on_a_sphere", &attlen)))
+    {
+      return 0;
+    }
+    char* val = new char[attlen + 1];
+    val[attlen] = '\0';
+    if (this->Internals->nc_err(nc_get_att_text(this->Internals->ncFile, NC_GLOBAL, "on_a_sphere", val)))
+    {
+      delete [] val;
+      return 0;
+    }
+    this->OnASphere = (strcmp(val, "YES") == 0);
+    delete [] val;
   }
 
   return 1;
@@ -745,7 +1395,7 @@ int vtkMPASReader::CheckParams()
   }
 
   this->VerticalLevelRange[0] = 0;
-  this->VerticalLevelRange[1] = this->MaximumNVertLevels-1;
+  this->VerticalLevelRange[1] = static_cast<int>(this->MaximumNVertLevels-1);
 
   if (this->OnASphere)
   {
@@ -781,31 +1431,58 @@ int vtkMPASReader::GetNcVars (const char* cellDimName, const char* pointDimName)
   this->Internals->cellArrays.clear();
   this->Internals->cellVars.clear();
 
-  NcFile* ncFile =  this->Internals->ncFile;
-
-  int numVars = ncFile->num_vars();
+  int numVars;
+  int vars[NC_MAX_VARS];
+  if (this->Internals->nc_err(nc_inq_varids(this->Internals->ncFile, &numVars, vars)))
+  {
+    return 0;
+  }
   for (int i = 0; i < numVars; i++)
   {
-    NcVar* var = ncFile->get_var(i);
-
     // Variables must have the following dimension specification:
     // [Time, ] (nCells | nVertices), [arbitraryDim1, [arbitraryDim2, [...]]]
 
     bool isPointData = false;
     bool isCellData = false;
-    int numDims = var->num_dims();
-    std::vector<std::string> dimNames;
-    for (int dim = 0; dim < std::min(numDims, 2); ++dim)
+    int numDims;
+    if (this->Internals->nc_err(nc_inq_varndims(this->Internals->ncFile, vars[i], &numDims)))
     {
-      dimNames.push_back(var->get_dim(dim)->name());
+      continue;
     }
 
     if (numDims < 1)
     {
-      vtkWarningMacro(<<"Variable '" << var->name()
+      char name[NC_MAX_NAME + 1];
+      if (this->Internals->nc_err(nc_inq_varname(this->Internals->ncFile, vars[i], name)))
+      {
+        continue;
+      }
+      vtkWarningMacro(<<"Variable '" << name
                       << "' has invalid number of dimensions: " << numDims);
       continue;
     }
+    int dims[NC_MAX_VAR_DIMS];
+    if (this->Internals->nc_err(nc_inq_vardimid(this->Internals->ncFile, vars[i], dims)))
+    {
+      continue;
+    }
+
+    std::vector<std::string> dimNames;
+    bool ok = true;
+    for (int dim = 0; dim < std::min(numDims, 2); ++dim)
+    {
+      char name[NC_MAX_NAME + 1];
+      if (this->Internals->nc_err(nc_inq_dimname(this->Internals->ncFile, dims[dim], name)))
+      {
+        ok = false;
+        break;
+      }
+      dimNames.push_back(name);
+    }
+    if (!ok)
+    {
+      continue;
+    }
 
     if (dimNames[0] == "Time" && dimNames.size() >= 2)
     {
@@ -830,11 +1507,11 @@ int vtkMPASReader::GetNcVars (const char* cellDimName, const char* pointDimName)
     // Add to cell or point var array
     if (isCellData)
     {
-      this->Internals->cellVars.push_back(var);
+      this->Internals->cellVars.push_back(vars[i]);
     }
     else if (isPointData)
     {
-      this->Internals->pointVars.push_back(var);
+      this->Internals->pointVars.push_back(vars[i]);
     }
   }
 
@@ -856,28 +1533,72 @@ int vtkMPASReader::BuildVarArrays()
 
   for (size_t v = 0; v < this->Internals->pointVars.size(); v++)
   {
-    NcVar *var = this->Internals->pointVars[v];
-    std::string name = this->UseDimensionedArrayNames ? dimensionedArrayName(var)
-                                                 : var->name();
+    int varid = this->Internals->pointVars[v];
+    std::string name;
+    if (this->UseDimensionedArrayNames)
+    {
+      name = this->Internals->dimensionedArrayName(varid);
+    }
+    else
+    {
+      char varname[NC_MAX_NAME + 1];
+      if (this->Internals->nc_err(nc_inq_varname(this->Internals->ncFile, varid, varname)))
+      {
+        continue;
+      }
+      name = varname;
+    }
     this->PointDataArraySelection->EnableArray(name.c_str());
     // Register the dimensions:
-    for (int d = 0; d < var->num_dims(); ++d)
+    int ndims;
+    if (this->Internals->nc_err(nc_inq_varndims(this->Internals->ncFile, varid, &ndims)))
+    {
+      continue;
+    }
+    int dims[NC_MAX_VAR_DIMS];
+    if (this->Internals->nc_err(nc_inq_vardimid(this->Internals->ncFile, varid, dims)))
+    {
+      continue;
+    }
+    for (int d = 0; d < ndims; ++d)
     {
-      this->InitializeDimension(var->get_dim(d));
+      this->Internals->InitializeDimension(dims[d]);
     }
     vtkDebugMacro(<<"Adding point var: " << name);
   }
 
   for (size_t v = 0; v < this->Internals->cellVars.size(); v++)
   {
-    NcVar *var = this->Internals->cellVars[v];
-    std::string name = this->UseDimensionedArrayNames ? dimensionedArrayName(var)
-                                                 : var->name();
+    int varid = this->Internals->cellVars[v];
+    std::string name;
+    if (this->UseDimensionedArrayNames)
+    {
+      name = this->Internals->dimensionedArrayName(varid);
+    }
+    else
+    {
+      char varname[NC_MAX_NAME + 1];
+      if (this->Internals->nc_err(nc_inq_varname(this->Internals->ncFile, varid, varname)))
+      {
+        continue;
+      }
+      name = varname;
+    }
     this->CellDataArraySelection->EnableArray(name.c_str());
     // Register the dimensions:
-    for (int d = 0; d < var->num_dims(); ++d)
+    int ndims;
+    if (this->Internals->nc_err(nc_inq_varndims(this->Internals->ncFile, varid, &ndims)))
+    {
+      continue;
+    }
+    int dims[NC_MAX_VAR_DIMS];
+    if (this->Internals->nc_err(nc_inq_vardimid(this->Internals->ncFile, varid, dims)))
+    {
+      continue;
+    }
+    for (int d = 0; d < ndims; ++d)
     {
-      this->InitializeDimension(var->get_dim(d));
+      this->Internals->InitializeDimension(dims[d]);
     }
     vtkDebugMacro(<<"Adding cell var: " << name);
   }
@@ -941,65 +1662,75 @@ int vtkMPASReader::ReadAndOutputGrid()
 
 int vtkMPASReader::AllocSphericalGeometry()
 {
-  NcFile* ncFile = this->Internals->ncFile;
-
-  CHECK_VAR(ncFile, "xCell");
+  int varid;
+  CHECK_VAR("xCell", varid);
   this->PointX = new double [this->NumberOfPoints+this->PointOffset];
-  NcVar*  xCellVar = ncFile->get_var("xCell");
-  if (!this->ValidateDimensions(xCellVar, false, 1, "nCells"))
+  if (!this->Internals->ValidateDimensions(varid, false, 1, "nCells"))
+  {
+    return 0;
+  }
+  size_t start_pt[] = {0};
+  size_t count_pt[] = {this->NumberOfPoints};
+  if (this->Internals->nc_err(nc_get_vara_double(this->Internals->ncFile, varid, start_pt, count_pt, this->PointX + this->PointOffset)))
   {
     return 0;
   }
-  xCellVar->get(this->PointX + this->PointOffset, this->NumberOfPoints);
   // point 0 is 0.0
   this->PointX[0] = 0.0;
 
-  CHECK_VAR(ncFile, "yCell");
-  this->PointY = new double[this->NumberOfPoints+this->PointOffset];
-  NcVar*  yCellVar = ncFile->get_var("yCell");
-  if (!this->ValidateDimensions(yCellVar, false, 1, "nCells"))
+  CHECK_VAR("yCell", varid);
+  this->PointY = new double[this->NumberOfPoints + this->PointOffset];
+  if (!this->Internals->ValidateDimensions(varid, false, 1, "nCells"))
+  {
+    return 0;
+  }
+  if (this->Internals->nc_err(nc_get_vara_double(this->Internals->ncFile, varid, start_pt, count_pt, this->PointY + this->PointOffset)))
   {
     return 0;
   }
-  yCellVar->get(this->PointY + this->PointOffset, this->NumberOfPoints);
   // point 0 is 0.0
   this->PointY[0] = 0.0;
 
-  CHECK_VAR(ncFile, "zCell");
+  CHECK_VAR("zCell", varid);
   this->PointZ = new double[this->NumberOfPoints+this->PointOffset];
-  NcVar*  zCellVar = ncFile->get_var("zCell");
-  if (!this->ValidateDimensions(zCellVar, false, 1, "nCells"))
+  if (!this->Internals->ValidateDimensions(varid, false, 1, "nCells"))
+  {
+    return 0;
+  }
+  if (this->Internals->nc_err(nc_get_vara_double(this->Internals->ncFile, varid, start_pt, count_pt, this->PointZ + this->PointOffset)))
   {
     return 0;
   }
-  zCellVar->get(this->PointZ + this->PointOffset, this->NumberOfPoints);
   // point 0 is 0.0
   this->PointZ[0] = 0.0;
 
-  CHECK_VAR(ncFile, "cellsOnVertex");
+  CHECK_VAR("cellsOnVertex", varid);
   this->OrigConnections = new int[this->NumberOfCells * this->PointsPerCell];
-  NcVar *connectionsVar = ncFile->get_var("cellsOnVertex");
   // TODO Spec says dims should be '3', 'nVertices', but my example files
   // use nVertices, vertexDegree...
-  if (!this->ValidateDimensions(connectionsVar, false, 2,
-                                "nVertices", "vertexDegree"))
+  if (!this->Internals->ValidateDimensions(varid, false, 2, "nVertices", "vertexDegree"))
+  {
+    return 0;
+  }
+  size_t start_conn[] = {0, 0};
+  size_t count_conn[] = {this->NumberOfCells, this->PointsPerCell};
+  if (this->Internals->nc_err(nc_get_vara_int(this->Internals->ncFile, varid, start_conn, count_conn, this->OrigConnections)))
   {
     return 0;
   }
-  connectionsVar->get(this->OrigConnections, this->NumberOfCells,
-                      this->PointsPerCell);
 
-  if (isNcVar(ncFile, "maxLevelCell"))
+  if ((varid = this->Internals->nc_var_id("maxLevelCell", false)) != -1)
   {
     this->IncludeTopography = true;
     this->MaximumLevelPoint = new int[this->NumberOfPoints + this->PointOffset];
-    NcVar *maxLevelPointVar = ncFile->get_var("maxLevelCell");
-    if (!this->ValidateDimensions(maxLevelPointVar, false, 1, "nCells"))
+    if (!this->Internals->ValidateDimensions(varid, false, 1, "nCells"))
+    {
+      return 0;
+    }
+    if (this->Internals->nc_err(nc_get_vara_int(this->Internals->ncFile, varid, start_pt, count_pt, this->MaximumLevelPoint + this->PointOffset)))
     {
       return 0;
     }
-    maxLevelPointVar->get(this->MaximumLevelPoint + this->PointOffset,
-                          this->NumberOfPoints);
   }
 
   this->CurrentExtraPoint = this->NumberOfPoints + this->PointOffset;
@@ -1007,17 +1738,17 @@ int vtkMPASReader::AllocSphericalGeometry()
 
   if (this->ShowMultilayerView)
   {
-    this->MaximumCells = this->CurrentExtraCell*this->MaximumNVertLevels;
+    this->MaximumCells = static_cast<int>(this->CurrentExtraCell*this->MaximumNVertLevels);
     vtkDebugMacro
       (<< "alloc sphere: multilayer: setting MaximumCells to " << this->MaximumCells);
-    this->MaximumPoints = this->CurrentExtraPoint*(this->MaximumNVertLevels+1);
+    this->MaximumPoints = static_cast<int>(this->CurrentExtraPoint*(this->MaximumNVertLevels+1));
     vtkDebugMacro
       (<< "alloc sphere: multilayer: setting MaximumPoints to " << this->MaximumPoints);
   }
   else
   {
-    this->MaximumCells = this->CurrentExtraCell;
-    this->MaximumPoints = this->CurrentExtraPoint;
+    this->MaximumCells = static_cast<int>(this->CurrentExtraCell);
+    this->MaximumPoints = static_cast<int>(this->CurrentExtraPoint);
     vtkDebugMacro
       (<< "alloc sphere: singlelayer: setting MaximumPoints to " << this->MaximumPoints);
   }
@@ -1032,45 +1763,53 @@ int vtkMPASReader::AllocSphericalGeometry()
 
 int vtkMPASReader::AllocProjectedGeometry()
 {
-  NcFile* ncFile = this->Internals->ncFile;
   const float BLOATFACTOR = .5;
   this->ModNumPoints = (int)floor(this->NumberOfPoints*(1.0 + BLOATFACTOR));
   this->ModNumCells = (int)floor(this->NumberOfCells*(1.0 + BLOATFACTOR))+1;
 
-  CHECK_VAR(ncFile, "lonCell");
+  int varid;
+  CHECK_VAR("lonCell", varid);
   this->PointX = new double[this->ModNumPoints];
-  NcVar*  xCellVar = ncFile->get_var("lonCell");
-  if (!this->ValidateDimensions(xCellVar, false, 1, "nCells"))
+  if (!this->Internals->ValidateDimensions(varid, false, 1, "nCells"))
+  {
+    return 0;
+  }
+  size_t start_pt[] = {0};
+  size_t count_pt[] = {this->NumberOfPoints};
+  if (this->Internals->nc_err(nc_get_vara_double(this->Internals->ncFile, varid, start_pt, count_pt, this->PointX + this->PointOffset)))
   {
     return 0;
   }
-  xCellVar->get(this->PointX + this->PointOffset, this->NumberOfPoints);
   // point 0 is 0.0
   this->PointX[0] = 0.0;
 
-  CHECK_VAR(ncFile, "latCell");
+  CHECK_VAR("latCell", varid);
   this->PointY = new double[this->ModNumPoints];
-  NcVar*  yCellVar = ncFile->get_var("latCell");
-  if (!this->ValidateDimensions(yCellVar, false, 1, "nCells"))
+  if (!this->Internals->ValidateDimensions(varid, false, 1, "nCells"))
+  {
+    return 0;
+  }
+  if (this->Internals->nc_err(nc_get_vara_double(this->Internals->ncFile, varid, start_pt, count_pt, this->PointY + this->PointOffset)))
   {
     return 0;
   }
-  yCellVar->get(this->PointY+this->PointOffset, this->NumberOfPoints);
   // point 0 is 0.0
   this->PointY[0] = 0.0;
 
-  CHECK_VAR(ncFile, "cellsOnVertex");
+  CHECK_VAR("cellsOnVertex", varid);
   this->OrigConnections = new int[this->NumberOfCells * this->PointsPerCell];
-  NcVar *connectionsVar = ncFile->get_var("cellsOnVertex");
   // TODO Spec says dims should be '3', 'nVertices', but my example files
   // use nVertices, vertexDegree...
-  if (!this->ValidateDimensions(connectionsVar, false, 2,
-                                "nVertices", "vertexDegree"))
+  if (!this->Internals->ValidateDimensions(varid, false, 2, "nVertices", "vertexDegree"))
+  {
+    return 0;
+  }
+  size_t start_conn[] = {0, 0};
+  size_t count_conn[] = {this->NumberOfCells, this->PointsPerCell};
+  if (this->Internals->nc_err(nc_get_vara_int(this->Internals->ncFile, varid, start_conn, count_conn, this->OrigConnections)))
   {
     return 0;
   }
-  connectionsVar->get(this->OrigConnections, this->NumberOfCells,
-                      this->PointsPerCell);
 
   // create my own list to include modified origConnections (due to
   // eliminating wraparound in the lat/lon projection) plus additional
@@ -1080,20 +1819,21 @@ int vtkMPASReader::AllocProjectedGeometry()
 
   // allocate an array to map the extra points and cells to the original
   // so that when obtaining data, we know where to get it
-  this->PointMap = new int[(size_t)floor(this->NumberOfPoints * BLOATFACTOR)];
-  this->CellMap = new int[(size_t)floor(this->NumberOfCells * BLOATFACTOR)];
+  this->PointMap = new size_t[(size_t)floor(this->NumberOfPoints * BLOATFACTOR)];
+  this->CellMap = new size_t[(size_t)floor(this->NumberOfCells * BLOATFACTOR)];
 
-  if (isNcVar(ncFile, "maxLevelCell"))
+  if ((varid = this->Internals->nc_var_id("maxLevelCell", false)) != -1)
   {
     this->IncludeTopography = true;
     this->MaximumLevelPoint = new int[this->NumberOfPoints + this->NumberOfPoints];
-    NcVar *maxLevelPointVar = ncFile->get_var("maxLevelCell");
-    if (!this->ValidateDimensions(maxLevelPointVar, false, 1, "nCells"))
+    if (!this->Internals->ValidateDimensions(varid, false, 1, "nCells"))
+    {
+      return 0;
+    }
+    if (this->Internals->nc_err(nc_get_vara_int(this->Internals->ncFile, varid, start_pt, count_pt, this->MaximumLevelPoint + this->PointOffset)))
     {
       return 0;
     }
-    maxLevelPointVar->get(this->MaximumLevelPoint + this->PointOffset,
-                          this->NumberOfPoints);
   }
 
   this->CurrentExtraPoint = this->NumberOfPoints + this->PointOffset;
@@ -1101,16 +1841,16 @@ int vtkMPASReader::AllocProjectedGeometry()
 
   if (ShowMultilayerView)
   {
-    this->MaximumCells = this->CurrentExtraCell*this->MaximumNVertLevels;
-    this->MaximumPoints = this->CurrentExtraPoint*(this->MaximumNVertLevels+1);
+    this->MaximumCells = static_cast<int>(this->CurrentExtraCell*this->MaximumNVertLevels);
+    this->MaximumPoints = static_cast<int>(this->CurrentExtraPoint*(this->MaximumNVertLevels+1));
     vtkDebugMacro
       (<< "alloc latlon: multilayer: setting this->MaximumPoints to " << this->MaximumPoints
        << endl);
   }
   else
   {
-    this->MaximumCells = this->CurrentExtraCell;
-    this->MaximumPoints = this->CurrentExtraPoint;
+    this->MaximumCells = static_cast<int>(this->CurrentExtraCell);
+    this->MaximumPoints = static_cast<int>(this->CurrentExtraPoint);
     vtkDebugMacro
       (<< "alloc latlon: singlelayer: setting this->MaximumPoints to " << this->MaximumPoints
        << endl);
@@ -1121,65 +1861,77 @@ int vtkMPASReader::AllocProjectedGeometry()
 
 int vtkMPASReader::AllocPlanarGeometry()
 {
-  NcFile* ncFile = this->Internals->ncFile;
-
-  CHECK_VAR(ncFile, "xCell");
+  int varid;
+  CHECK_VAR("xCell", varid);
   this->PointX = new double[this->NumberOfPoints];
-  NcVar*  xCellVar = ncFile->get_var("xCell");
-  if (!this->ValidateDimensions(xCellVar, false, 1, "nCells"))
+  if (!this->Internals->ValidateDimensions(varid, false, 1, "nCells"))
+  {
+    return 0;
+  }
+  size_t start_pt[] = {0};
+  size_t count_pt[] = {this->NumberOfPoints};
+  if (this->Internals->nc_err(nc_get_vara_double(this->Internals->ncFile, varid, start_pt, count_pt, this->PointX + this->PointOffset)))
   {
     return 0;
   }
-  xCellVar->get(this->PointX + this->PointOffset, this->NumberOfPoints);
   // point 0 is 0.0
   this->PointX[0] = 0.0;
 
-  CHECK_VAR(ncFile, "yCell");
+  CHECK_VAR("yCell", varid);
   this->PointY = new double[this->NumberOfPoints];
-  NcVar*  yCellVar = ncFile->get_var("yCell");
-  if (!this->ValidateDimensions(yCellVar, false, 1, "nCells"))
+  if (!this->Internals->ValidateDimensions(varid, false, 1, "nCells"))
+  {
+    return 0;
+  }
+  if (this->Internals->nc_err(nc_get_vara_double(this->Internals->ncFile, varid, start_pt, count_pt, this->PointY + this->PointOffset)))
   {
     return 0;
   }
-  yCellVar->get(this->PointY + this->PointOffset, this->NumberOfPoints);
   // point 0 is 0.0
   this->PointY[0] = 0.0;
 
-  CHECK_VAR(ncFile, "zCell");
+  CHECK_VAR("zCell", varid);
   this->PointZ = new double[this->NumberOfPoints];
-  NcVar *zCellVar = ncFile->get_var("zCell");
-  if (!this->ValidateDimensions(zCellVar, false, 1, "nCells"))
+  if (!this->Internals->ValidateDimensions(varid, false, 1, "nCells"))
+  {
+    return 0;
+  }
+  if (this->Internals->nc_err(nc_get_vara_double(this->Internals->ncFile, varid, start_pt, count_pt, this->PointZ + this->PointOffset)))
   {
     return 0;
   }
-  zCellVar->get(this->PointZ + this->PointOffset, this->NumberOfPoints);
   // point 0 is 0.0
   this->PointZ[0] = 0.0;
 
-  CHECK_VAR(ncFile, "cellsOnVertex");
+  CHECK_VAR("cellsOnVertex", varid);
   this->OrigConnections = new int[this->NumberOfCells * this->PointsPerCell];
-  NcVar *connectionsVar = ncFile->get_var("cellsOnVertex");
   // TODO Spec says dims should be '3', 'nVertices', but my example files
   // use nVertices, vertexDegree...
-  if (!this->ValidateDimensions(connectionsVar, false, 2,
-                                "nVertices", "vertexDegree"))
+  if (!this->Internals->ValidateDimensions(varid, false, 2, "nVertices", "vertexDegree"))
+  {
+    return 0;
+  }
+  size_t start_conn[] = {0, 0};
+  size_t count_conn[] = {this->NumberOfCells, this->PointsPerCell};
+  if (this->Internals->nc_err(nc_get_vara_int(this->Internals->ncFile, varid, start_conn, count_conn, this->OrigConnections)))
   {
     return 0;
   }
-  connectionsVar->get(this->OrigConnections, this->NumberOfCells,
-                      this->PointsPerCell);
 
-  if (isNcVar(ncFile, "maxLevelCell"))
+  if ((varid = this->Internals->nc_var_id("maxLevelCell", false)) != -1)
   {
     this->IncludeTopography = true;
     this->MaximumLevelPoint = new int[2 * this->NumberOfPoints];
-    NcVar *maxLevelPointVar = ncFile->get_var("maxLevelCell");
-    if (!this->ValidateDimensions(maxLevelPointVar, false, 1, "nCells"))
+    if (!this->Internals->ValidateDimensions(varid, false, 1, "nCells"))
+    {
+      return 0;
+    }
+    size_t start[] = {0};
+    size_t count[] = {this->NumberOfPoints};
+    if (this->Internals->nc_err(nc_get_vara_int(this->Internals->ncFile, varid, start, count, this->MaximumLevelPoint + this->PointOffset)))
     {
       return 0;
     }
-    maxLevelPointVar->get(this->MaximumLevelPoint + this->PointOffset,
-                          this->NumberOfPoints);
   }
 
   this->CurrentExtraPoint = this->NumberOfPoints + this->PointOffset;
@@ -1187,14 +1939,14 @@ int vtkMPASReader::AllocPlanarGeometry()
 
   if (this->ShowMultilayerView)
   {
-    this->MaximumCells = this->CurrentExtraCell * this->MaximumNVertLevels;
-    this->MaximumPoints = this->CurrentExtraPoint *
-        (this->MaximumNVertLevels + 1);
+    this->MaximumCells = static_cast<int>(this->CurrentExtraCell * this->MaximumNVertLevels);
+    this->MaximumPoints = static_cast<int>(this->CurrentExtraPoint *
+        (this->MaximumNVertLevels + 1));
   }
   else
   {
-    this->MaximumCells = this->CurrentExtraCell;
-    this->MaximumPoints = this->CurrentExtraPoint;
+    this->MaximumCells = static_cast<int>(this->CurrentExtraCell);
+    this->MaximumPoints = static_cast<int>(this->CurrentExtraPoint);
   }
 
   return 1;
@@ -1210,7 +1962,7 @@ void vtkMPASReader::ShiftLonData()
   // if atmospheric data, or zero centered, set center to 180 instead of 0
   if (IsAtmosphere || IsZeroCentered)
   {
-    for (int j = this->PointOffset; j < this->NumberOfPoints + this->PointOffset; j++)
+    for (size_t j = this->PointOffset; j < this->NumberOfPoints + this->PointOffset; j++)
     {
       // need to shift over the point so center is at PI
       if (this->PointX[j] < 0)
@@ -1222,7 +1974,7 @@ void vtkMPASReader::ShiftLonData()
 
   if (CenterLon != 180)
   {
-    for (int j = this->PointOffset; j < this->NumberOfPoints + this->PointOffset; j++)
+    for (size_t j = this->PointOffset; j < this->NumberOfPoints + this->PointOffset; j++)
     {
       // need to shift over the point if centerLon dictates
       if (this->CenterRad < vtkMath::Pi())
@@ -1270,13 +2022,13 @@ int vtkMPASReader::AddMirrorPoint(int index, double dividerX, double offset)
   this->PointX[this->CurrentExtraPoint] = X;
   this->PointY[this->CurrentExtraPoint] = Y;
 
-  int mirrorPoint = this->CurrentExtraPoint;
+  size_t mirrorPoint = this->CurrentExtraPoint;
 
   // record mapping
   *(this->PointMap + (this->CurrentExtraPoint - this->NumberOfPoints - this->PointOffset)) = index;
   this->CurrentExtraPoint++;
 
-  return mirrorPoint;
+  return static_cast<int>(mirrorPoint);
 }
 
 
@@ -1288,18 +2040,18 @@ void vtkMPASReader::FixPoints()
 {
   vtkDebugMacro(<< "In FixPoints..." << endl);
 
-  for (int j = this->CellOffset; j < this->NumberOfCells + this->CellOffset; j++ )
+  for (size_t j = this->CellOffset; j < this->NumberOfCells + this->CellOffset; j++ )
   {
     int *conns = this->OrigConnections + (j * this->PointsPerCell);
 
     // go through and make sure none of the referenced points are
     // out of range
     // if so, set all to point 0
-    for (int k = 0; k < this->PointsPerCell; k++)
+    for (size_t k = 0; k < this->PointsPerCell; k++)
     {
-      if  ((conns[k] <= 0) || (conns[k] > this->NumberOfPoints))
+      if  ((conns[k] <= 0) || (static_cast<size_t>(conns[k]) > this->NumberOfPoints))
       {
-        for (int m = 0; m < this->PointsPerCell; m++)
+        for (size_t m = 0; m < this->PointsPerCell; m++)
         {
           conns[m] = 0;
         }
@@ -1310,16 +2062,16 @@ void vtkMPASReader::FixPoints()
     if (this->DoBugFix)
     {
       //BUG FIX for problem where cells are stretching to a faraway point
-      int lastk = this->PointsPerCell-1;
+      size_t lastk = this->PointsPerCell-1;
       const double thresh = .06981317007977; // 4 degrees
-      for (int k = 0; k < this->PointsPerCell; k++)
+      for (size_t k = 0; k < this->PointsPerCell; k++)
       {
         double ydiff = std::abs(this->PointY[conns[k]]
                                 - this->PointY[conns[lastk]]);
         // Don't look at cells at map border
         if (ydiff > thresh)
         {
-          for (int m = 0; m < this->PointsPerCell; m++)
+          for (size_t m = 0; m < this->PointsPerCell; m++)
           {
             conns[m] = 0;
           }
@@ -1361,7 +2113,7 @@ int vtkMPASReader::EliminateXWrap()
       // Determine the bounds in the x-dimension
       double xRange[2] = { this->PointX[this->PointOffset],
                            this->PointX[this->PointOffset] };
-      for (int i = 1; i < this->NumberOfPoints; ++i)
+      for (size_t i = 1; i < this->NumberOfPoints; ++i)
       {
         double x = this->PointX[this->PointOffset + i];
         xRange[0] = std::min(xRange[0], x);
@@ -1382,15 +2134,15 @@ int vtkMPASReader::EliminateXWrap()
 
   // For each cell, examine vertices
   // Add new points and cells where needed to account for wraparound.
-  for (int j = this->CellOffset; j < this->NumberOfCells + this->CellOffset; j++ )
+  for (size_t j = this->CellOffset; j < this->NumberOfCells + this->CellOffset; j++ )
   {
     int *conns = this->OrigConnections + (j * this->PointsPerCell);
     int *modConns = this->ModConnections + (j * this->PointsPerCell);
 
     // Determine if we are wrapping in X direction
-    int lastk = this->PointsPerCell-1;
+    size_t lastk = this->PointsPerCell-1;
     bool xWrap = false;
-    for (int k = 0; k < this->PointsPerCell; k++)
+    for (size_t k = 0; k < this->PointsPerCell; k++)
     {
       if (std::abs(this->PointX[conns[k]] - this->PointX[conns[lastk]]) > tolerance)
       {
@@ -1409,7 +2161,7 @@ int vtkMPASReader::EliminateXWrap()
 
       // modify existing cell, so it doesn't wrap
       // move points to one side
-      for (int k = 1; k < this->PointsPerCell; k++)
+      for (size_t k = 1; k < this->PointsPerCell; k++)
       {
         int neigh = conns[k];
 
@@ -1436,7 +2188,7 @@ int vtkMPASReader::EliminateXWrap()
       anchorX = this->PointX[addedConns[0]];
 
       // add mirror cell points if needed
-      for (int k = 1; k < this->PointsPerCell; k++)
+      for (size_t k = 1; k < this->PointsPerCell; k++)
       {
         int neigh = conns[k];
 
@@ -1458,7 +2210,7 @@ int vtkMPASReader::EliminateXWrap()
     {
 
       // just add cell "as is" to this->ModConnections
-      for (int k=0; k< this->PointsPerCell; k++)
+      for (size_t k=0; k< this->PointsPerCell; k++)
       {
         modConns[k] = conns[k];
       }
@@ -1477,16 +2229,16 @@ int vtkMPASReader::EliminateXWrap()
 
   if (!ShowMultilayerView)
   {
-    this->MaximumCells = this->CurrentExtraCell;
-    this->MaximumPoints = this->CurrentExtraPoint;
+    this->MaximumCells = static_cast<int>(this->CurrentExtraCell);
+    this->MaximumPoints = static_cast<int>(this->CurrentExtraPoint);
     vtkDebugMacro
       (<< "elim xwrap: singlelayer: setting this->MaximumPoints to " << this->MaximumPoints
        << endl);
   }
   else
   {
-    this->MaximumCells = this->CurrentExtraCell*this->MaximumNVertLevels;
-    this->MaximumPoints = this->CurrentExtraPoint*(this->MaximumNVertLevels+1);
+    this->MaximumCells = static_cast<int>(this->CurrentExtraCell*this->MaximumNVertLevels);
+    this->MaximumPoints = static_cast<int>(this->CurrentExtraPoint*(this->MaximumNVertLevels+1));
     vtkDebugMacro
       (<< "elim xwrap: multilayer: setting this->MaximumPoints to " <<
        this->MaximumPoints << endl);
@@ -1512,7 +2264,7 @@ void vtkMPASReader::OutputPoints()
   points->Allocate(this->MaximumPoints);
   output->SetPoints(points);
 
-  for (int j = 0; j < this->CurrentExtraPoint; j++ )
+  for (size_t j = 0; j < this->CurrentExtraPoint; j++ )
   {
     double x, y, z;
 
@@ -1557,7 +2309,7 @@ void vtkMPASReader::OutputPoints()
         }
       }
 
-      for (int levelNum = 0; levelNum < this->MaximumNVertLevels+1; levelNum++)
+      for (size_t levelNum = 0; levelNum < this->MaximumNVertLevels+1; levelNum++)
       {
         if (this->Geometry == Spherical)
         {
@@ -1573,7 +2325,7 @@ void vtkMPASReader::OutputPoints()
         }
         else
         {
-          z = -levelNum * adjustedLayerThickness;
+          z = levelNum * -adjustedLayerThickness;
         }
         points->InsertNextPoint(x, y, z);
       }
@@ -1626,121 +2378,11 @@ unsigned char vtkMPASReader::GetCellType()
       {
         cellType = VTK_HEXAHEDRON;
       }
-      break;
-    default:
-      break;
-  }
-  return cellType;
-}
-
-//------------------------------------------------------------------------------
-bool vtkMPASReader::ValidateDimensions(NcVar *var, bool silent, int ndims, ...)
-{
-  if (var->num_dims() != ndims)
-  {
-    if (!silent)
-    {
-      vtkWarningMacro(<< "Expected variable '" << var->name() << "' to have "
-                      << ndims << "dimension(s), but it has " << var->num_dims()
-                      << ".");
-    }
-    return false;
-  }
-
-  va_list args;
-  va_start(args, ndims);
-
-  for (int i = 0; i < ndims; ++i)
-  {
-    NcDim *dim = var->get_dim(i);
-    std::string dimName(va_arg(args, const char *));
-    if (dimName != dim->name())
-    {
-      if (!silent)
-      {
-        vtkWarningMacro(<< "Expected variable '" << var->name() << "' to have '"
-                        << dimName << "' at dimension index " << i << ", not '"
-                        << dim->name() << "'.");
-      }
-      va_end(args);
-      return false;
-    }
-  }
-
-  va_end(args);
-
-  return true;
-}
-
-//------------------------------------------------------------------------------
-long vtkMPASReader::GetCursorForDimension(const NcDim *dim)
-{
-  std::string dimName = dim->name();
-  if (dimName == "nCells" || dimName == "nVertices")
-  {
-    return 0;
-  }
-  else if (dimName == "Time")
-  {
-    return std::min(static_cast<long>(std::floor(this->DTime)),
-                    static_cast<long>(this->NumberOfTimeSteps-1));
-  }
-  else if (this->ShowMultilayerView &&
-           dimName == this->VerticalDimension)
-  {
-    return 0;
-  }
-  else
-  {
-    return this->InitializeDimension(dim);
-  }
-}
-
-//------------------------------------------------------------------------------
-size_t vtkMPASReader::GetCountForDimension(const NcDim *dim)
-{
-  std::string dimName = dim->name();
-  if (dimName == "nCells")
-  {
-    return this->NumberOfPoints;
-  }
-  else if (dimName == "nVertices")
-  {
-    return this->NumberOfCells;
-  }
-  else if (this->ShowMultilayerView && dimName == this->VerticalDimension)
-  {
-    return this->MaximumNVertLevels;
-  }
-  else
-  {
-    return 1;
-  }
-}
-
-//------------------------------------------------------------------------------
-long vtkMPASReader::InitializeDimension(const NcDim *dim)
-{
-  Internal::DimMetaDataMap::const_iterator match =
-      this->Internals->dimMetaDataMap.find(dim->name());
-
-  long result = 0;
-  if (match == this->Internals->dimMetaDataMap.end())
-  {
-    DimMetaData metaData;
-    metaData.curIdx = result;
-    metaData.dimSize = dim->size();
-
-    this->Internals->dimMetaDataMap.insert(
-          std::make_pair(std::string(dim->name()), metaData));
-    this->Internals->dimMetaDataTime.Modified();
-  }
-  else
-  {
-    result = match->second.curIdx;
+      break;
+    default:
+      break;
   }
-
-  return result;
+  return cellType;
 }
 
 //----------------------------------------------------------------------------
@@ -1755,9 +2397,9 @@ void vtkMPASReader::OutputCells()
   output->Allocate(this->MaximumCells, this->MaximumCells);
 
   int cellType = GetCellType();
-  int val;
+  size_t val;
 
-  int pointsPerPolygon;
+  size_t pointsPerPolygon;
   if (this->ShowMultilayerView)
   {
     pointsPerPolygon = 2 * this->PointsPerCell;
@@ -1775,7 +2417,7 @@ void vtkMPASReader::OutputCells()
 
   std::vector<vtkIdType> polygon(pointsPerPolygon);
 
-  for (int j = 0; j < this->CurrentExtraCell ; j++)
+  for (size_t j = 0; j < this->CurrentExtraCell ; j++)
   {
 
     int* conns;
@@ -1795,9 +2437,9 @@ void vtkMPASReader::OutputCells()
       int* connections;
 
       //check if it is a mirror cell, if so, get original
-      if (j >= this->NumberOfCells + this->CellOffset)
+      if (static_cast<size_t>(j) >= this->NumberOfCells + this->CellOffset)
       {
-        int origCellNum = *(this->CellMap + (j - this->NumberOfCells - this->CellOffset));
+        size_t origCellNum = *(this->CellMap + (j - this->NumberOfCells - this->CellOffset));
         connections = this->OrigConnections + (origCellNum*this->PointsPerCell);
       }
       else
@@ -1808,7 +2450,7 @@ void vtkMPASReader::OutputCells()
       minLevel = this->MaximumLevelPoint[connections[0]];
 
       // Take the min of the this->MaximumLevelPoint of each point
-      for (int k = 1; k < this->PointsPerCell; k++)
+      for (size_t k = 1; k < this->PointsPerCell; k++)
       {
         minLevel = std::min(minLevel, this->MaximumLevelPoint[connections[k]]);
       }
@@ -1824,52 +2466,52 @@ void vtkMPASReader::OutputCells()
       {
         //cerr << "Setting all points to zero" << endl;
         val = 0;
-        for (int k = 0; k < this->PointsPerCell; k++)
+        for (size_t k = 0; k < this->PointsPerCell; k++)
         {
-          polygon[k] = val;
+          polygon[k] = static_cast<vtkIdType>(val);
         }
       }
       else
       {
-        for (int k = 0; k < this->PointsPerCell; k++)
+        for (size_t k = 0; k < this->PointsPerCell; k++)
         {
           polygon[k] = conns[k];
         }
       }
-      output->InsertNextCell(cellType, pointsPerPolygon, &polygon[0]);
+      output->InsertNextCell(cellType, static_cast<vtkIdType>(pointsPerPolygon), &polygon[0]);
 
     }
     else
     { // multilayer
       // for each level, write the cell
-      for (int levelNum = 0; levelNum < this->MaximumNVertLevels; levelNum++)
+      for (size_t levelNum = 0; levelNum < this->MaximumNVertLevels; levelNum++)
       {
-        if (this->IncludeTopography && ((minLevel-1) < levelNum))
+        if (this->IncludeTopography && (static_cast<size_t>(minLevel-1) < levelNum))
         {
           // setting all points to zero
           val = 0;
-          for (int k = 0; k < pointsPerPolygon; k++)
+          for (size_t k = 0; k < pointsPerPolygon; k++)
           {
-            polygon[k] = val;
+            polygon[k] = static_cast<vtkIdType>(val);
           }
         }
         else
         {
-          for (int k = 0; k < this->PointsPerCell; k++)
+          for (size_t k = 0; k < this->PointsPerCell; k++)
           {
             val = (conns[k]*(this->MaximumNVertLevels+1)) + levelNum;
-            polygon[k] = val;
+            polygon[k] = static_cast<vtkIdType>(val);
           }
 
-          for (int k = 0; k < this->PointsPerCell; k++)
+          for (size_t k = 0; k < this->PointsPerCell; k++)
           {
             val = (conns[k]*(this->MaximumNVertLevels+1)) + levelNum + 1;
-            polygon[k+this->PointsPerCell] = val;
+            polygon[k+this->PointsPerCell] = static_cast<vtkIdType>(val);
           }
         }
         //vtkDebugMacro
         //("InsertingCell j: " << j << " level: " << levelNum << endl);
-        output->InsertNextCell(cellType, pointsPerPolygon, &polygon[0]);
+        output->InsertNextCell(cellType, static_cast<vtkIdType>(pointsPerPolygon), &polygon[0]);
       }
     }
   }
@@ -1882,299 +2524,28 @@ void vtkMPASReader::OutputCells()
   vtkDebugMacro(<< "Leaving OutputCells..." << endl);
 }
 
-//------------------------------------------------------------------------------
-vtkDataArray *vtkMPASReader::CreateDataArray(int typeNc)
-{
-  int typeVtk = this->NcTypeToVtkType(static_cast<NcType>(typeNc));
-  return vtkDataArray::CreateDataArray(typeVtk);
-}
-
-//------------------------------------------------------------------------------
-vtkIdType vtkMPASReader::ComputeNumberOfTuples(NcVar *ncVar)
-{
-  int numDims = ncVar->num_dims();
-  vtkIdType size = 0;
-  for (int dim = 0; dim < numDims; ++dim)
-  {
-    vtkIdType count = static_cast<vtkIdType>(
-          this->GetCountForDimension(ncVar->get_dim(dim)));
-    if (size == 0)
-    {
-      size = count;
-    }
-    else
-    {
-      size *= count;
-    }
-  }
-  return size;
-}
-
-//------------------------------------------------------------------------------
-template <typename ValueType>
-bool vtkMPASReader::LoadDataArray(NcVar *ncVar, vtkDataArray *array,
-                                  bool resize)
-{
-  if (array->GetDataType() != this->NcTypeToVtkType(ncVar->type()))
-  {
-    vtkWarningMacro("Invalid array type.");
-    return false;
-  }
-
-  int numDims = ncVar->num_dims();
-  std::vector<long> cursor;
-  std::vector<nc_size_t> counts;
-  vtkIdType size = 0;
-
-  for (int dim = 0; dim < numDims; ++dim)
-  {
-    cursor.push_back(this->GetCursorForDimension(ncVar->get_dim(dim)));
-    counts.push_back(static_cast<nc_size_t>(
-                       this->GetCountForDimension(ncVar->get_dim(dim))));
-    if (size == 0)
-    {
-      size = counts.back();
-    }
-    else
-    {
-      size *= counts.back();
-    }
-  }
-
-  if (resize)
-  {
-    array->SetNumberOfComponents(1);
-    array->SetNumberOfTuples(size);
-  }
-  else
-  {
-    if (array->GetNumberOfComponents() != 1)
-    {
-      vtkWarningMacro("Invalid number of components: "
-                      << array->GetNumberOfComponents() << ".");
-      return false;
-    }
-    else if (array->GetNumberOfTuples() < size)
-    {
-      vtkWarningMacro("Array only has " << array->GetNumberOfTuples()
-                      << " allocated, but we need " << size << ".");
-      return false;
-    }
-  }
-
-  ValueType *dataBlock = static_cast<ValueType*>(array->GetVoidPointer(0));
-  if (!dataBlock)
-  {
-    vtkWarningMacro("GetVoidPointer returned nullptr.");
-    return false;
-  }
-
-  if (!ncVar->set_cur(&cursor[0]))
-  {
-    vtkWarningMacro("Setting cursor failed.");
-    return false;
-  }
-
-  if (!ncVar->get(dataBlock, &counts[0]))
-  {
-    vtkWarningMacro("Reading " << size << " elements failed.");
-    return false;
-  }
-
-  return true;
-}
-
-//------------------------------------------------------------------------------
-template <typename ValueType>
-int vtkMPASReader::LoadPointVarDataImpl(NcVar *ncVar, vtkDataArray *array)
-{
-  // Don't resize, we've preallocated extra room for multilayer (if needed):
-  if (!this->LoadDataArray<ValueType>(ncVar, array, /*resize=*/false))
-  {
-    return 0;
-  }
-
-  // Check if this variable contains the vertical dimension:
-  bool hasVerticalDimension = false;
-  int numDims = ncVar->num_dims();
-  if (this->ShowMultilayerView)
-  {
-    for (int d = 0; d < numDims; ++d)
-    {
-      if (this->VerticalDimension == ncVar->get_dim(d)->name())
-      {
-        hasVerticalDimension = true;
-        break;
-      }
-    }
-  }
-
-  vtkIdType varSize = this->ComputeNumberOfTuples(ncVar);
-  ValueType *dataBlock = static_cast<ValueType*>(array->GetVoidPointer(0));
-  std::vector<ValueType> tempData; // Used for Multilayer
-
-  // singlelayer
-  if (!this->ShowMultilayerView)
-  {
-    // Account for point offset:
-    if (this->PointOffset != 0)
-    {
-      assert(this->NumberOfPoints <= array->GetNumberOfTuples() &&
-             "Source array too small.");
-      assert(this->PointOffset + this->NumberOfPoints <=
-             array->GetNumberOfTuples() && "Destination array too small.");
-      if (this->PointOffset < this->NumberOfPoints)
-      {
-        std::copy_backward(dataBlock, dataBlock + this->NumberOfPoints,
-                           dataBlock + this->PointOffset +
-                           this->NumberOfPoints);
-      }
-      else
-      {
-        std::copy(dataBlock, dataBlock + this->NumberOfPoints,
-                  dataBlock + this->PointOffset);
-      }
-    }
-    dataBlock[0] = dataBlock[1];
-    // data is all in place, don't need to do next step
-  }
-  else
-  { // multilayer
-    if (this->MaximumPoints == 0)
-    {
-      return 0; // No points
-    }
-
-    tempData.resize(this->MaximumPoints);
-    size_t vertPointOffset = this->MaximumNVertLevels * this->PointOffset;
-    ValueType *dataPtr = &tempData[0] + vertPointOffset;
-
-    assert(varSize < array->GetNumberOfTuples());
-    assert(varSize < static_cast<vtkIdType>(this->MaximumPoints -
-                                            vertPointOffset));
-    std::copy(dataBlock, dataBlock + varSize, dataPtr);
-
-    if (!hasVerticalDimension)
-    {
-      // need to replicate data over all vertical layers
-      // layout in memory needs to be:
-      // pt1, pt1, ..., (VertLevels times), pt2, pt2, ..., (VertLevels times),
-      // need to go backwards through the points in order to not overwrite
-      // anything.
-      for(int i = this->NumberOfPoints; i > 0; i--)
-      {
-        // point to copy
-        ValueType pt = *(dataPtr + i - 1);
-
-        // where to start copying
-        ValueType *copyPtr = dataPtr + (i-1)*this->MaximumNVertLevels;
-
-        std::fill(copyPtr, copyPtr + this->MaximumNVertLevels, pt);
-      }
-    }
-  }
-
-  vtkDebugMacro(<<"Got point data.");
-
-  int i = 0;
-  int k = 0;
-
-  if (this->ShowMultilayerView)
-  {
-    // put in dummy points
-    assert(this->MaximumNVertLevels * 2 <= this->MaximumPoints);
-    assert(this->MaximumNVertLevels <= array->GetNumberOfTuples());
-    std::copy(tempData.begin() + this->MaximumNVertLevels,
-              tempData.begin() + (2*this->MaximumNVertLevels),
-              dataBlock);
-
-    // write highest level dummy point (duplicate of last level)
-    assert(this->MaximumNVertLevels < array->GetNumberOfTuples());
-    assert(2*this->MaximumNVertLevels - 1 < this->MaximumPoints);
-    dataBlock[this->MaximumNVertLevels] =
-        tempData[2*this->MaximumNVertLevels - 1];
-
-    vtkDebugMacro(<<"Wrote dummy point data.");
-
-    // put in other points
-    for (int j = this->PointOffset;
-         j < this->NumberOfPoints + this->PointOffset;
-         j++)
-    {
-
-      i = j*(this->MaximumNVertLevels+1);
-      k = j*(this->MaximumNVertLevels);
-
-      // write data for one point -- lowest level to highest
-      assert(k + this->MaximumNVertLevels <= this->MaximumPoints);
-      assert(i + this->MaximumNVertLevels <= array->GetNumberOfTuples());
-      std::copy(tempData.begin() + k,
-                tempData.begin() + k + this->MaximumNVertLevels,
-                dataBlock + i);
-
-      // for last layer of points, repeat last level's values
-      // Need Mark's input on this one
-      dataBlock[i++] = tempData[--k];
-      //vtkDebugMacro (<< "Wrote j:" << j << endl);
-    }
-  }
-
-  vtkDebugMacro(<<"Wrote next points.");
-
-  vtkDebugMacro(<<"this->NumberOfPoints: " << this->NumberOfPoints << " "
-                <<"this->CurrentExtraPoint: " << this->CurrentExtraPoint);
-
-  // put out data for extra points
-  for (int j = this->PointOffset + this->NumberOfPoints;
-       j < this->CurrentExtraPoint;
-       j++)
-  {
-    // use map to find out what point data we are using
-    if (!this->ShowMultilayerView)
-    {
-      k = this->PointMap[j - this->NumberOfPoints - this->PointOffset];
-      assert(j < array->GetNumberOfTuples());
-      assert(k < array->GetNumberOfTuples());
-      dataBlock[j] = dataBlock[k];
-    }
-    else
-    {
-      k = this->PointMap[j - this->NumberOfPoints - this->PointOffset] *
-          this->MaximumNVertLevels;
-      // write data for one point -- lowest level to highest
-      assert(k + this->MaximumNVertLevels <= this->MaximumPoints);
-      assert(i + this->MaximumNVertLevels <= array->GetNumberOfTuples());
-      std::copy(tempData.begin() + k,
-                tempData.begin() + k + this->MaximumNVertLevels,
-                dataBlock + i);
-
-      // for last layer of points, repeat last level's values
-      // Need Mark's input on this one
-      dataBlock[i++] = tempData[--k];
-    }
-  }
-
-  vtkDebugMacro(<<"wrote extra point data.");
-  return 1;
-}
-
 //----------------------------------------------------------------------------
 //  Load the data for a point variable
 //----------------------------------------------------------------------------
 vtkDataArray *vtkMPASReader::LoadPointVarData(int variableIndex)
 {
-  NcVar* ncVar = this->Internals->pointVars[variableIndex];
-  if (ncVar == nullptr)
+  int varid = this->Internals->pointVars[variableIndex];
+  char varname[NC_MAX_NAME + 1];
+  if (this->Internals->nc_err(nc_inq_varname(this->Internals->ncFile, varid, varname)))
   {
     vtkErrorMacro(<<"No NetCDF data for pointVar @ index " << variableIndex);
     return nullptr;
   }
 
-  vtkDebugMacro(<<"Loading point data array named: " << ncVar->name());
+  vtkDebugMacro(<<"Loading point data array named: " << varname);
 
   // Get data type:
-  NcType typeNc = ncVar->type();
-  int typeVtk = this->NcTypeToVtkType(typeNc);
+  nc_type typeNc;
+  if (this->Internals->nc_err(nc_inq_vartype(this->Internals->ncFile, varid, &typeNc)))
+  {
+    return nullptr;
+  }
+  int typeVtk = NcTypeToVtkType(typeNc);
 
   // Allocate data array pointer for this variable:
   vtkSmartPointer<vtkDataArray> array =
@@ -2185,13 +2556,13 @@ vtkDataArray *vtkMPASReader::LoadPointVarData(int variableIndex)
     array = vtkSmartPointer<vtkDataArray>::Take(
           vtkDataArray::CreateDataArray(typeVtk));
   }
-  array->SetName(ncVar->name());
+  array->SetName(varname);
   array->SetNumberOfComponents(1);
   array->SetNumberOfTuples(this->MaximumPoints);
 
   int success = false;
   vtkNcDispatch(typeVtk,
-                success = this->LoadPointVarDataImpl<VTK_TT>(ncVar, array););
+                success = this->Internals->LoadPointVarDataImpl<VTK_TT>(varid, array););
 
   if (success)
   {
@@ -2201,68 +2572,29 @@ vtkDataArray *vtkMPASReader::LoadPointVarData(int variableIndex)
   return nullptr;
 }
 
-//------------------------------------------------------------------------------
-template <typename ValueType>
-int vtkMPASReader::LoadCellVarDataImpl(NcVar *ncVar, vtkDataArray *array)
-{
-  // Don't resize, we've preallocated extra room for multilayer (if needed):
-  if (!this->LoadDataArray<ValueType>(ncVar, array, /*resize=*/false))
-  {
-    return 0;
-  }
-
-  ValueType *dataBlock = static_cast<ValueType*>(array->GetVoidPointer(0));
-
-  // put out data for extra cells
-  for (int j = this->CellOffset + this->NumberOfCells;
-       j < this->CurrentExtraCell;
-       j++)
-  {
-    // use map to find out what cell data we are using
-    if (!this->ShowMultilayerView)
-    {
-      int k = this->CellMap[j - this->NumberOfCells - this->CellOffset];
-      assert(j < array->GetNumberOfTuples());
-      assert(k < array->GetNumberOfTuples());
-      dataBlock[j] = dataBlock[k];
-    }
-    else
-    {
-      int i = j*this->MaximumNVertLevels;
-      int k = this->CellMap[j - this->NumberOfCells - this->CellOffset] *
-              this->MaximumNVertLevels;
-
-      // write data for one cell -- lowest level to highest
-      assert(i < array->GetNumberOfTuples());
-      assert(k + this->MaximumNVertLevels <= array->GetNumberOfTuples());
-      std::copy(dataBlock + k, dataBlock + k + this->MaximumNVertLevels,
-                dataBlock + i);
-    }
-  }
-
-  vtkDebugMacro(<<"Stored data.");
-
-  return 1;
-}
-
 //----------------------------------------------------------------------------
 //  Load the data for a cell variable
 //----------------------------------------------------------------------------
 
 vtkDataArray* vtkMPASReader::LoadCellVarData(int variableIndex)
 {
-  NcVar* ncVar = this->Internals->cellVars[variableIndex];
-  if (ncVar == nullptr)
+  int varid = this->Internals->cellVars[variableIndex];
+  char varname[NC_MAX_NAME + 1];
+  if (this->Internals->nc_err(nc_inq_varname(this->Internals->ncFile, varid, varname)))
   {
     vtkErrorMacro(<<"No NetCDF data for cellVar @ index " << variableIndex);
     return nullptr;
   }
 
-  vtkDebugMacro(<<"Loading cell data array named: " << ncVar->name());
+  vtkDebugMacro(<<"Loading cell data array named: " << varname);
 
   // Get data type:
-  NcType typeNc = ncVar->type();
-  int typeVtk = this->NcTypeToVtkType(typeNc);
+  nc_type typeNc;
+  if (this->Internals->nc_err(nc_inq_vartype(this->Internals->ncFile, varid, &typeNc)))
+  {
+    return nullptr;
+  }
+  int typeVtk = NcTypeToVtkType(typeNc);
 
   // Allocate data array pointer for this variable:
   vtkSmartPointer<vtkDataArray> array =
@@ -2273,13 +2605,13 @@ vtkDataArray* vtkMPASReader::LoadCellVarData(int variableIndex)
     array = vtkSmartPointer<vtkDataArray>::Take(
           vtkDataArray::CreateDataArray(typeVtk));
   }
-  array->SetName(ncVar->name());
+  array->SetName(varname);
   array->SetNumberOfComponents(1);
   array->SetNumberOfTuples(this->MaximumCells);
 
   int success = false;
   vtkNcDispatch(typeVtk,
-                success = this->LoadCellVarDataImpl<VTK_TT>(ncVar, array););
+                success = this->Internals->LoadCellVarDataImpl<VTK_TT>(varid, array););
   if (success)
   {
     this->Internals->cellArrays[variableIndex] = array;
@@ -2334,19 +2666,21 @@ void vtkMPASReader::LoadTimeFieldData(vtkUnstructuredGrid *dataset)
 
   // If the xtime variable exists, use its value at the current timestep:
   std::string time;
-  if (isNcVar(this->Internals->ncFile, "xtime"))
+  int varid;
+  if ((varid = this->Internals->nc_var_id("xtime")) != -1)
   {
-    NcVar *var = this->Internals->ncFile->get_var("xtime");
-    if (var && this->ValidateDimensions(var, false, 2, "Time", "StrLen"))
+    if (this->Internals->ValidateDimensions(varid, false, 2, "Time", "StrLen"))
     {
-      NcDim *strLenDim = this->Internals->ncFile->get_dim("StrLen");
-      assert(strLenDim);
-      long strLen = strLenDim->size();
+      int dimid = this->Internals->nc_dim_id("StrLen");
+      assert(dimid != -1);
+      size_t strLen = 0;
+      this->Internals->nc_err(nc_inq_dimlen(this->Internals->ncFile, dimid, &strLen));
       if (strLen > 0)
       {
         time.resize(strLen);
-        var->set_cur(this->GetCursorForDimension(var->get_dim(0)), 0);
-        if (var->get(&time[0], 1, strLen))
+        size_t start[] = {this->Internals->GetCursorForDimension(dimid), 0};
+        size_t count[] = {1, strLen};
+        if (this->Internals->nc_err(nc_get_vara_text(this->Internals->ncFile, varid, start, count, &time[0])))
         {
           // Trim off trailing whitespace:
           size_t realLength = time.find_last_not_of(' ');
@@ -2379,30 +2713,6 @@ void vtkMPASReader::LoadTimeFieldData(vtkUnstructuredGrid *dataset)
   array->SetValue(0, time);
 }
 
-//------------------------------------------------------------------------------
-inline int vtkMPASReader::NcTypeToVtkType(int ncType)
-{
-  switch (static_cast<NcType>(ncType))
-  {
-    case ncByte:
-      return VTK_SIGNED_CHAR;
-    case ncChar:
-      return VTK_CHAR;
-    case ncShort:
-      return VTK_SHORT;
-    case ncInt:
-      return VTK_INT;
-    case ncFloat:
-      return VTK_FLOAT;
-    case ncDouble:
-      return VTK_DOUBLE;
-    case ncNoType:
-    default: // Shouldn't happen...
-      vtkGenericWarningMacro(<<"Invalid NcType: " << ncType);
-      return VTK_VOID;
-  }
-}
-
 //----------------------------------------------------------------------------
 //  Callback if the user selects a variable.
 //----------------------------------------------------------------------------
@@ -2653,7 +2963,7 @@ void vtkMPASReader::SetDimensionCurrentIndex(const std::string &dim, int idx)
   typedef Internal::DimMetaDataMap::iterator Iter;
   Iter it = this->Internals->dimMetaDataMap.find(dim);
   if (it != this->Internals->dimMetaDataMap.end() &&
-      idx < it->second.dimSize)
+      static_cast<size_t>(idx) < it->second.dimSize)
   {
     it->second.curIdx = idx;
     this->Modified();
@@ -2715,16 +3025,18 @@ void vtkMPASReader::SetCenterLon(int val)
 
 int vtkMPASReader::CanReadFile(const char *filename)
 {
-  NcFile ncFile(filename);
-  if (!ncFile.is_valid())
+  Internal *internals = new Internal(nullptr);
+  if (!internals->open(filename))
   {
+    delete internals;
     return 0;
   }
   bool ret = true;
-  ret &= isNcDim(&ncFile, "nCells");
-  ret &= isNcDim(&ncFile, "nVertices");
-  ret &= isNcDim(&ncFile, "vertexDegree");
-  ret &= isNcDim(&ncFile, "Time");
+  ret &= (internals->nc_dim_id("nCells") != -1);
+  ret &= (internals->nc_dim_id("nVertices") != -1);
+  ret &= (internals->nc_dim_id("vertexDegree") != -1);
+  ret &= (internals->nc_dim_id("Time") != -1);
+  delete internals;
   return ret;
 }
 
diff --git a/IO/NetCDF/vtkMPASReader.h b/IO/NetCDF/vtkMPASReader.h
index 06e2918c0d5..df3dd1c8b28 100644
--- a/IO/NetCDF/vtkMPASReader.h
+++ b/IO/NetCDF/vtkMPASReader.h
@@ -80,8 +80,6 @@ version available from Los Alamos National Laboratory.
 #include "vtkIONetCDFModule.h" // For export macro
 #include "vtkUnstructuredGridAlgorithm.h"
 
-#include "vtk_netcdfcpp_fwd.h" // Forward declarations for vtknetcdfcpp
-
 #include <string> // for std::string
 
 class vtkCallbackCommand;
@@ -239,7 +237,7 @@ class VTKIONETCDF_EXPORT vtkMPASReader : public vtkUnstructuredGridAlgorithm
 
   char *FileName;         // First field part file giving path
 
-  int NumberOfTimeSteps;      // Temporal domain
+  size_t NumberOfTimeSteps;   // Temporal domain
   double DTime;               // The current time
 
   // Observer to modify this object when array selections are modified
@@ -295,23 +293,23 @@ class VTKIONETCDF_EXPORT vtkMPASReader : public vtkUnstructuredGridAlgorithm
   bool UseDimensionedArrayNames;
 
   // geometry
-  int MaximumNVertLevels;
-  int NumberOfCells;
-  int NumberOfPoints;
+  size_t MaximumNVertLevels;
+  size_t NumberOfCells;
+  size_t NumberOfPoints;
   int CellOffset;
-  int PointOffset;
-  int PointsPerCell;
-  int CurrentExtraPoint;  // current extra point
-  int CurrentExtraCell;   // current extra cell
+  size_t PointOffset;
+  size_t PointsPerCell;
+  size_t CurrentExtraPoint;  // current extra point
+  size_t CurrentExtraCell;   // current extra cell
   double* PointX;      // x coord of point
   double* PointY;      // y coord of point
   double* PointZ;      // z coord of point
-  int ModNumPoints;
-  int ModNumCells;
+  size_t ModNumPoints;
+  size_t ModNumCells;
   int* OrigConnections;   // original connections
   int* ModConnections;    // modified connections
-  int* CellMap;           // maps from added cell to original cell #
-  int* PointMap;          // maps from added point to original point #
+  size_t* CellMap;        // maps from added cell to original cell #
+  size_t* PointMap;       // maps from added point to original point #
   int* MaximumLevelPoint;      //
   int MaximumCells;           // max cells
   int MaximumPoints;          // max points
@@ -334,32 +332,6 @@ class VTKIONETCDF_EXPORT vtkMPASReader : public vtkUnstructuredGridAlgorithm
   void OutputCells();
   unsigned char GetCellType();
 
-  /**
-   * Returns true if the dimensions in var match the expected args, or prints a
-   * warning and returns false if any are incorrect.
-   * ndims is the number of dimensions, and the variatic args must be
-   * C-strings identifying the expected dimensions.
-   * If silent is true, no warnings are printed.
-   */
-  bool ValidateDimensions(NcVar *var, bool silent, int ndims, ...);
-
-  /**
-   * Return the cursor position for the specified dimension.
-   */
-  long GetCursorForDimension(const NcDim *dim);
-
-  /**
-   * Return the number of values to read for the specified dimension.
-   */
-  size_t GetCountForDimension(const NcDim *dim);
-
-  /**
-   * For an arbitrary (i.e. not nCells, nVertices, or Time) dimension, extract
-   * the dimension's metadata into memory (if needed) and return the last used
-   * index into the dimension values, or 0 if the dimension is new.
-   */
-  long InitializeDimension(const NcDim *dim);
-
   vtkDataArray* LoadPointVarData(int variable);
   vtkDataArray* LoadCellVarData(int variable);
   vtkDataArray* LookupPointDataArray(int varIdx);
@@ -381,20 +353,6 @@ class VTKIONETCDF_EXPORT vtkMPASReader : public vtkUnstructuredGridAlgorithm
 
   class Internal;
   Internal *Internals;
-
-  static int NcTypeToVtkType(int ncType);
-
-  vtkDataArray* CreateDataArray(int ncType);
-  vtkIdType ComputeNumberOfTuples(NcVar *ncVar);
-
-  template <typename ValueType>
-  bool LoadDataArray(NcVar *ncVar, vtkDataArray *array, bool resize = true);
-
-  template <typename ValueType>
-  int LoadPointVarDataImpl(NcVar *ncVar, vtkDataArray *array);
-
-  template <typename ValueType>
-  int LoadCellVarDataImpl(NcVar *ncVar, vtkDataArray *array);
 };
 
 #endif

From b9a70144f0370035b507970aad8fc01abc76286c Mon Sep 17 00:00:00 2001
From: Ben Boeckel <ben.boeckel@kitware.com>
Date: Wed, 3 Oct 2018 17:06:24 -0400
Subject: [PATCH 6/9] vtkNetCDFCAMReader: clean up filename handling

---
 IO/NetCDF/vtkNetCDFCAMReader.cxx | 35 +++++++-------------------------
 1 file changed, 7 insertions(+), 28 deletions(-)

diff --git a/IO/NetCDF/vtkNetCDFCAMReader.cxx b/IO/NetCDF/vtkNetCDFCAMReader.cxx
index 16ad841f875..9e76bae9401 100644
--- a/IO/NetCDF/vtkNetCDFCAMReader.cxx
+++ b/IO/NetCDF/vtkNetCDFCAMReader.cxx
@@ -174,21 +174,10 @@ void vtkNetCDFCAMReader::SetFileName(const char* fileName)
   this->PointsFile = nullptr;
   delete [] this->FileName;
   this->FileName = nullptr;
-  if (fileName)
+  if (fileName && *fileName)
   {
-    size_t n = strlen(fileName) + 1;
-    char *cp1 =  new char[n];
-    const char *cp2 = (fileName);
-    this->FileName = cp1;
-    do
-    {
-      *cp1++ = *cp2++;
-    }
-    while ( --n );
-  }
-  else
-  {
-    this->FileName = nullptr;
+    this->FileName = new char[strlen(fileName) + 1];
+    strcpy(this->FileName, fileName);
   }
   this->Modified();
 }
@@ -210,21 +199,11 @@ void vtkNetCDFCAMReader::SetConnectivityFileName(const char* fileName)
   delete this->ConnectivityFile;
   this->ConnectivityFile = nullptr;
   delete [] this->ConnectivityFileName;
-  if (fileName)
-  {
-    size_t n = strlen(fileName) + 1;
-    char *cp1 =  new char[n];
-    const char *cp2 = (fileName);
-    this->ConnectivityFileName = cp1;
-    do
-    {
-      *cp1++ = *cp2++;
-    }
-    while ( --n );
-  }
-  else
+  this->ConnectivityFileName = nullptr;
+  if (fileName && *fileName)
   {
-    this->ConnectivityFileName = nullptr;
+    this->ConnectivityFileName = new char[strlen(fileName) + 1];
+    strcpy(this->ConnectivityFileName, fileName);
   }
   this->Modified();
 }

From bb81849de595041dd6496c72a05ebb2ac7e81156 Mon Sep 17 00:00:00 2001
From: Ben Boeckel <ben.boeckel@kitware.com>
Date: Wed, 3 Oct 2018 18:03:46 -0400
Subject: [PATCH 7/9] vtkNetCDFCAMReader: remove dependency on netcdfcpp

---
 IO/NetCDF/vtkNetCDFCAMReader.cxx | 657 +++++++++++++++++++++----------
 IO/NetCDF/vtkNetCDFCAMReader.h   |  19 +-
 2 files changed, 460 insertions(+), 216 deletions(-)

diff --git a/IO/NetCDF/vtkNetCDFCAMReader.cxx b/IO/NetCDF/vtkNetCDFCAMReader.cxx
index 9e76bae9401..62041749af0 100644
--- a/IO/NetCDF/vtkNetCDFCAMReader.cxx
+++ b/IO/NetCDF/vtkNetCDFCAMReader.cxx
@@ -35,7 +35,7 @@
 #include <set>
 #include <sstream>
 #include <vector>
-#include <vtk_netcdfcpp.h>
+#include <vtk_netcdf.h>
 
 namespace
 {
@@ -67,34 +67,130 @@ namespace
   {
     return std::abs(val) < std::numeric_limits<T>::epsilon();
   }
+}
+
+class vtkNetCDFCAMReader::Internal
+{
+public:
+  Internal(vtkNetCDFCAMReader *r)
+    : reader(r), nc_points(-1), nc_connectivity(-1)
+  {
+  }
+  ~Internal()
+  {
+    closePoints();
+    closeConnectivity();
+  }
 
-  /**
-   * Returns the concatenation of the name of the variable
-   * with the dimensions as a string.
-   */
-  std::string GetNameDimension(NcVar* var)
+  bool open(const char* file, int *ncfile)
   {
-    std::ostringstream name;
-    std::ostringstream postfix;
-    if (! var)
+    int mode = NC_NOWRITE | NC_64BIT_OFFSET | NC_NETCDF4 | NC_CLASSIC_MODEL;
+    int ncid;
+    if (nc_err(nc_open(file, mode, &ncid)))
     {
-      return "";
+      return false;
+    }
+    *ncfile = ncid;
+    return true;
+  }
+  bool openPoints(const char* file)
+  {
+    return open(file, &nc_points);
+  }
+  bool openConnectivity(const char* file)
+  {
+    return open(file, &nc_connectivity);
+  }
+  void closePoints()
+  {
+    if (nc_points != -1)
+    {
+      nc_err(nc_close(nc_points));
+      nc_points = -1;
     }
-    postfix << "["
-            << var->get_dim(0)->name() << ", "
-            << var->get_dim(1)->name();
-    if (var->num_dims() == 2)
+  }
+
+  void closeConnectivity()
+  {
+    if (nc_connectivity != -1)
     {
-      postfix << "]";
+      nc_err(nc_close(nc_connectivity));
+      nc_connectivity = -1;
     }
-    else
+  }
+
+  bool nc_err(int nc_ret, bool msg_on_err = true) const;
+
+  std::string GetNameDimension(int ncid, int varid) const;
+
+  vtkNetCDFCAMReader *reader;
+  int nc_points;
+  int nc_connectivity;
+};
+
+bool vtkNetCDFCAMReader::Internal::nc_err(int nc_ret, bool msg_on_err) const
+{
+  if (nc_ret == NC_NOERR)
+  {
+    return false;
+  }
+
+  if (msg_on_err)
+  {
+    vtkErrorWithObjectMacro(reader, << "NetCDF error: " << nc_strerror(nc_ret));
+  }
+  return true;
+}
+
+std::string vtkNetCDFCAMReader::Internal::GetNameDimension(int nc_file, int nc_var) const
+{
+  int ndims;
+  if (nc_err(nc_inq_varndims(nc_file, nc_var, &ndims)))
+  {
+    return "";
+  }
+  if (ndims < 2)
+  {
+    return "";
+  }
+
+  int dims[NC_MAX_VAR_DIMS];
+  if (nc_err(nc_inq_vardimid(nc_file, nc_var, dims)))
+  {
+    return "";
+  }
+
+  std::ostringstream postfix;
+
+  char ncname[NC_MAX_NAME + 1];
+  if (nc_err(nc_inq_dimname(nc_file, dims[0], ncname)))
+  {
+    return "";
+  }
+  postfix << "[" << ncname;
+  if (nc_err(nc_inq_dimname(nc_file, dims[1], ncname)))
+  {
+    return "";
+  }
+  postfix << "," << ncname;
+
+  if (ndims > 2)
+  {
+    if (nc_err(nc_inq_dimname(nc_file, dims[2], ncname)))
     {
-      postfix << ", "
-              << var->get_dim(2)->name() << "]";
+      return "";
     }
-    name << var->name() << " " << postfix.str();
-    return name.str();
+    postfix << ", " << ncname;
+  }
+  postfix << "]";
+
+  if (nc_err(nc_inq_varname(nc_file, nc_var, ncname)))
+  {
+    return "";
   }
+  std::ostringstream name;
+  name << ncname << " " << postfix.str();
+  return name.str();
 }
 
 //----------------------------------------------------------------------------
@@ -107,8 +203,6 @@ vtkNetCDFCAMReader::vtkNetCDFCAMReader()
   this->CurrentFileName = nullptr;
   this->ConnectivityFileName = nullptr;
   this->CurrentConnectivityFileName = nullptr;
-  this->PointsFile = nullptr;
-  this->ConnectivityFile = nullptr;
   this->VerticalDimension = VERTICAL_DIMENSION_MIDPOINT_LAYERS;
   this->TimeSteps = nullptr;
   this->NumberOfTimeSteps = 0;
@@ -130,6 +224,8 @@ vtkNetCDFCAMReader::vtkNetCDFCAMReader()
   this->InterfaceLayerIndex = 0;
   this->InterfaceLayersRange[0] = 0;
   this->InterfaceLayersRange[1] = 1;
+
+  this->Internals = new Internal(this);
 }
 
 //----------------------------------------------------------------------------
@@ -139,23 +235,27 @@ vtkNetCDFCAMReader::~vtkNetCDFCAMReader()
   this->SetCurrentFileName(nullptr);
   this->SetConnectivityFileName(nullptr);
   this->SetCurrentConnectivityFileName(nullptr);
-  delete this->PointsFile;
-  this->PointsFile = nullptr;
-  delete this->ConnectivityFile;
-  this->ConnectivityFile = nullptr;
   delete []this->TimeSteps;
   this->TimeSteps = nullptr;
   this->PointDataArraySelection->Delete();
   this->PointDataArraySelection = nullptr;
   this->SelectionObserver->Delete();
   this->SelectionObserver = nullptr;
+
+  delete this->Internals;
 }
 
 //----------------------------------------------------------------------------
 int vtkNetCDFCAMReader::CanReadFile(const char* fileName)
 {
-  NcFile file(fileName, NcFile::ReadOnly);
-  return file.is_valid();
+  Internal *internals = new Internal(nullptr);
+  if (!internals->openPoints(fileName))
+  {
+    delete internals;
+    return 0;
+  }
+  delete internals;
+  return 1;
 }
 
 //----------------------------------------------------------------------------
@@ -170,8 +270,7 @@ void vtkNetCDFCAMReader::SetFileName(const char* fileName)
   {
     return;
   }
-  delete this->PointsFile;
-  this->PointsFile = nullptr;
+  this->Internals->closePoints();
   delete [] this->FileName;
   this->FileName = nullptr;
   if (fileName && *fileName)
@@ -196,8 +295,7 @@ void vtkNetCDFCAMReader::SetConnectivityFileName(const char* fileName)
   {
     return;
   }
-  delete this->ConnectivityFile;
-  this->ConnectivityFile = nullptr;
+  this->Internals->closeConnectivity();
   delete [] this->ConnectivityFileName;
   this->ConnectivityFileName = nullptr;
   if (fileName && *fileName)
@@ -223,53 +321,72 @@ int vtkNetCDFCAMReader::RequestInformation(
   if(this->CurrentFileName != nullptr &&
      strcmp(this->CurrentFileName, this->FileName) != 0)
   {
-    delete this->PointsFile;
+    this->Internals->closePoints();
     this->PointDataArraySelection->RemoveAllArrays();
-    this->PointsFile = nullptr;
     this->SetCurrentFileName(nullptr);
   }
-  if(this->PointsFile == nullptr)
+  if(this->Internals->nc_points == -1)
   {
-    this->PointsFile = new NcFile(this->FileName, NcFile::ReadOnly);
-    if(this->PointsFile->is_valid() == 0)
+    if(!this->Internals->openPoints(this->FileName))
     {
       vtkErrorMacro(<< "Can't read file " << this->FileName);
-      delete this->PointsFile;
-      this->PointsFile = nullptr;
       return 0;
     }
     this->SetCurrentFileName(this->FileName);
     this->BuildVarArray();
-    NcDim* levDim = this->PointsFile->get_dim("lev");
-    if (levDim)
+    int dimid;
+    if (!this->Internals->nc_err(nc_inq_dimid(this->Internals->nc_points, "lev", &dimid), false))
     {
-      this->MidpointLayersRange[1] = levDim->size() - 1;
+      size_t size;
+      if (this->Internals->nc_err(nc_inq_dimlen(this->Internals->nc_points, dimid, &size)))
+      {
+        return 0;
+      }
+      this->MidpointLayersRange[1] = static_cast<int>(size - 1);
     }
-    NcDim* ilevDim = this->PointsFile->get_dim("ilev");
-    if (ilevDim)
+    if (!this->Internals->nc_err(nc_inq_dimid(this->Internals->nc_points, "ilev", &dimid), false))
     {
-      this->InterfaceLayersRange[1] = ilevDim->size() - 1;
+      size_t size;
+      if (this->Internals->nc_err(nc_inq_dimlen(this->Internals->nc_points, dimid, &size)))
+      {
+        return 0;
+      }
+      this->InterfaceLayersRange[1] = static_cast<int>(size - 1);
     }
   }
-  NcDim* timeDimension = this->PointsFile->get_dim("time");
-  if(timeDimension == nullptr)
+  int dimid;
+  if (this->Internals->nc_err(nc_inq_dimid(this->Internals->nc_points, "time", &dimid)))
   {
     vtkErrorMacro("Cannot find the number of time steps (time dimension).");
     return 0;
   }
-  this->NumberOfTimeSteps = timeDimension->size();
+  size_t size;
+  if (this->Internals->nc_err(nc_inq_dimlen(this->Internals->nc_points, dimid, &size)))
+  {
+    return 0;
+  }
+  this->NumberOfTimeSteps = size;
   vtkInformation* outInfo = outputVector->GetInformationObject(0);
 
   if (this->NumberOfTimeSteps > 0)
   {
     delete []this->TimeSteps;
     this->TimeSteps = new double[this->NumberOfTimeSteps];
-    NcVar* timeVar = this->PointsFile->get_var("time");
-    timeVar->get(this->TimeSteps, this->NumberOfTimeSteps);
+    int varid;
+    if (this->Internals->nc_err(nc_inq_varid(this->Internals->nc_points, "time", &varid)))
+    {
+      return 0;
+    }
+    size_t start[] = {0};
+    size_t count[] = {this->NumberOfTimeSteps};
+    if (this->Internals->nc_err(nc_get_vara_double(this->Internals->nc_points, varid, start, count, this->TimeSteps)))
+    {
+      return 0;
+    }
 
     // Tell the pipeline what steps are available
     outInfo->Set(vtkStreamingDemandDrivenPipeline::TIME_STEPS(),
-              this->TimeSteps, this->NumberOfTimeSteps);
+              this->TimeSteps, static_cast<int>(this->NumberOfTimeSteps));
 
     // Range is required to get GUI to show things
     double tRange[2] = {this->TimeSteps[0],
@@ -291,37 +408,86 @@ int vtkNetCDFCAMReader::RequestInformation(
 //----------------------------------------------------------------------------
 void vtkNetCDFCAMReader::BuildVarArray()
 {
-  std::vector<std::set<std::string> > vars(VERTICAL_DIMENSION_COUNT);
-  for(int i=0; i<this->PointsFile->num_vars(); i++)
+  std::vector<std::set<std::string> > varsnames(VERTICAL_DIMENSION_COUNT);
+  int nvars;
+  int vars[NC_MAX_VARS];
+  if (this->Internals->nc_err(nc_inq_varids(this->Internals->nc_points, &nvars, vars)))
+  {
+    return;
+  }
+  for(int i=0; i<nvars; i++)
   {
-    NcVar* var = this->PointsFile->get_var(i);
     bool showVar = false;
     enum VerticalDimension verticalDimension = VERTICAL_DIMENSION_SINGLE_LAYER;
-    if(var->num_dims() == 3 &&
-       strcmp(var->get_dim(0)->name(), "time") == 0 &&
-       (strcmp(var->get_dim(1)->name(), "lev") == 0 ||
-        strcmp(var->get_dim(1)->name(), "ilev") == 0) &&
-       strcmp(var->get_dim(2)->name(), "ncol") == 0)
+    int ndims;
+    if (this->Internals->nc_err(nc_inq_varndims(this->Internals->nc_points, vars[i], &ndims)))
     {
-      verticalDimension = (strcmp(var->get_dim(1)->name(), "lev") == 0) ?
-        VERTICAL_DIMENSION_MIDPOINT_LAYERS: VERTICAL_DIMENSION_INTERFACE_LAYERS;
-      showVar = true;
+      continue;
+    }
+    int dims[NC_MAX_VAR_DIMS];
+    if (this->Internals->nc_err(nc_inq_vardimid(this->Internals->nc_points, vars[i], dims)))
+    {
+      continue;
     }
-    else if(var->num_dims() == 2 &&
-            strcmp(var->get_dim(0)->name(), "time") == 0 &&
-            strcmp(var->get_dim(1)->name(), "ncol") == 0)
+    if(ndims == 3)
     {
-      verticalDimension = VERTICAL_DIMENSION_SINGLE_LAYER;
-      showVar = true;
+      bool ok = true;
+      char name[NC_MAX_NAME + 1];
+      if (this->Internals->nc_err(nc_inq_dimname(this->Internals->nc_points, dims[0], name)))
+      {
+        continue;
+      }
+      ok = ok && (strcmp(name, "time") == 0);
+
+      if (this->Internals->nc_err(nc_inq_dimname(this->Internals->nc_points, dims[1], name)))
+      {
+        continue;
+      }
+      ok = ok && (strcmp(name, "lev") == 0 || strcmp(name, "ilev") == 0);
+      verticalDimension = (strcmp(name, "lev") == 0) ?
+        VERTICAL_DIMENSION_MIDPOINT_LAYERS : VERTICAL_DIMENSION_INTERFACE_LAYERS;
+
+      if (this->Internals->nc_err(nc_inq_dimname(this->Internals->nc_points, dims[2], name)))
+      {
+        continue;
+      }
+      ok = ok && (strcmp(name, "ncol") == 0);
+
+      if (ok)
+      {
+        showVar = true;
+      }
+    }
+    else if(ndims == 2)
+    {
+      bool ok = true;
+      char name[NC_MAX_NAME + 1];
+      if (this->Internals->nc_err(nc_inq_dimname(this->Internals->nc_points, dims[0], name)))
+      {
+        continue;
+      }
+      ok = ok && (strcmp(name, "time") == 0);
+
+      if (this->Internals->nc_err(nc_inq_dimname(this->Internals->nc_points, dims[1], name)))
+      {
+        continue;
+      }
+      ok = ok && (strcmp(name, "ncol") == 0);
+
+      if (ok)
+      {
+        verticalDimension = VERTICAL_DIMENSION_SINGLE_LAYER;
+        showVar = true;
+      }
     }
     if (showVar)
     {
-      vars[verticalDimension].insert(GetNameDimension(var));
+      varsnames[verticalDimension].insert(this->Internals->GetNameDimension(this->Internals->nc_points, vars[i]));
     }
   }
   for (int i = 0; i < VERTICAL_DIMENSION_COUNT; ++i)
   {
-    for(std::set<std::string>::iterator it = vars[i].begin(); it != vars[i].end();
+    for(std::set<std::string>::iterator it = varsnames[i].begin(); it != varsnames[i].end();
         ++it)
     {
       this->PointDataArraySelection->EnableArray(it->c_str());
@@ -419,109 +585,134 @@ int vtkNetCDFCAMReader::RequestData(
   if(this->CurrentConnectivityFileName != nullptr &&
      strcmp(this->CurrentConnectivityFileName, this->ConnectivityFileName) != 0)
   {
-    delete this->ConnectivityFile;
-    this->ConnectivityFile = nullptr;
+    this->Internals->closeConnectivity();
     this->SetCurrentConnectivityFileName(nullptr);
   }
-  if(this->ConnectivityFile == nullptr)
+  if(this->Internals->nc_connectivity == -1)
   {
-    this->ConnectivityFile = new NcFile(this->ConnectivityFileName,
-                                        NcFile::ReadOnly);
-    if(this->ConnectivityFile->is_valid() == 0)
+    if(!this->Internals->openConnectivity(this->ConnectivityFileName))
     {
       vtkErrorMacro(<< "Can't read file " << this->ConnectivityFileName);
-      delete this->ConnectivityFile;
-      this->ConnectivityFile = nullptr;
       return 0;
     }
     this->SetCurrentConnectivityFileName(this->ConnectivityFileName);
   }
 
-  // Set the NetCDF error handler to not kill the application.
-  // Upon exiting this method the error handler will be restored
-  // to its previous state.
-  NcError ncError(NcError::verbose_nonfatal);
-
   // read in the points first
-  long numLevels = 1; // value for single level
+  size_t numLevels = 1; // value for single level
   const char* levName = nullptr;
-  NcVar* levelsVar = nullptr;
+  int levelsid;
   if (this->VerticalDimension == VERTICAL_DIMENSION_MIDPOINT_LAYERS ||
       this->VerticalDimension == VERTICAL_DIMENSION_INTERFACE_LAYERS)
   {
     levName = (this->VerticalDimension == VERTICAL_DIMENSION_MIDPOINT_LAYERS) ?
       "lev" : "ilev";
-    NcDim* levelsDimension = this->PointsFile->get_dim(levName);
-    if(levelsDimension == nullptr)
+    int dimid;
+    if (this->Internals->nc_err(nc_inq_dimid(this->Internals->nc_points, levName, &dimid)))
     {
       vtkErrorMacro("Cannot find the number of levels (lev dimension).");
       return 0;
     }
-    numLevels = levelsDimension->size();
-    levelsVar = this->PointsFile->get_var(levName);
-    if(levelsVar == nullptr)
+    if (this->Internals->nc_err(nc_inq_dimlen(this->Internals->nc_points, dimid, &numLevels)))
+    {
+      return 0;
+    }
+    if (this->Internals->nc_err(nc_inq_varid(this->Internals->nc_points, levName, &levelsid)))
     {
       vtkErrorMacro("Cannot find the number of levels (lev variable).");
       return 0;
     }
-    if(levelsVar->num_dims() != 1 ||
-       levelsVar->get_dim(0)->size() != numLevels)
+    int ndims;
+    if (this->Internals->nc_err(nc_inq_varndims(this->Internals->nc_points, levelsid, &ndims)))
+    {
+      return 0;
+    }
+    int dims[NC_MAX_VAR_DIMS];
+    if (this->Internals->nc_err(nc_inq_vardimid(this->Internals->nc_points, levelsid, dims)))
+    {
+      return 0;
+    }
+    size_t size;
+    if (this->Internals->nc_err(nc_inq_dimlen(this->Internals->nc_points, dims[0], &size)))
+    {
+      return 0;
+    }
+    if(ndims != 1 || size != numLevels)
     {
       vtkErrorMacro("The lev variable is not consistent.");
       return 0;
     }
   }
-  NcDim* dimension = this->PointsFile->get_dim("ncol");
-  if(dimension == nullptr)
+  int dimid;
+  if (this->Internals->nc_err(nc_inq_dimid(this->Internals->nc_points, "ncol", &dimid)))
   {
     vtkErrorMacro("Cannot find the number of points (ncol dimension).");
     return 0;
   }
-  NcVar* lon = this->PointsFile->get_var("lon");
-  NcVar* lat = this->PointsFile->get_var("lat");
+  int lonid;
+  if (this->Internals->nc_err(nc_inq_varid(this->Internals->nc_points, "lon", &lonid)))
+  {
+    vtkErrorMacro("Cannot find coordinates (lon variable).");
+    return 0;
+  }
+  int latid;
+  if (this->Internals->nc_err(nc_inq_varid(this->Internals->nc_points, "lat", &latid)))
+  {
+    vtkErrorMacro("Cannot find coordinates (lat variable).");
+    return 0;
+  }
   vtkSmartPointer<vtkPoints> points = vtkSmartPointer<vtkPoints>::New();
   output->SetPoints(points);
 
-  long numFilePoints = dimension->size();
-  if(lat == nullptr || lon == nullptr)
+  size_t numFilePoints;
+  if (this->Internals->nc_err(nc_inq_dimlen(this->Internals->nc_points, dimid, &numFilePoints)))
+  {
+    return 0;
+  }
+
+  nc_type var_type;
+  if (this->Internals->nc_err(nc_inq_vartype(this->Internals->nc_points, latid, &var_type)))
   {
-    vtkErrorMacro("Cannot find coordinates (lat or lon variable).");
     return 0;
   }
-  if(lat->type() == ncDouble)
+  if(var_type == NC_DOUBLE)
   {
     points->SetDataTypeToDouble();
-    points->SetNumberOfPoints(numFilePoints);
+    points->SetNumberOfPoints(static_cast<int>(numFilePoints));
     std::vector<double> array(numFilePoints*2);
-    if(!lon->get(&array[0], numFilePoints))
+    size_t start[] = {0};
+    size_t count[] = {numFilePoints};
+    if (this->Internals->nc_err(nc_get_vara_double(this->Internals->nc_points, lonid, start, count, &array[0])))
     {
       return 0;
     }
-    if(!lat->get(&array[numFilePoints], numFilePoints))
+    if (this->Internals->nc_err(nc_get_vara_double(this->Internals->nc_points, latid, start, count, &array[numFilePoints])))
     {
       return 0;
     }
-    for(long i=0;i<numFilePoints;i++)
+    for(size_t i=0;i<numFilePoints;i++)
     {
-      points->SetPoint(i, array[i], array[i+numFilePoints], numLevels);
+      points->SetPoint(static_cast<vtkIdType>(i), array[i], array[i+numFilePoints], numLevels);
     }
   }
   else
   {
     points->SetDataTypeToFloat();
-    points->SetNumberOfPoints(numFilePoints);
+    points->SetNumberOfPoints(static_cast<int>(numFilePoints));
     std::vector<float> array(numFilePoints*2);
-    if(!lon->get(&array[0], numFilePoints))
+    size_t start[] = {0};
+    size_t count[] = {numFilePoints};
+    if (this->Internals->nc_err(nc_get_vara_float(this->Internals->nc_points, lonid, start, count, &array[0])))
     {
       return 0;
     }
-    if(!lat->get(&array[numFilePoints], numFilePoints))
+    if (this->Internals->nc_err(nc_get_vara_float(this->Internals->nc_points, latid, start, count, &array[numFilePoints])))
     {
       return 0;
     }
-    for(long i=0;i<numFilePoints;i++)
+    for(size_t i=0;i<numFilePoints;i++)
     {
-      points->SetPoint(i, array[i], array[i+numFilePoints], numLevels - 1);
+      points->SetPoint(static_cast<vtkIdType>(i), array[i], array[i+numFilePoints], numLevels - 1);
     }
   }
   this->SetProgress(.25);  // educated guess for progress
@@ -543,25 +734,26 @@ int vtkNetCDFCAMReader::RequestData(
   locator->SetDataSet(output); // dataset only has points right now.
   locator->BuildLocator();
 
-  dimension = this->ConnectivityFile->get_dim("ncells");
-  if(dimension == nullptr)
+  if (this->Internals->nc_err(nc_inq_dimid(this->Internals->nc_connectivity, "ncells", &dimid)))
   {
     vtkErrorMacro("Cannot find the number of cells (ncells dimension).");
     return 0;
   }
-  NcVar* connectivity =
-    this->ConnectivityFile->get_var("element_corners");
-  if(connectivity == nullptr)
+  int connid;
+  if (this->Internals->nc_err(nc_inq_varid(this->Internals->nc_connectivity, "element_corners", &connid)))
   {
     vtkErrorMacro("Cannot find cell connectivity (element_corners dimension).");
     return 0;
   }
-  long numCellsPerLevel = dimension->size();
-
+  size_t numCellsPerLevel;
+  if (this->Internals->nc_err(nc_inq_dimlen(this->Internals->nc_connectivity, dimid, &numCellsPerLevel)))
+  {
+    return 0;
+  }
 
-  int piece = outInfo->Get(vtkStreamingDemandDrivenPipeline::UPDATE_PIECE_NUMBER());
-  int numPieces = outInfo->Get(vtkStreamingDemandDrivenPipeline::UPDATE_NUMBER_OF_PIECES());
-  int originalNumLevels = numLevels;
+  size_t piece = outInfo->Get(vtkStreamingDemandDrivenPipeline::UPDATE_PIECE_NUMBER());
+  size_t numPieces = outInfo->Get(vtkStreamingDemandDrivenPipeline::UPDATE_NUMBER_OF_PIECES());
+  size_t originalNumLevels = numLevels;
   if ((this->VerticalDimension == VERTICAL_DIMENSION_MIDPOINT_LAYERS &&
        this->SingleMidpointLayer) ||
       (this->VerticalDimension == VERTICAL_DIMENSION_INTERFACE_LAYERS &&
@@ -570,20 +762,24 @@ int vtkNetCDFCAMReader::RequestData(
     numLevels = 1;
   }
 
-  int beginLevel, endLevel, beginCell, endCell;
+  size_t beginLevel, endLevel, beginCell, endCell;
   if (! this->GetPartitioning(piece, numPieces, numLevels, numCellsPerLevel,
                               beginLevel, endLevel, beginCell, endCell))
   {
     return 0;
   }
   // the cells/levels assigned to this piece
-  long numLocalCells = endCell-beginCell;
-  int numLocalLevels = endLevel-beginLevel + 1;
+  size_t numLocalCells = endCell-beginCell;
+  size_t numLocalLevels = endLevel-beginLevel + 1;
   std::vector<int> cellConnectivity(4*numLocalCells);
-  connectivity->set_cur(0, beginCell);
-  connectivity->get(&(cellConnectivity[0]), 4, numLocalCells);
+  size_t start_conn[] = {0, static_cast<size_t>(beginCell)};
+  size_t count_conn[] = {4, static_cast<size_t>(numLocalCells)};
+  if (this->Internals->nc_err(nc_get_vara_int(this->Internals->nc_connectivity, connid, start_conn, count_conn, &cellConnectivity[0])))
+  {
+    return 0;
+  }
 
-  for(long i=0;i<numLocalCells;i++)
+  for(size_t i=0;i<numLocalCells;i++)
   {
     vtkIdType pointIds[4];
     double coords[4][3]; // assume quads here
@@ -664,11 +860,11 @@ int vtkNetCDFCAMReader::RequestData(
         {
           // if a new point was indeed inserted, we need to update the
           // boundaryPoints to keep track of it.
-          assert(newPtId >= numFilePoints && pointIds[j] < newPtId);
-          assert(static_cast<vtkIdType>(boundaryPoints.size()) == (newPtId-numFilePoints));
+          assert(newPtId >= static_cast<vtkIdType>(numFilePoints) && pointIds[j] < newPtId);
+          assert(static_cast<size_t>(boundaryPoints.size()) == (newPtId-numFilePoints));
           boundaryPoints.push_back(pointIds[j]);
         }
-        cellConnectivity[i+j*numLocalCells] = (newPtId + 1); // note: 1-indexed.
+        cellConnectivity[i+j*numLocalCells] = static_cast<int>(newPtId + 1); // note: 1-indexed.
       }
     }
   }
@@ -682,17 +878,17 @@ int vtkNetCDFCAMReader::RequestData(
      originalNumLevels == numLevels)
   {
     // a hacky way to resize the points array without resetting the data
-    points->InsertPoint(numPointsPerLevel*numLocalLevels-1, 0, 0, 0);
+    points->InsertPoint(static_cast<vtkIdType>(numPointsPerLevel*numLocalLevels-1), 0, 0, 0);
     for(vtkIdType pt=0;pt<numPointsPerLevel;pt++)
     {
       double point[3];
       points->GetPoint(pt, point);
       // need to start at 0 here since for multiple process the first
       // level will need to be replaced
-      for(long lev=0;lev<numLocalLevels;lev++)
+      for(size_t lev=0;lev<numLocalLevels;lev++)
       {
         point[2] = numLevels - lev - beginLevel - 1;
-        points->SetPoint(pt+lev*numPointsPerLevel, point);
+        points->SetPoint(static_cast<vtkIdType>(pt+lev*numPointsPerLevel), point);
       }
     }
   }
@@ -717,7 +913,7 @@ int vtkNetCDFCAMReader::RequestData(
   output->GetInformation()->Set(vtkDataObject::DATA_TIME_STEP(), dTime);
 
   // Index of the time step to request
-  int timeStep = 0;
+  size_t timeStep = 0;
   while (timeStep < this->NumberOfTimeSteps &&
          this->TimeSteps[timeStep] < dTime)
   {
@@ -728,27 +924,85 @@ int vtkNetCDFCAMReader::RequestData(
   // data with dimensions (time, lev, ncol) but read them in
   // by chunks of ncol since it will be a pretty big chunk of
   // memory that we'll have to break up anyways.
-  for(int i=0;i<this->PointsFile->num_vars();i++)
+  int nvars;
+  int vars[NC_MAX_VARS];
+  if (this->Internals->nc_err(nc_inq_varids(this->Internals->nc_points, &nvars, vars)))
   {
-    NcVar* variable = this->PointsFile->get_var(i);
-    if(this->VerticalDimension != VERTICAL_DIMENSION_SINGLE_LAYER &&
-       (variable->num_dims() != 3 ||
-        strcmp(variable->get_dim(0)->name(), "time") != 0 ||
-        strcmp(variable->get_dim(1)->name(), levName) != 0 ||
-        strcmp(variable->get_dim(2)->name(), "ncol") != 0) )
-    { // not a 3D field variable
-      continue;
+    return 0;
+  }
+  for(int i=0;i<nvars;i++)
+  {
+    int ndims;
+    if (this->Internals->nc_err(nc_inq_varndims(this->Internals->nc_points, vars[i], &ndims)))
+    {
+      return 0;
     }
-    else if(this->VerticalDimension == VERTICAL_DIMENSION_SINGLE_LAYER &&
-            ((variable->num_dims() != 2 ||
-              strcmp(variable->get_dim(0)->name(), "time") != 0 ||
-              strcmp(variable->get_dim(1)->name(), "ncol") != 0)))
-    { // not a 2D field variable
-      continue;
+    int dims[NC_MAX_VAR_DIMS];
+    if (this->Internals->nc_err(nc_inq_vardimid(this->Internals->nc_points, vars[i], dims)))
+    {
+      return 0;
+    }
+    if(this->VerticalDimension != VERTICAL_DIMENSION_SINGLE_LAYER)
+    { // check for a 3D field variable
+      if (ndims != 3)
+      {
+        continue;
+      }
+
+      char name[NC_MAX_NAME + 1];
+      if (this->Internals->nc_err(nc_inq_dimname(this->Internals->nc_points, dims[0], name)))
+      {
+        return 0;
+      }
+      if (strcmp(name, "time") != 0)
+      {
+        continue;
+      }
+      if (this->Internals->nc_err(nc_inq_dimname(this->Internals->nc_points, dims[1], name)))
+      {
+        return 0;
+      }
+      if (strcmp(name, levName) != 0)
+      {
+        continue;
+      }
+      if (this->Internals->nc_err(nc_inq_dimname(this->Internals->nc_points, dims[2], name)))
+      {
+        return 0;
+      }
+      if (strcmp(name, "ncol") != 0)
+      {
+        continue;
+      }
+    }
+    else if(this->VerticalDimension == VERTICAL_DIMENSION_SINGLE_LAYER)
+    { // check for a 2D field variable
+      if (ndims != 2)
+      {
+        continue;
+      }
+
+      char name[NC_MAX_NAME + 1];
+      if (this->Internals->nc_err(nc_inq_dimname(this->Internals->nc_points, dims[0], name)))
+      {
+        return 0;
+      }
+      if (strcmp(name, "time") != 0)
+      {
+        continue;
+      }
+      if (this->Internals->nc_err(nc_inq_dimname(this->Internals->nc_points, dims[1], name)))
+      {
+        return 0;
+      }
+      if (strcmp(name, "ncol") != 0)
+      {
+        continue;
+      }
     }
 
     if (! this->PointDataArraySelection->GetArraySetting(
-          GetNameDimension(variable).c_str()))
+          this->Internals->GetNameDimension(this->Internals->nc_points, vars[i]).c_str()))
     {
       // not enabled
       continue;
@@ -756,11 +1010,20 @@ int vtkNetCDFCAMReader::RequestData(
 
     vtkDoubleArray* doubleArray = nullptr;
     vtkFloatArray* floatArray = nullptr;
-    if(variable->type() == ncDouble)
+    if (this->Internals->nc_err(nc_inq_vartype(this->Internals->nc_points, vars[i], &var_type)))
+    {
+      return 0;
+    }
+    char varname[NC_MAX_NAME + 1];
+    if (this->Internals->nc_err(nc_inq_varname(this->Internals->nc_points, vars[i], varname)))
+    {
+      return 0;
+    }
+    if(var_type == NC_DOUBLE)
     {
       doubleArray = vtkDoubleArray::New();
       doubleArray->SetNumberOfTuples(points->GetNumberOfPoints());
-      doubleArray->SetName(variable->name());
+      doubleArray->SetName(varname);
       output->GetPointData()->AddArray(doubleArray);
       doubleArray->Delete();
     }
@@ -768,30 +1031,29 @@ int vtkNetCDFCAMReader::RequestData(
     {
       floatArray = vtkFloatArray::New();
       floatArray->SetNumberOfTuples(points->GetNumberOfPoints());
-      floatArray->SetName(variable->name());
+      floatArray->SetName(varname);
       output->GetPointData()->AddArray(floatArray);
       floatArray->Delete();
     }
     if(this->VerticalDimension != VERTICAL_DIMENSION_SINGLE_LAYER)
     {
-      for(long lev=0;lev<numLocalLevels;lev++)
+      for(size_t lev=0;lev<numLocalLevels;lev++)
       {
-        variable->set_cur(timeStep, lev+beginLevel, 0);
+        size_t start[] = {static_cast<size_t>(timeStep), static_cast<size_t>(lev + beginLevel), 0};
+        size_t count[] = {1, 1, numFilePoints};
         if(doubleArray)
         {
-          if(!variable->get(doubleArray->GetPointer(0)+lev*numPointsPerLevel,
-                            1, 1, numFilePoints))
+          if (this->Internals->nc_err(nc_get_vara_double(this->Internals->nc_points, vars[i], start, count, doubleArray->GetPointer(0)+lev*numPointsPerLevel)))
           {
-            vtkErrorMacro("Problem getting NetCDF variable " << variable->name());
+            vtkErrorMacro("Problem getting NetCDF variable " << varname);
             return 0;
           }
         }
         else
         {
-          if(!variable->get(floatArray->GetPointer(0)+lev*numPointsPerLevel,
-                            1, 1, numFilePoints))
+          if (this->Internals->nc_err(nc_get_vara_float(this->Internals->nc_points, vars[i], start, count, floatArray->GetPointer(0)+lev*numPointsPerLevel)))
           {
-            vtkErrorMacro("Problem getting NetCDF variable " << variable->name());
+            vtkErrorMacro("Problem getting NetCDF variable " << varname);
             return 0;
           }
         }
@@ -799,20 +1061,21 @@ int vtkNetCDFCAMReader::RequestData(
     }
     else
     {
-      variable->set_cur(timeStep, 0);
+      size_t start[] = {static_cast<size_t>(timeStep), 0};
+      size_t count[] = {1, numFilePoints};
       if(doubleArray)
       {
-        if(!variable->get(doubleArray->GetPointer(0), 1, numFilePoints))
+        if (this->Internals->nc_err(nc_get_vara_double(this->Internals->nc_points, vars[i], start, count, doubleArray->GetPointer(0))))
         {
-          vtkErrorMacro("Problem getting NetCDF variable " << variable->name());
+          vtkErrorMacro("Problem getting NetCDF variable " << varname);
           return 0;
         }
       }
       else
       {
-        if(!variable->get(floatArray->GetPointer(0), 1, numFilePoints))
+        if (this->Internals->nc_err(nc_get_vara_float(this->Internals->nc_points, vars[i], start, count, floatArray->GetPointer(0))))
         {
-          vtkErrorMacro("Problem getting NetCDF variable " << variable->name());
+          vtkErrorMacro("Problem getting NetCDF variable " << varname);
           return 0;
         }
       }
@@ -829,10 +1092,10 @@ int vtkNetCDFCAMReader::RequestData(
   for (std::vector<vtkIdType>::const_iterator it=
         boundaryPoints.begin(); it!=boundaryPoints.end(); ++it, ++newPtId)
   {
-    for(long lev=0;lev<numLocalLevels;lev++)
+    for(size_t lev=0;lev<numLocalLevels;lev++)
     {
-      vtkIdType srcId = (*it) + lev * numPointsPerLevel;
-      vtkIdType destId = (newPtId + numFilePoints) + lev * numPointsPerLevel;
+      vtkIdType srcId = static_cast<vtkIdType>((*it) + lev * numPointsPerLevel);
+      vtkIdType destId = static_cast<vtkIdType>((newPtId + numFilePoints) + lev * numPointsPerLevel);
       pointData->CopyData(pointData, srcId, destId);
     }
   }
@@ -842,16 +1105,20 @@ int vtkNetCDFCAMReader::RequestData(
   if(this->VerticalDimension != VERTICAL_DIMENSION_SINGLE_LAYER)
   {
     std::vector<float> levelData(numLocalLevels);
-    levelsVar->set_cur(beginLevel);
-    levelsVar->get(&levelData[0], numLocalLevels);
+    size_t start[] = {static_cast<size_t>(beginLevel)};
+    size_t count[] = {static_cast<size_t>(numLocalLevels)};
+    if (this->Internals->nc_err(nc_get_vara_float(this->Internals->nc_points, lonid, start, count, &levelData[0])))
+    {
+      return 0;
+    }
     vtkNew<vtkFloatArray> levelPointData;
-    levelPointData->SetName(levelsVar->name());
+    levelPointData->SetName(levName);
     levelPointData->SetNumberOfTuples(points->GetNumberOfPoints());
-    for(long j=0;j<numLocalLevels;j++)
+    for(size_t j=0;j<numLocalLevels;j++)
     {
       for(vtkIdType i=0;i<numPointsPerLevel;i++)
       {
-        levelPointData->SetValue(j*numPointsPerLevel+i, levelData[j]);
+        levelPointData->SetValue(static_cast<vtkIdType>(j*numPointsPerLevel+i), levelData[j]);
       }
     }
     output->GetPointData()->AddArray(levelPointData);
@@ -864,14 +1131,14 @@ int vtkNetCDFCAMReader::RequestData(
      // We load only one level
      numLevels != originalNumLevels)
   {
-    output->Allocate(numLocalCells);
+    output->Allocate(static_cast<vtkIdType>(numLocalCells));
   }
   else
   {
     // we have numLocalLevels points so we have (numLocalLevels-1) cells.
-    output->Allocate(numLocalCells*(numLocalLevels-1));
+    output->Allocate(static_cast<vtkIdType>(numLocalCells*(numLocalLevels-1)));
   }
-  for(long i=0;i<numLocalCells;i++)
+  for(size_t i=0;i<numLocalCells;i++)
   {
     vtkIdType pointIds[4];
     for(int j=0;j<4;j++)
@@ -883,13 +1150,13 @@ int vtkNetCDFCAMReader::RequestData(
        numLevels == originalNumLevels)
     {
       // volumetric grid
-      for(int lev=0;lev<(numLocalLevels-1);lev++)
+      for(size_t lev=0;lev<(numLocalLevels-1);lev++)
       {
         vtkIdType hexIds[8];
         for(int j=0;j<4;j++)
         {
-          hexIds[j] = pointIds[j]+lev*numPointsPerLevel;
-          hexIds[j+4] = pointIds[j]+(1+lev)*numPointsPerLevel;
+          hexIds[j] = static_cast<vtkIdType>(pointIds[j]+lev*numPointsPerLevel);
+          hexIds[j+4] = static_cast<vtkIdType>(pointIds[j]+(1+lev)*numPointsPerLevel);
         }
         output->InsertNextCell(VTK_HEXAHEDRON, 8, hexIds);
       }
@@ -916,12 +1183,12 @@ int vtkNetCDFCAMReader::RequestData(
 
 //----------------------------------------------------------------------------
 bool vtkNetCDFCAMReader::GetPartitioning(
-  int piece, int numPieces,int numLevels, int numCellsPerLevel,
-  int & beginLevel, int & endLevel, int & beginCell, int & endCell)
+  size_t piece, size_t numPieces,size_t numLevels, size_t numCellsPerLevel,
+  size_t & beginLevel, size_t & endLevel, size_t & beginCell, size_t & endCell)
 {
   // probably not the best way to partition the data but should
   // be sufficient for development.
-  if(numPieces <= 0 || piece < 0 || piece >= numPieces)
+  if(numPieces <= 0 || piece >= numPieces)
   {
     vtkErrorMacro("Bad piece information for partitioning.");
     return false;
@@ -958,21 +1225,21 @@ bool vtkNetCDFCAMReader::GetPartitioning(
 
   int levelsPerPiece = vtkMath::Ceil(numLevels/static_cast<double>(numPieces));
   int piecesPerLevel = vtkMath::Ceil(numPieces/static_cast<double>(numLevels));
-  int numOverworkedPieces = piecesPerLevel/levelsPerPiece*numLevels - numPieces;
+  size_t numOverworkedPieces = piecesPerLevel/levelsPerPiece*numLevels - numPieces;
   bool evenOverworked = (piecesPerLevel % 2 == 0 || numOverworkedPieces == 0);
   if(piece < numOverworkedPieces)
   {
     if(evenOverworked)
     {
       beginLevel = inputBeginLevel + 2*piece/piecesPerLevel;
-      int remainder = piece % (piecesPerLevel/2);
+      size_t remainder = piece % (piecesPerLevel/2);
       beginCell = remainder * numCellsPerLevel * 2 / piecesPerLevel;
       endCell = (remainder + 1)* numCellsPerLevel * 2 / piecesPerLevel;
     }
     else
     {
       beginLevel = inputBeginLevel + 2*piece/(piecesPerLevel-1);
-      int remainder = piece % ((piecesPerLevel-1)/2);
+      size_t remainder = piece % ((piecesPerLevel-1)/2);
       beginCell = remainder * numCellsPerLevel * 2 / piecesPerLevel;
       endCell = (remainder + 1)* numCellsPerLevel * 2 / piecesPerLevel;
     }
@@ -987,9 +1254,9 @@ bool vtkNetCDFCAMReader::GetPartitioning(
     }
     else
     {
-      int fakePiece = numOverworkedPieces+piece; // take into account overworked pieces
+      size_t fakePiece = numOverworkedPieces+piece; // take into account overworked pieces
       beginLevel = inputBeginLevel + fakePiece / piecesPerLevel;
-      int remainder = fakePiece % piecesPerLevel;
+      size_t remainder = fakePiece % piecesPerLevel;
       beginCell = remainder * numCellsPerLevel / piecesPerLevel;
       endCell = (remainder + 1)*numCellsPerLevel / piecesPerLevel;
     }
@@ -1022,20 +1289,6 @@ void vtkNetCDFCAMReader::PrintSelf(ostream& os, vtkIndent indent)
   os << indent << "SingleInterfaceLayer: " << this->SingleInterfaceLayer << endl;
   os << indent << "InterfaceLayerIndex: " << this->InterfaceLayerIndex << endl;
 
-  if(this->PointsFile)
-  {
-    os << indent << "PointsFile: " << this->PointsFile << endl;
-  }
-  else
-  {
-    os << indent << "PointsFile: (nullptr)" << endl;
-  }
-  if(this->ConnectivityFile)
-  {
-    os << indent << "ConnectivityFile: " << this->ConnectivityFile << endl;
-  }
-  else
-  {
-    os << indent << "ConnectivityFile: (nullptr)" << endl;
-  }
+  os << indent << "PointsFile: " << this->Internals->nc_points << endl;
+  os << indent << "ConnectivityFile: " << this->Internals->nc_connectivity << endl;
 }
diff --git a/IO/NetCDF/vtkNetCDFCAMReader.h b/IO/NetCDF/vtkNetCDFCAMReader.h
index f897c38730c..2158f8985a0 100644
--- a/IO/NetCDF/vtkNetCDFCAMReader.h
+++ b/IO/NetCDF/vtkNetCDFCAMReader.h
@@ -31,8 +31,6 @@
 #include "vtkIONetCDFModule.h" // For export macro
 #include "vtkUnstructuredGridAlgorithm.h"
 
-#include "vtk_netcdfcpp_fwd.h" // Forward declarations for vtknetcdfcpp
-
 class vtkCallbackCommand;
 class vtkDataArraySelection;
 
@@ -135,8 +133,8 @@ class VTKIONETCDF_EXPORT vtkNetCDFCAMReader : public vtkUnstructuredGridAlgorith
    * a partitioned space of levels and cells.
    */
   bool GetPartitioning(
-    int piece, int numPieces,int numCellLevels, int numCellsPerLevel,
-    int & beginCellLevel, int & endCellLevel, int & beginCell, int & endCell);
+    size_t piece, size_t numPieces,size_t numCellLevels, size_t numCellsPerLevel,
+    size_t & beginCellLevel, size_t & endCellLevel, size_t & beginCell, size_t & endCell);
 
   void BuildVarArray();
   static void SelectionCallback(vtkObject* caller, unsigned long eid,
@@ -168,7 +166,7 @@ class VTKIONETCDF_EXPORT vtkNetCDFCAMReader : public vtkUnstructuredGridAlgorith
 
   int VerticalDimension;
   double * TimeSteps;
-  long NumberOfTimeSteps;
+  size_t NumberOfTimeSteps;
   vtkDataArraySelection* PointDataArraySelection;
   vtkCallbackCommand* SelectionObserver;
 
@@ -180,15 +178,8 @@ class VTKIONETCDF_EXPORT vtkNetCDFCAMReader : public vtkUnstructuredGridAlgorith
   int InterfaceLayerIndex;
   int InterfaceLayersRange[2];
 
-
-  //@{
-  /**
-   * The NetCDF file descriptors.  nullptr indicates they haven't
-   * been opened.
-   */
-  NcFile* PointsFile;
-  NcFile* ConnectivityFile;
+  class Internal;
+  Internal *Internals;
 };
-  //@}
 
 #endif

From f3a4ec0261c0e735c8be3164a507594298162c37 Mon Sep 17 00:00:00 2001
From: Ben Boeckel <ben.boeckel@kitware.com>
Date: Wed, 3 Oct 2018 18:16:56 -0400
Subject: [PATCH 8/9] netcdf: remove mentions of netcdfcpp logic

---
 CMake/FindNetCDF.cmake | 8 +-------
 IO/NetCDF/module.cmake | 1 -
 2 files changed, 1 insertion(+), 8 deletions(-)

diff --git a/CMake/FindNetCDF.cmake b/CMake/FindNetCDF.cmake
index ce4f76cc6dc..e5471f78450 100644
--- a/CMake/FindNetCDF.cmake
+++ b/CMake/FindNetCDF.cmake
@@ -6,12 +6,11 @@
 #
 # Your package can require certain interfaces to be FOUND by setting these
 #
-#  NETCDF_CXX         - require the C++ interface and link the C++ library
 #  NETCDF_F77         - require the F77 interface and link the fortran library
 #  NETCDF_F90         - require the F90 interface and link the fortran library
 #
 # Or equivalently by calling FindNetCDF with a COMPONENTS argument containing one or
-# more of "CXX;F77;F90".
+# more of "F77;F90".
 #
 # When interfaces are requested the user has access to interface specific hints:
 #
@@ -91,10 +90,6 @@ macro (NetCDF_check_interface lang header libs)
   endif ()
 endmacro ()
 
-list (FIND NetCDF_FIND_COMPONENTS "CXX" _nextcomp)
-if (_nextcomp GREATER -1)
-  set (NETCDF_CXX 1)
-endif ()
 list (FIND NetCDF_FIND_COMPONENTS "F77" _nextcomp)
 if (_nextcomp GREATER -1)
   set (NETCDF_F77 1)
@@ -103,7 +98,6 @@ list (FIND NetCDF_FIND_COMPONENTS "F90" _nextcomp)
 if (_nextcomp GREATER -1)
   set (NETCDF_F90 1)
 endif ()
-NetCDF_check_interface (CXX netcdfcpp.h netcdf_c++)
 NetCDF_check_interface (F77 netcdf.inc  netcdff)
 NetCDF_check_interface (F90 netcdf.mod  netcdff)
 
diff --git a/IO/NetCDF/module.cmake b/IO/NetCDF/module.cmake
index c408218b69a..62c85e3e868 100644
--- a/IO/NetCDF/module.cmake
+++ b/IO/NetCDF/module.cmake
@@ -14,6 +14,5 @@ vtk_module(vtkIONetCDF
   PRIVATE_DEPENDS
     vtkCommonDataModel
     vtknetcdf
-    vtknetcdfcpp
     vtksys
   )

From 514284eef008952a414430987b8c4b282f942561 Mon Sep 17 00:00:00 2001
From: Ben Boeckel <ben.boeckel@kitware.com>
Date: Wed, 3 Oct 2018 18:17:17 -0400
Subject: [PATCH 9/9] netcdfcpp: remove

See paraview/paraview#18306
---
 ThirdParty/netcdfcpp/CMakeLists.txt           |   20 -
 ThirdParty/netcdfcpp/module.cmake             |    4 -
 ThirdParty/netcdfcpp/vtk_netcdfcpp.h.in       |   26 -
 ThirdParty/netcdfcpp/vtk_netcdfcpp_fwd.h.in   |   28 -
 .../netcdfcpp/vtknetcdfcpp/.gitattributes     |    1 -
 .../netcdfcpp/vtknetcdfcpp/CMakeLists.txt     |   39 -
 ThirdParty/netcdfcpp/vtknetcdfcpp/COPYRIGHT   |   42 -
 .../netcdfcpp/vtknetcdfcpp/README.kitware.md  |   14 -
 .../netcdfcpp/vtknetcdfcpp/cxx/ncvalues.cpp   |  331 ----
 .../netcdfcpp/vtknetcdfcpp/cxx/ncvalues.h     |  282 ---
 .../netcdfcpp/vtknetcdfcpp/cxx/netcdf.cpp     | 1658 -----------------
 .../netcdfcpp/vtknetcdfcpp/cxx/netcdfcpp.h    |  474 -----
 .../vtknetcdfcpp/cxx/vtk_netcdfcpp_mangle.h   |   25 -
 13 files changed, 2944 deletions(-)
 delete mode 100644 ThirdParty/netcdfcpp/CMakeLists.txt
 delete mode 100644 ThirdParty/netcdfcpp/module.cmake
 delete mode 100644 ThirdParty/netcdfcpp/vtk_netcdfcpp.h.in
 delete mode 100644 ThirdParty/netcdfcpp/vtk_netcdfcpp_fwd.h.in
 delete mode 100644 ThirdParty/netcdfcpp/vtknetcdfcpp/.gitattributes
 delete mode 100644 ThirdParty/netcdfcpp/vtknetcdfcpp/CMakeLists.txt
 delete mode 100644 ThirdParty/netcdfcpp/vtknetcdfcpp/COPYRIGHT
 delete mode 100644 ThirdParty/netcdfcpp/vtknetcdfcpp/README.kitware.md
 delete mode 100644 ThirdParty/netcdfcpp/vtknetcdfcpp/cxx/ncvalues.cpp
 delete mode 100644 ThirdParty/netcdfcpp/vtknetcdfcpp/cxx/ncvalues.h
 delete mode 100644 ThirdParty/netcdfcpp/vtknetcdfcpp/cxx/netcdf.cpp
 delete mode 100644 ThirdParty/netcdfcpp/vtknetcdfcpp/cxx/netcdfcpp.h
 delete mode 100644 ThirdParty/netcdfcpp/vtknetcdfcpp/cxx/vtk_netcdfcpp_mangle.h

diff --git a/ThirdParty/netcdfcpp/CMakeLists.txt b/ThirdParty/netcdfcpp/CMakeLists.txt
deleted file mode 100644
index 7b065c359e8..00000000000
--- a/ThirdParty/netcdfcpp/CMakeLists.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-vtk_module_third_party(NetCDFCPP
-  PACKAGE NetCDF
-  COMPONENTS CXX)
-
-if (VTK_USE_SYSTEM_NETCDFCPP AND NOT VTK_USE_SYSTEM_NETCDF)
-  message(FATAL_ERROR
-    "Using a system netcdfcpp with VTK's netcdf is not supported. Please set "
-    "VTK_USE_SYSTEM_NETCDF as well so that the same netcdf library is used "
-    "everywhere in VTK.")
-endif ()
-
-configure_file(
-  "${CMAKE_CURRENT_SOURCE_DIR}/vtk_netcdfcpp_fwd.h.in"
-  "${CMAKE_CURRENT_BINARY_DIR}/vtk_netcdfcpp_fwd.h")
-if (NOT VTK_INSTALL_NO_DEVELOPMENT)
-  install(
-    FILES       "${CMAKE_CURRENT_BINARY_DIR}/vtk_netcdfcpp_fwd.h"
-    DESTINATION "${VTK_INSTALL_INCLUDE_DIR}"
-    COMPONENT   Development)
-endif ()
diff --git a/ThirdParty/netcdfcpp/module.cmake b/ThirdParty/netcdfcpp/module.cmake
deleted file mode 100644
index 7ed84e77d2c..00000000000
--- a/ThirdParty/netcdfcpp/module.cmake
+++ /dev/null
@@ -1,4 +0,0 @@
-vtk_module(vtknetcdfcpp
-  DEPENDS
-    vtknetcdf
-  EXCLUDE_FROM_WRAPPING)
diff --git a/ThirdParty/netcdfcpp/vtk_netcdfcpp.h.in b/ThirdParty/netcdfcpp/vtk_netcdfcpp.h.in
deleted file mode 100644
index 60c26996f48..00000000000
--- a/ThirdParty/netcdfcpp/vtk_netcdfcpp.h.in
+++ /dev/null
@@ -1,26 +0,0 @@
-/*=========================================================================
-
-  Program:   Visualization Toolkit
-  Module:    vtk_netcdfcxx.h
-
-  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
-  All rights reserved.
-  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.
-
-     This software is distributed WITHOUT ANY WARRANTY; without even
-     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-     PURPOSE.  See the above copyright notice for more information.
-
-=========================================================================*/
-#ifndef vtk_netcdfcpp_h
-#define vtk_netcdfcpp_h
-
-/* Use the netcdfcpp library configured for VTK.  */
-#cmakedefine VTK_USE_SYSTEM_NETCDFCPP
-#ifdef VTK_USE_SYSTEM_NETCDFCPP
-# include <netcdfcpp.h>
-#else
-# include <vtknetcdfcpp/netcdfcpp.h>
-#endif
-
-#endif
diff --git a/ThirdParty/netcdfcpp/vtk_netcdfcpp_fwd.h.in b/ThirdParty/netcdfcpp/vtk_netcdfcpp_fwd.h.in
deleted file mode 100644
index d58984971f9..00000000000
--- a/ThirdParty/netcdfcpp/vtk_netcdfcpp_fwd.h.in
+++ /dev/null
@@ -1,28 +0,0 @@
-/*=========================================================================
-
-  Program:   Visualization Toolkit
-  Module:    vtk_netcdfcxx_fwd.h
-
-  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
-  All rights reserved.
-  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.
-
-     This software is distributed WITHOUT ANY WARRANTY; without even
-     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-     PURPOSE.  See the above copyright notice for more information.
-
-=========================================================================*/
-#ifndef vtk_netcdfcpp_fwd_h
-#define vtk_netcdfcpp_fwd_h
-
-/* Use the netcdfcpp library configured for VTK.  */
-#cmakedefine VTK_USE_SYSTEM_NETCDFCPP
-#ifndef VTK_USE_SYSTEM_NETCDFCPP
-# include <vtknetcdfcpp/vtk_netcdfcpp_mangle.h>
-#endif
-
-class NcDim;
-class NcFile;
-class NcVar;
-
-#endif
diff --git a/ThirdParty/netcdfcpp/vtknetcdfcpp/.gitattributes b/ThirdParty/netcdfcpp/vtknetcdfcpp/.gitattributes
deleted file mode 100644
index 361509ed706..00000000000
--- a/ThirdParty/netcdfcpp/vtknetcdfcpp/.gitattributes
+++ /dev/null
@@ -1 +0,0 @@
-*   -whitespace
diff --git a/ThirdParty/netcdfcpp/vtknetcdfcpp/CMakeLists.txt b/ThirdParty/netcdfcpp/vtknetcdfcpp/CMakeLists.txt
deleted file mode 100644
index 4ec43f2f6b1..00000000000
--- a/ThirdParty/netcdfcpp/vtknetcdfcpp/CMakeLists.txt
+++ /dev/null
@@ -1,39 +0,0 @@
-project(vtknetcdfcpp CXX)
-
-vtk_add_library(vtknetcdfcpp
-  cxx/netcdf.cpp
-  cxx/ncvalues.cpp)
-vtk_module_load(vtknetcdf)
-target_link_libraries(vtknetcdfcpp
-  PUBLIC
-    ${vtknetcdf_LIBRARIES})
-
-include(GenerateExportHeader)
-generate_export_header(vtknetcdfcpp
-  EXPORT_MACRO_NAME VTKNETCDFCPP_EXPORT)
-target_include_directories(vtknetcdfcpp
-  PUBLIC
-    $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}>)
-
-set(headers
-  cxx/ncvalues.h
-  cxx/netcdfcpp.h
-  cxx/vtk_netcdfcpp_mangle.h)
-
-foreach (header IN LISTS headers)
-  get_filename_component(header_name "${header}" NAME)
-  configure_file(
-    "${CMAKE_CURRENT_SOURCE_DIR}/${header}"
-    "${CMAKE_CURRENT_BINARY_DIR}/${header_name}"
-    COPYONLY)
-endforeach ()
-
-list(APPEND headers
-  "${CMAKE_CURRENT_BINARY_DIR}/vtknetcdfcpp_export.h")
-
-if (NOT VTK_INSTALL_NO_DEVELOPMENT)
-  install(
-    FILES       ${headers}
-    DESTINATION "${VTK_INSTALL_INCLUDE_DIR}/vtknetcdfcpp"
-    COMPONENT   Development)
-endif ()
diff --git a/ThirdParty/netcdfcpp/vtknetcdfcpp/COPYRIGHT b/ThirdParty/netcdfcpp/vtknetcdfcpp/COPYRIGHT
deleted file mode 100644
index e2182476706..00000000000
--- a/ThirdParty/netcdfcpp/vtknetcdfcpp/COPYRIGHT
+++ /dev/null
@@ -1,42 +0,0 @@
-/*! \file
-The NetCDF Copyright.
-
-\page copyright Copyright
-
-Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 University
-Corporation for Atmospheric Research/Unidata.
-
-Portions of this software were developed by the Unidata Program at the 
-University Corporation for Atmospheric Research.
-
-Access and use of this software shall impose the following obligations
-and understandings on the user. The user is granted the right, without
-any fee or cost, to use, copy, modify, alter, enhance and distribute
-this software, and any derivative works thereof, and its supporting
-documentation for any purpose whatsoever, provided that this entire
-notice appears in all copies of the software, derivative works and
-supporting documentation.  Further, UCAR requests that the user credit
-UCAR/Unidata in any publications that result from the use of this
-software or in any product that includes this software, although this
-is not an obligation. The names UCAR and/or Unidata, however, may not
-be used in any advertising or publicity to endorse or promote any
-products or commercial entity unless specific written permission is
-obtained from UCAR/Unidata. The user also understands that
-UCAR/Unidata is not obligated to provide the user with any support,
-consulting, training or assistance of any kind with regard to the use,
-operation and performance of this software nor to provide the user
-with any updates, revisions, new versions or "bug fixes."
-
-THIS SOFTWARE IS PROVIDED BY UCAR/UNIDATA "AS IS" AND ANY EXPRESS OR
-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL UCAR/UNIDATA BE LIABLE FOR ANY SPECIAL,
-INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
-FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
-NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
-WITH THE ACCESS, USE OR PERFORMANCE OF THIS SOFTWARE.
-*/
-
-
-
diff --git a/ThirdParty/netcdfcpp/vtknetcdfcpp/README.kitware.md b/ThirdParty/netcdfcpp/vtknetcdfcpp/README.kitware.md
deleted file mode 100644
index 66c265725c5..00000000000
--- a/ThirdParty/netcdfcpp/vtknetcdfcpp/README.kitware.md
+++ /dev/null
@@ -1,14 +0,0 @@
-# NetCDF-3 C++ for for VTK
-
-This directory contains the NetCDF-3 C++ library with changes to support
-embedding it VTK. This includes changes made primarily to the build system to
-allow it to be embedded into another source tree as well as a header to
-facilitate mangling of the symbols to avoid conflicts with other copies of the
-library within a single process.
-
-  * Add attributes to pass commit checks within VTK.
-  * Removal of `config.h` since none of its symbols are used.
-  * Add a CMake build system to the project.
-  * Export symbols for Windows support.
-  * Mangle all exported symbols to have a `vtknetcdfcxx_` prefix.
-  * Use `override` where necessary.
diff --git a/ThirdParty/netcdfcpp/vtknetcdfcpp/cxx/ncvalues.cpp b/ThirdParty/netcdfcpp/vtknetcdfcpp/cxx/ncvalues.cpp
deleted file mode 100644
index 27d62b27d83..00000000000
--- a/ThirdParty/netcdfcpp/vtknetcdfcpp/cxx/ncvalues.cpp
+++ /dev/null
@@ -1,331 +0,0 @@
-/*********************************************************************
- *   Copyright 1992, University Corporation for Atmospheric Research
- *   See netcdf/README file for copying and redistribution conditions.
- *
- *   Purpose:	implementation of classes of typed arrays for netCDF
- *
- *   $Header: /upc/share/CVS/netcdf-3/cxx/ncvalues.cpp,v 1.12 2008/03/05 16:45:32 russ Exp $
- *********************************************************************/
-
-// #include <config.h>
-#include <iostream>
-#include <string>
-#include <cstring>
-
-#include "ncvalues.h"
-
-NcValues::NcValues( void ) : the_type(ncNoType), the_number(0)
-{}
-
-NcValues::NcValues(NcType type, long num)
-	: the_type(type), the_number(num)
-{}
-
-NcValues::~NcValues( void )
-{}
-
-long NcValues::num( void )
-{
-    return the_number;
-}    
-
-std::ostream& operator<< (std::ostream& os, const NcValues& vals)
-{
-    return vals.print(os);
-}
-
-implement(NcValues,ncbyte)
-implement(NcValues,char)
-implement(NcValues,short)
-implement(NcValues,int)
-implement(NcValues,nclong)
-implement(NcValues,long)
-implement(NcValues,float)
-implement(NcValues,double)
-
-Ncbytes_for_one_implement(ncbyte)
-Ncbytes_for_one_implement(char)
-Ncbytes_for_one_implement(short)
-Ncbytes_for_one_implement(int)
-Ncbytes_for_one_implement(nclong)
-Ncbytes_for_one_implement(long)
-Ncbytes_for_one_implement(float)
-Ncbytes_for_one_implement(double)
-
-as_ncbyte_implement(short)
-as_ncbyte_implement(int)
-as_ncbyte_implement(nclong)
-as_ncbyte_implement(long)
-as_ncbyte_implement(float)
-as_ncbyte_implement(double)
-
-inline ncbyte NcValues_char::as_ncbyte( long n ) const
-{
-    return the_values[n];
-}
-
-inline ncbyte NcValues_ncbyte::as_ncbyte( long n ) const
-{
-    return the_values[n];
-}
-
-as_char_implement(short)
-as_char_implement(int)
-as_char_implement(nclong)
-as_char_implement(long)
-as_char_implement(float)
-as_char_implement(double)
-
-inline char NcValues_ncbyte::as_char( long n ) const
-{
-    return the_values[n] > CHAR_MAX ? ncBad_char : (char) the_values[n];
-}
-
-inline char NcValues_char::as_char( long n ) const
-{
-    return the_values[n];
-}
-
-as_short_implement(int)
-as_short_implement(nclong)
-as_short_implement(long)
-as_short_implement(float)
-as_short_implement(double)
-
-inline short NcValues_ncbyte::as_short( long n ) const
-{
-    return the_values[n];
-}
-
-inline short NcValues_char::as_short( long n ) const
-{
-    return the_values[n];
-}
-
-inline short NcValues_short::as_short( long n ) const
-{
-    return the_values[n];
-}
-
-
-as_int_implement(float)
-as_int_implement(double)
-
-inline int NcValues_ncbyte::as_int( long n ) const
-{
-    return the_values[n];
-}
-
-inline int NcValues_char::as_int( long n ) const
-{
-    return the_values[n];
-}
-
-inline int NcValues_short::as_int( long n ) const
-{
-    return the_values[n];
-}
-
-inline int NcValues_int::as_int( long n ) const
-{
-    return the_values[n];
-}
-
-inline int NcValues_nclong::as_int( long n ) const
-{
-    return the_values[n];
-}
-
-inline int NcValues_long::as_int( long n ) const
-{
-    return the_values[n];
-}
-
-as_nclong_implement(float)
-as_nclong_implement(double)
-
-inline nclong NcValues_ncbyte::as_nclong( long n ) const
-{
-    return the_values[n];
-}
-
-inline nclong NcValues_char::as_nclong( long n ) const
-{
-    return the_values[n];
-}
-
-inline nclong NcValues_short::as_nclong( long n ) const
-{
-    return the_values[n];
-}
-
-inline nclong NcValues_int::as_nclong( long n ) const
-{
-    return the_values[n];
-}
-
-inline nclong NcValues_nclong::as_nclong( long n ) const
-{
-    return the_values[n];
-}
-
-inline nclong NcValues_long::as_nclong( long n ) const
-{
-    return the_values[n];
-}
-
-as_long_implement(float)
-as_long_implement(double)
-
-inline long NcValues_ncbyte::as_long( long n ) const
-{
-    return the_values[n];
-}
-
-inline long NcValues_char::as_long( long n ) const
-{
-    return the_values[n];
-}
-
-inline long NcValues_short::as_long( long n ) const
-{
-    return the_values[n];
-}
-
-inline long NcValues_int::as_long( long n ) const
-{
-    return the_values[n];
-}
-
-inline long NcValues_nclong::as_long( long n ) const
-{
-    return the_values[n];
-}
-
-inline long NcValues_long::as_long( long n ) const
-{
-    return the_values[n];
-}
-
-as_float_implement(ncbyte)
-as_float_implement(char)
-as_float_implement(short)
-as_float_implement(int)
-as_float_implement(nclong)
-as_float_implement(long)
-as_float_implement(float)
-as_float_implement(double)
-
-as_double_implement(ncbyte)
-as_double_implement(char)
-as_double_implement(short)
-as_double_implement(int)
-as_double_implement(nclong)
-as_double_implement(long)
-as_double_implement(float)
-as_double_implement(double)
-
-as_string_implement(short)
-as_string_implement(int)
-as_string_implement(nclong)
-as_string_implement(long)
-as_string_implement(float)
-as_string_implement(double)
-
-inline char* NcValues_ncbyte::as_string( long n ) const
-{
-    char* s = new char[the_number + 1];
-    s[the_number] = '\0';
-    strncpy(s, (const char*)the_values + n, (int)the_number);
-    return s;
-}
-
-inline char* NcValues_char::as_string( long n ) const
-{
-    char* s = new char[the_number + 1];
-    s[the_number] = '\0';
-    strncpy(s, (const char*)the_values + n, (int)the_number);
-    return s;
-}
-
-std::ostream& NcValues_short::print(std::ostream& os) const
-{
-    for(int i = 0; i < the_number - 1; i++)
-      os << the_values[i] << ", ";
-    if (the_number > 0)
-      os << the_values[the_number-1] ;
-    return os;
-}
-
-std::ostream& NcValues_int::print(std::ostream& os) const
-{
-    for(int i = 0; i < the_number - 1; i++)
-      os << the_values[i] << ", ";
-    if (the_number > 0)
-      os << the_values[the_number-1] ;
-    return os;
-}
-
-std::ostream& NcValues_nclong::print(std::ostream& os) const
-{
-    for(int i = 0; i < the_number - 1; i++)
-      os << the_values[i] << ", ";
-    if (the_number > 0)
-      os << the_values[the_number-1] ;
-    return os;
-}
-
-std::ostream& NcValues_long::print(std::ostream& os) const
-{
-    for(int i = 0; i < the_number - 1; i++)
-      os << the_values[i] << ", ";
-    if (the_number > 0)
-      os << the_values[the_number-1] ;
-    return os;
-}
-
-std::ostream& NcValues_ncbyte::print(std::ostream& os) const
-{
-    for(int i = 0; i < the_number - 1; i++)
-      os << the_values[i] << ", ";
-    if (the_number > 0)
-      os << the_values[the_number-1] ;
-    return os;
-}
-
-std::ostream& NcValues_char::print(std::ostream& os) const
-{
-    os << '"';
-    long len = the_number;
-    while (the_values[--len] == '\0') // don't output trailing null bytes
-	;
-    for(int i = 0; i <= len; i++)
-	os << the_values[i] ;
-    os << '"';
-    
-    return os;
-}
-
-std::ostream& NcValues_float::print(std::ostream& os) const
-{
-    std::streamsize save=os.precision();
-    os.precision(7);
-    for(int i = 0; i < the_number - 1; i++)
-      os << the_values[i] << ", ";
-    if (the_number > 0)
-      os << the_values[the_number-1] ;
-    os.precision(save);
-    return os;
-}
-
-std::ostream& NcValues_double::print(std::ostream& os) const
-{
-    std::streamsize save=os.precision();
-    os.precision(15);
-    for(int i = 0; i < the_number - 1; i++)
-      os << the_values[i] << ", ";
-    if (the_number > 0)
-      os << the_values[the_number-1];
-    os.precision(save);
-    return os;
-}
diff --git a/ThirdParty/netcdfcpp/vtknetcdfcpp/cxx/ncvalues.h b/ThirdParty/netcdfcpp/vtknetcdfcpp/cxx/ncvalues.h
deleted file mode 100644
index 022de15d0ee..00000000000
--- a/ThirdParty/netcdfcpp/vtknetcdfcpp/cxx/ncvalues.h
+++ /dev/null
@@ -1,282 +0,0 @@
-/*********************************************************************
- *   Copyright 1992, University Corporation for Atmospheric Research
- *   See netcdf/README file for copying and redistribution conditions.
- *
- *   Purpose:	interface for classes of typed arrays for netCDF
- *
- *   $Header: /upc/share/CVS/netcdf-3/cxx/ncvalues.h,v 1.7 2006/07/26 21:12:06 russ Exp $
- *********************************************************************/
-
-#ifndef Ncvalues_def
-#define Ncvalues_def
-
-#include "vtk_netcdfcpp_mangle.h"
-#include "vtknetcdfcpp_export.h"
-
-#include <iostream>
-#include <sstream>
-#include <limits.h>
-#include "vtk_netcdf.h"
-
-// Documentation warned this might change and now it has, for
-// consistency with C interface 
-typedef signed char ncbyte;
-
-#define NC_UNSPECIFIED ((nc_type)0)
-
-// C++ interface dates from before netcdf-3, still uses some netcdf-2 names
-#ifdef NO_NETCDF_2
-#define NC_LONG NC_INT
-#define FILL_LONG NC_FILL_INT
-typedef int nclong;
-#define	NC_FATAL	1
-#define	NC_VERBOSE	2
-#endif
-
-enum NcType 
-{
-  ncNoType = NC_UNSPECIFIED, 
-  ncByte = NC_BYTE, 
-  ncChar = NC_CHAR, 
-  ncShort = NC_SHORT, 
-  ncInt = NC_INT,
-  ncLong = NC_LONG,		// deprecated, someday want to use for 64-bit ints
-  ncFloat = NC_FLOAT, 
-  ncDouble = NC_DOUBLE
-};
-
-#define ncBad_ncbyte ncBad_byte
-static const ncbyte ncBad_byte = NC_FILL_BYTE;
-static const char ncBad_char = NC_FILL_CHAR;
-static const short ncBad_short = NC_FILL_SHORT;
-static const nclong ncBad_nclong = FILL_LONG; // deprecated
-static const int ncBad_int = NC_FILL_INT;
-static const long ncBad_long = FILL_LONG; // deprecated
-static const float ncBad_float = NC_FILL_FLOAT;
-static const double ncBad_double = NC_FILL_DOUBLE;
-
-// macros to glue tokens together to form new names (used to be in generic.h)
-#define name2(a,b) a ## b
-#define declare(clas,t)        name2(clas,declare)(t)
-#define implement(clas,t)      name2(clas,implement)(t)
-// This is the same as the name2 macro, but we need to define our own
-// version since rescanning something generated with the name2 macro
-// won't necessarily cause name2 to be expanded again.
-#define makename2(z, y)		makename2_x(z, y)
-#define makename2_x(z, y)		z##y
-
-#define NcVal(TYPE) makename2(NcValues_,TYPE)
-
-#define NcValuesdeclare(TYPE)						      \
-class NcVal(TYPE) : public NcValues					      \
-{									      \
-  public:								      \
-    NcVal(TYPE)( void );						      \
-    NcVal(TYPE)(long num);						      \
-    NcVal(TYPE)(long num, const TYPE* vals);				      \
-    NcVal(TYPE)(const NcVal(TYPE)&);					      \
-    virtual NcVal(TYPE)& operator=(const NcVal(TYPE)&);			      \
-    virtual ~NcVal(TYPE)( void ) override;				      \
-    void* base( void ) const override;					      \
-    int bytes_for_one( void ) const override;				      \
-    ncbyte as_ncbyte( long n ) const override;				      \
-    char as_char( long n ) const override;				      \
-    short as_short( long n ) const override;				      \
-    int as_int( long n ) const override;				      \
-    int as_nclong( long n ) const override;				      \
-    long as_long( long n ) const override;				      \
-    float as_float( long n ) const override;				      \
-    double as_double( long n ) const override;				      \
-    char* as_string( long n ) const override;				      \
-    virtual int invalid( void ) const;					      \
-  private:								      \
-    TYPE* the_values;							      \
-    std::ostream& print(std::ostream&) const override;			      \
-};
-
-#define NcTypeEnum(TYPE) makename2(_nc__,TYPE)
-#define _nc__ncbyte ncByte
-#define _nc__char ncChar
-#define _nc__short ncShort
-#define _nc__int ncInt
-#define _nc__nclong ncLong
-#define _nc__long ncLong
-#define _nc__float ncFloat
-#define _nc__double ncDouble
-#define NcValuesimplement(TYPE)						      \
-NcVal(TYPE)::NcVal(TYPE)( void )					      \
-	: NcValues(NcTypeEnum(TYPE), 0), the_values(0)			      \
-{}									      \
-									      \
-NcVal(TYPE)::NcVal(TYPE)(long num, const TYPE* vals)			      \
-	: NcValues(NcTypeEnum(TYPE), num)				      \
-{									      \
-    the_values = new TYPE[num];						      \
-    for(int i = 0; i < num; i++)					      \
-      the_values[i] = vals[i];						      \
-}									      \
-									      \
-NcVal(TYPE)::NcVal(TYPE)(long num)					      \
-	: NcValues(NcTypeEnum(TYPE), num), the_values(new TYPE[num])	      \
-{}									      \
-									      \
-NcVal(TYPE)::NcVal(TYPE)(const NcVal(TYPE)& v) :			      \
-    NcValues(v)								      \
-{									      \
-    delete[] the_values;						      \
-    the_values = new TYPE[v.the_number];				      \
-    for(int i = 0; i < v.the_number; i++)				      \
-      the_values[i] = v.the_values[i];					      \
-}									      \
-									      \
-NcVal(TYPE)& NcVal(TYPE)::operator=(const NcVal(TYPE)& v)		      \
-{									      \
-    if ( &v != this) {							      \
-      NcValues::operator=(v);						      \
-      delete[] the_values;						      \
-      the_values = new TYPE[v.the_number];				      \
-      for(int i = 0; i < v.the_number; i++)				      \
-        the_values[i] = v.the_values[i];				      \
-    }									      \
-    return *this;							      \
-}									      \
-									      \
-void* NcVal(TYPE)::base( void ) const					      \
-{									      \
-    return the_values;							      \
-}									      \
-									      \
-NcVal(TYPE)::~NcVal(TYPE)( void )					      \
-{									      \
-    delete[] the_values;						      \
-}									      \
-									      \
-int NcVal(TYPE)::invalid( void ) const					      \
-{									      \
-    for(int i=0;i<the_number;i++)					      \
-	if (the_values[i] == makename2(ncBad_,TYPE)) return 1; 	       	      \
-    return 0;                                                                 \
-}                                                                             \
-
-
-#define Ncbytes_for_one_implement(TYPE)					      \
-int NcVal(TYPE)::bytes_for_one( void ) const				      \
-{									      \
-    return sizeof(TYPE); 			                              \
-}
-
-#define as_ncbyte_implement(TYPE)					      \
-ncbyte NcVal(TYPE)::as_ncbyte( long n ) const				      \
-{									      \
-    if (the_values[n] < 0 || the_values[n] > UCHAR_MAX)		              \
-      return ncBad_byte;						      \
-    return (ncbyte) the_values[n];			                      \
-}
-
-#define as_char_implement(TYPE)						      \
-char NcVal(TYPE)::as_char( long n ) const				      \
-{									      \
-    if (the_values[n] < CHAR_MIN || the_values[n] > CHAR_MAX)		      \
-      return ncBad_char;						      \
-    return (char) the_values[n];					      \
-}
-
-#define as_short_implement(TYPE)					      \
-short NcVal(TYPE)::as_short( long n ) const				      \
-{									      \
-    if (the_values[n] < SHRT_MIN || the_values[n] > SHRT_MAX)		      \
-      return ncBad_short;						      \
-    return (short) the_values[n];				              \
-}
-
-#define NCINT_MIN INT_MIN
-#define NCINT_MAX INT_MAX
-#define as_int_implement(TYPE)					      \
-int NcVal(TYPE)::as_int( long n ) const				      \
-{									      \
-    if (the_values[n] < NCINT_MIN || the_values[n] > NCINT_MAX)	      \
-      return ncBad_int;						      \
-    return (int) the_values[n];				              \
-}
-
-#define NCLONG_MIN INT_MIN
-#define NCLONG_MAX INT_MAX
-#define as_nclong_implement(TYPE)					      \
-nclong NcVal(TYPE)::as_nclong( long n ) const				      \
-{									      \
-    if (the_values[n] < NCLONG_MIN || the_values[n] > NCLONG_MAX)	      \
-      return ncBad_nclong;						      \
-    return (nclong) the_values[n];				              \
-}
-
-#define as_long_implement(TYPE)					              \
-long NcVal(TYPE)::as_long( long n ) const				      \
-{									      \
-    if (the_values[n] < LONG_MIN || the_values[n] > LONG_MAX)	              \
-      return ncBad_long;						      \
-    return (long) the_values[n];		       	                      \
-}
-
-#define as_float_implement(TYPE)					      \
-inline float NcVal(TYPE)::as_float( long n ) const			      \
-{									      \
-    return (float) the_values[n];				              \
-}
-
-#define as_double_implement(TYPE)					      \
-inline double NcVal(TYPE)::as_double( long n ) const			      \
-{									      \
-    return (double) the_values[n];				              \
-}
-
-#define as_string_implement(TYPE)					      \
-char* NcVal(TYPE)::as_string( long n ) const				      \
-{									      \
-    char* s = new char[32];                                                   \
-    std::ostringstream ostr;                                                  \
-    ostr << the_values[n];                                            \
-    ostr.str().copy(s, std::string::npos);                                               \
-    s[ostr.str().length()] = 0;                                                     \
-    return s;								      \
-}
-
-class NcValues			// ABC for value blocks
-{
-  public:
-    NcValues( void );
-    NcValues(NcType, long);
-    virtual ~NcValues( void );
-    virtual long num( void );
-    virtual std::ostream& print(std::ostream&) const = 0;
-    virtual void* base( void ) const = 0;
-    virtual int bytes_for_one( void ) const = 0;
-
-    // The following member functions provide conversions from the value
-    // type to a desired basic type.  If the value is out of range, the
-    // default "fill-value" for the appropriate type is returned.
-    virtual ncbyte as_ncbyte( long n ) const = 0; // nth value as a byte
-    virtual char as_char( long n ) const = 0;     // nth value as char
-    virtual short as_short( long n ) const = 0;   // nth value as short
-    virtual int    as_int( long n ) const = 0;    // nth value as int
-    virtual int    as_nclong( long n ) const = 0; // nth value as nclong
-    virtual long as_long( long n ) const = 0;     // nth value as long
-    virtual float as_float( long n ) const = 0;   // nth value as floating-point
-    virtual double as_double( long n ) const = 0; // nth value as double
-    virtual char* as_string( long n ) const = 0;  // value as string
-    
-  protected:
-    NcType the_type;
-    long the_number;
-    friend std::ostream& operator<< (std::ostream&, const NcValues&);
-};
-
-declare(NcValues,ncbyte)
-declare(NcValues,char)
-declare(NcValues,short)
-declare(NcValues,int)
-declare(NcValues,nclong)
-declare(NcValues,long)
-declare(NcValues,float)
-declare(NcValues,double)
-
-#endif
diff --git a/ThirdParty/netcdfcpp/vtknetcdfcpp/cxx/netcdf.cpp b/ThirdParty/netcdfcpp/vtknetcdfcpp/cxx/netcdf.cpp
deleted file mode 100644
index 4393e077c41..00000000000
--- a/ThirdParty/netcdfcpp/vtknetcdfcpp/cxx/netcdf.cpp
+++ /dev/null
@@ -1,1658 +0,0 @@
-/*********************************************************************
- *   Copyright 1992, University Corporation for Atmospheric Research
- *   See netcdf/README file for copying and redistribution conditions.
- *
- *   Purpose:	Implements class interface for netCDF over C interface
- *
- *   $Header: /upc/share/CVS/netcdf-3/cxx/netcdf.cpp,v 1.18 2009/03/10 15:20:54 russ Exp $
- *********************************************************************/
-
-// #include <config.h>
-#include <string.h>
-#include <stdlib.h>
-#include <iostream>
-#include "netcdfcpp.h"
-
-#ifndef TRUE
-#define TRUE 1
-#define FALSE 0
-#endif
-
-static const int ncGlobal = NC_GLOBAL; // psuedo-variable for global attributes
-
-static const int ncBad = -1;	// failure return for netCDF C interface 
-
-NcFile::~NcFile( void )
-{
-    (void) close();
-}
-
-NcBool NcFile::is_valid( void ) const
-{
-    return the_id != ncBad;
-}
-
-int NcFile::num_dims( void ) const
-{
-    int num = 0;
-    if (is_valid())
-      NcError::set_err(
-		       nc_inq_ndims(the_id, &num)
-		       );
-    return num;
-}
-
-int NcFile::num_vars( void ) const
-{
-    int num = 0;
-    if (is_valid())
-      NcError::set_err(
-		       nc_inq_nvars(the_id, &num)
-		       );
-    return num;
-}
-
-int NcFile::num_atts( void ) const
-{
-    int num = 0;
-    if (is_valid())
-      NcError::set_err(
-		       nc_inq_natts(the_id, &num)
-		       );
-    return num;
-}
-
-NcDim* NcFile::get_dim( NcToken name ) const
-{
-    int dimid;
-    if(NcError::set_err(
-			nc_inq_dimid(the_id, name, &dimid)
-			) != NC_NOERR)
-	return 0;
-    return get_dim(dimid);
-}
-
-NcVar* NcFile::get_var( NcToken name ) const
-{
-    int varid;
-    if(NcError::set_err(
-			nc_inq_varid(the_id, name, &varid)
-			) != NC_NOERR)
-	return 0;
-    return get_var(varid);
-}
-
-NcAtt* NcFile::get_att( NcToken aname ) const
-{
-    return is_valid() ? globalv->get_att(aname) : 0;
-}
-
-NcDim* NcFile::get_dim( int i ) const
-{
-    if (! is_valid() || i < 0 || i >= num_dims())
-      return 0;
-    return dimensions[i];
-}
-
-NcVar* NcFile::get_var( int i ) const
-{
-    if (! is_valid() || i < 0 || i >= num_vars())
-      return 0;
-    return variables[i];
-}
-
-NcAtt* NcFile::get_att( int n ) const
-{
-    return is_valid() ? globalv->get_att(n) : 0;
-}
-
-NcDim* NcFile::rec_dim( ) const
-{
-    if (! is_valid())
-      return 0;
-    int recdim;
-    if(NcError::set_err(
-			nc_inq_unlimdim(the_id, &recdim)
-			) != NC_NOERR)
-	return 0;
-    return get_dim(recdim);
-}
-
-NcDim* NcFile::add_dim(NcToken name, long size)
-{
-    if (!is_valid() || !define_mode())
-      return 0;
-    int n = num_dims();
-    NcDim* dimp = new NcDim(this, name, size);
-    dimensions[n] = dimp;	// for garbage collection on close()
-    return dimp;
-}
-
-NcDim* NcFile::add_dim(NcToken name)
-{
-    return add_dim(name, NC_UNLIMITED);
-}
-
-// To create scalar, 1-dimensional, ..., 5-dimensional variables, just supply
-// as many dimension arguments as necessary
-
-NcVar* NcFile::add_var(NcToken name, NcType type, // scalar to 5D var
-			    const NcDim* dim0,
-			    const NcDim* dim1,
-			    const NcDim* dim2,
-			    const NcDim* dim3,
-			    const NcDim* dim4)
-{
-    if (!is_valid() || !define_mode())
-      return 0;
-    int dims[5];
-    int ndims = 0;
-    if (dim0) {
-	ndims++;
-	dims[0] = dim0->id();
-	if (dim1) {
-	    ndims++;
-	    dims[1] = dim1->id();
-	    if (dim2) {
-		ndims++;
-		dims[2] = dim2->id();
-		if (dim3) {
-		    ndims++;
-		    dims[3] = dim3->id();
-		    if (dim4) {
-			ndims++;
-			dims[4] = dim4->id();
-		    }
-		}
-	    }
-	}
-    }
-    int n = num_vars();
-    int varid;
-    if(NcError::set_err(
-			nc_def_var(the_id, name, (nc_type) type, ndims, dims, &varid)
-			) != NC_NOERR)
-	return 0;
-    NcVar* varp =
-      new NcVar(this, varid);
-    variables[n] = varp;
-    return varp;
-}
-
-// For variables with more than 5 dimensions, use n-dimensional interface
-// with vector of dimensions.
-
-NcVar* NcFile::add_var(NcToken name, NcType type, int ndims, const NcDim** dims)
-{
-    if (!is_valid() || !define_mode())
-      return 0;
-    int* dimids = new int[ndims];
-    for (int i=0; i < ndims; i++)
-      dimids[i] = dims[i]->id();
-    int n = num_vars();
-    int varid;
-    if(NcError::set_err(
-			nc_def_var(the_id, name, (nc_type) type, ndims, dimids, &varid)
-			) != NC_NOERR)
-	return 0;
-    NcVar* varp =
-      new NcVar(this, varid);
-    variables[n] = varp;
-    delete [] dimids;
-    return varp;
-}
-
-#define NcFile_add_scalar_att(TYPE)					      \
-NcBool NcFile::add_att(NcToken aname, TYPE val)				      \
-{									      \
-    return globalv->add_att(aname, val);				      \
-}
-
-NcFile_add_scalar_att(char)
-NcFile_add_scalar_att(ncbyte)
-NcFile_add_scalar_att(short)
-NcFile_add_scalar_att(int)
-NcFile_add_scalar_att(long)
-NcFile_add_scalar_att(float)
-NcFile_add_scalar_att(double)
-NcFile_add_scalar_att(const char*)
-
-#define NcFile_add_vector_att(TYPE)					      \
-NcBool NcFile::add_att(NcToken aname, int n, const TYPE* val)		      \
-{									      \
-    return globalv->add_att(aname, n, val);				      \
-}
-
-NcFile_add_vector_att(char)
-NcFile_add_vector_att(ncbyte)
-NcFile_add_vector_att(short)
-NcFile_add_vector_att(int)
-NcFile_add_vector_att(long)
-NcFile_add_vector_att(float)
-NcFile_add_vector_att(double)
-
-NcBool NcFile::set_fill( FillMode a_mode )
-{
-  int prev_mode;
-  if (NcError::set_err(
-		       nc_set_fill(the_id, a_mode, &prev_mode)
-		       ) == NC_NOERR) {
-    the_fill_mode = a_mode;
-    return TRUE;
-  }
-  return FALSE;
-}
-
-NcFile::FillMode NcFile::get_fill( void ) const
-{
-    return the_fill_mode;
-}
-
-NcFile::FileFormat NcFile::get_format( void ) const
-{
-    int the_format;
-    NcError::set_err(
-		     nc_inq_format(the_id, &the_format)
-		     );
-    switch (the_format) {
-    case NC_FORMAT_CLASSIC:
-	return Classic;
-    case NC_FORMAT_64BIT:
-	return Offset64Bits;
-    case NC_FORMAT_NETCDF4:
-	return Netcdf4;
-    case NC_FORMAT_NETCDF4_CLASSIC:
-	return Netcdf4Classic;
-    default:
-	return BadFormat;
-    }
-}
-
-NcBool NcFile::sync( void )
-{
-    if (!data_mode())
-      return 0;
-    if (NcError::set_err(
-			 nc_sync(the_id)
-			 ) != NC_NOERR)
-      return 0;
-    int i;
-    for (i = 0; i < num_dims(); i++) {
-	if (dimensions[i]->is_valid()) {
-	    dimensions[i]->sync();
-	} else {		// someone else added a new dimension
-	    dimensions[i] = new NcDim(this,i);
-	}
-    }
-    for (i = 0; i < num_vars(); i++) {
-	if (variables[i]->is_valid()) {
-	    variables[i]->sync();
-	} else {		// someone else added a new variable
-	    variables[i] = new NcVar(this,i);
-	}
-    }
-    return 1;
-}
-
-NcBool NcFile::close( void )
-{
-    int i;
-    
-    if (the_id == ncBad)
-      return 0;
-    for (i = 0; i < num_dims(); i++)
-      delete dimensions[i];
-    for (i = 0; i < num_vars(); i++)
-      delete variables[i];
-    delete [] dimensions;
-    delete [] variables;
-    delete globalv;
-    int old_id = the_id;
-    the_id = ncBad;
-    return NcError::set_err(
-			    nc_close(old_id)
-			    ) == NC_NOERR;
-}
-
-NcBool NcFile::abort( void )
-{
-    return NcError::set_err(
-			    nc_abort(the_id)
-			    ) == NC_NOERR;
-}
-
-NcBool NcFile::define_mode( void )
-{
-    if (! is_valid())
-      return FALSE;
-    if (in_define_mode)
-      return TRUE;
-    if (NcError::set_err(
-			 nc_redef(the_id)
-			 ) != NC_NOERR)
-      return FALSE;
-    in_define_mode = 1;
-    return TRUE;
-}
-
-NcBool NcFile::data_mode( void )
-{
-    if (! is_valid())
-      return FALSE;
-    if (! in_define_mode)
-      return TRUE;
-    if (NcError::set_err(
-			 nc_enddef(the_id)
-			 ) != NC_NOERR)
-      return FALSE;
-    in_define_mode = 0;
-    return TRUE;
-}
-
-int NcFile::id( void ) const
-{
-    return the_id;
-}
-
-NcFile::NcFile( const char* path, FileMode fmode, 
-		size_t* bufrsizeptr, size_t initialsize, FileFormat fformat  )
-{
-    NcError err(NcError::silent_nonfatal); // constructor must not fail
-
-    int mode = NC_NOWRITE;
-    the_fill_mode = Fill;
-    int status;
-    
-    // If the user wants a 64-bit offset format, set that flag.
-    if (fformat == Offset64Bits)
-       mode |= NC_64BIT_OFFSET;
-#ifdef USE_NETCDF4
-    else if (fformat == Netcdf4)
-       mode |= NC_NETCDF4;
-    else if (fformat == Netcdf4Classic)
-       mode |= NC_NETCDF4|NC_CLASSIC_MODEL;
-#endif
-
-    switch (fmode) {
-    case Write:
-	mode |= NC_WRITE;
-	/*FALLTHRU*/
-    case ReadOnly:
-	// use netcdf-3 interface to permit specifying tuning parameter
-	status = NcError::set_err(
-				  nc__open(path, mode, bufrsizeptr, &the_id)
-				  );
-	if(status != NC_NOERR)
-	{
-	    NcError::set_err(status);
-	    the_id =  -1;
-	}
-	in_define_mode = 0;
-	break;
-    case New:
-	mode |= NC_NOCLOBBER;
-	/*FALLTHRU*/
-    case Replace:
-	// use netcdf-3 interface to permit specifying tuning parameters
-	status = NcError::set_err(
-				  nc__create(path, mode, initialsize,
-				      bufrsizeptr, &the_id)
-				  );
-	if(status != NC_NOERR)
-	{
-	    NcError::set_err(status);
-	    the_id =  -1;
-	}
-	in_define_mode = 1;
-	break;
-    default:
-	the_id = ncBad;
-	in_define_mode = 0;
-	break;
-    }
-    if (is_valid()) {
-	dimensions = new NcDim*[NC_MAX_DIMS];
-	variables = new NcVar*[NC_MAX_VARS];
-	int i;
-	for (i = 0; i < num_dims(); i++)
-	    dimensions[i] = new NcDim(this, i);
-	for (i = 0; i < num_vars(); i++)
-	    variables[i] = new NcVar(this, i);
-	globalv = new NcVar(this, ncGlobal);
-    } else {
-	dimensions = 0;
-	variables = 0;
-	globalv = 0;
-    }
-}
-
-NcToken NcDim::name( void ) const
-{
-    return the_name;
-}
-
-long NcDim::size( void ) const
-{
-    size_t sz = 0;
-    if (the_file)
-      NcError::set_err(
-		       nc_inq_dimlen(the_file->id(), the_id, &sz)
-		       );
-    return sz;
-}
-
-NcBool NcDim::is_valid( void ) const
-{
-    return the_file->is_valid() && the_id != ncBad;
-}
-
-NcBool NcDim::is_unlimited( void ) const
-{
-    if (!the_file)
-      return FALSE;
-    int recdim;
-    NcError::set_err(
-		     nc_inq_unlimdim(the_file->id(), &recdim)
-		     );
-    return the_id == recdim;
-}
-
-NcBool NcDim::rename(NcToken newname)
-{
-    if (strlen(newname) > strlen(the_name)) {
-	if (! the_file->define_mode())
-	    return FALSE;
-    }
-    NcBool ret = NcError::set_err(
-				  nc_rename_dim(the_file->id(), the_id, newname)
-				  ) == NC_NOERR;
-    if (ret) {
-	delete [] the_name;
-	the_name = new char[1 + strlen(newname)];
-	strcpy(the_name, newname);
-    }
-    return ret;
-}
-
-int NcDim::id( void ) const
-{
-    return the_id;
-}
-
-NcBool NcDim::sync(void) 
-{    
-    char nam[NC_MAX_NAME];
-    if (the_name) {
-	delete [] the_name;
-    }
-    if (the_file && NcError::set_err(
-				     nc_inq_dimname(the_file->id(), the_id, nam)
-				     ) == NC_NOERR) {
-	the_name = new char[strlen(nam) + 1]; 
-	strcpy(the_name, nam);
-	return TRUE;
-    }
-    the_name = 0;
-    return FALSE;
-}
-
-NcDim::NcDim(NcFile* nc, int id)
-	: the_file(nc), the_id(id)
-{
-    char nam[NC_MAX_NAME];
-    if (the_file && NcError::set_err(
-				     nc_inq_dimname(the_file->id(), the_id, nam)
-				     ) == NC_NOERR) {
-	the_name = new char[strlen(nam) + 1]; 
-	strcpy(the_name, nam);
-    } else {
-	the_name = 0;
-    }
-}
-
-NcDim::NcDim(NcFile* nc, NcToken name, long sz)
-	: the_file(nc)
-{
-    size_t dimlen = sz;
-    if(NcError::set_err(
-			nc_def_dim(the_file->id(), name, dimlen, &the_id)
-			) == NC_NOERR) {
-	the_name = new char[strlen(name) + 1];
-	strcpy(the_name, name);
-    } else {
-	the_name = 0;
-    }
-}
-
-NcDim::~NcDim( void )
-{
-    delete [] the_name;
-}
-
-#define Nc_as(TYPE) name2(as_,TYPE)
-#define NcTypedComponent_as(TYPE)				          \
-TYPE NcTypedComponent::Nc_as(TYPE)( long n ) const		          \
-{								          \
-  NcValues* tmp = values();                                               \
-  TYPE rval = tmp->Nc_as(TYPE)(n);                                        \
-  delete tmp;                                                             \
-  return rval;                                                            \
-}
-NcTypedComponent_as(ncbyte)
-NcTypedComponent_as(char)
-NcTypedComponent_as(short)
-NcTypedComponent_as(int)
-NcTypedComponent_as(nclong)
-NcTypedComponent_as(long)
-NcTypedComponent_as(float)
-NcTypedComponent_as(double)
-
-char* NcTypedComponent::as_string( long n ) const
-{
-    NcValues* tmp = values();
-    char* rval = tmp->as_string(n);
-    delete tmp;
-    return rval;
-}
-
-NcTypedComponent::NcTypedComponent ( NcFile* nc )
-	: the_file(nc)
-{}
-
-NcValues* NcTypedComponent::get_space( long numVals ) const
-{
-    NcValues* valp;
-    if (numVals < 1)
-	numVals = num_vals();
-    switch (type()) {
-      case ncFloat:
-	valp = new NcValues_float(numVals);
-	break;
-      case ncDouble:
-	valp = new NcValues_double(numVals);
-	break;
-      case ncInt:
-	valp = new NcValues_int(numVals);
-	break;
-      case ncShort:
-	valp = new NcValues_short(numVals);
-	break;
-      case ncByte:
-      case ncChar:
-	valp = new NcValues_char(numVals);
-	break;
-      case ncNoType:
-      default:
-	valp = 0;
-    }
-    return valp;
-}
-
-NcVar::~NcVar( void )
-{
-    delete[] the_cur;
-    delete[] cur_rec;
-    delete[] the_name;
-}
-
-NcToken NcVar::name( void ) const
-{
-    return the_name;
-}
-
-NcType NcVar::type( void ) const
-{
-    nc_type typ;
-    NcError::set_err(
-		     nc_inq_vartype(the_file->id(), the_id, &typ)
-		     );
-    return (NcType) typ;
-}
-
-NcBool NcVar::is_valid( void ) const
-{
-    return the_file->is_valid() && the_id != ncBad;
-}
-
-int NcVar::num_dims( void ) const
-{
-    int ndim;
-    NcError::set_err(
-		     nc_inq_varndims(the_file->id(), the_id, &ndim)
-		     );
-    return ndim;
-}
-
-// The i-th dimension for this variable
-NcDim* NcVar::get_dim( int i ) const
-{
-    int ndim;
-    int dims[NC_MAX_DIMS];
-    if(NcError::set_err(
-			nc_inq_var(the_file->id(), the_id, 0, 0, &ndim, dims, 0)
-			) != NC_NOERR ||
-       i < 0 || i >= ndim)
-      return 0;
-    return the_file->get_dim(dims[i]);
-}
-
-size_t* NcVar::edges( void ) const	// edge lengths (dimension sizes)
-{
-    size_t* evec = new size_t[num_dims()];
-    for(int i=0; i < num_dims(); i++)
-      evec[i] = get_dim(i)->size();
-    return evec;
-}
-
-int NcVar::num_atts( void ) const // handles variable and global atts
-{
-    int natt = 0;
-    if (the_file->is_valid())
-      if (the_id == ncGlobal)
-	natt = the_file->num_atts();
-      else
-	NcError::set_err(
-			 nc_inq_varnatts(the_file->id(), the_id, &natt)
-			 );
-    return natt;
-}
-
-NcAtt* NcVar::get_att( NcToken aname ) const
-{
-    NcAtt* att = new NcAtt(the_file, this, aname);
-    if (! att->is_valid()) {
-	delete att;
-	return 0;
-    }
-    return att;
-}
-
-NcAtt* NcVar::get_att( int n ) const
-{
-    if (n < 0 || n >= num_atts())
-      return 0;
-    NcToken aname = attname(n);
-    NcAtt* ap = get_att(aname);
-    delete [] (char*)aname;
-    return ap;
-}
-
-long NcVar::num_vals( void ) const
-{
-    long prod = 1;
-    for (int d = 0; d < num_dims(); d++)
-	prod *= get_dim(d)->size();
-    return  prod;
-}
-
-NcValues* NcVar::values( void ) const
-{
-    int ndims = num_dims();
-    size_t crnr[NC_MAX_DIMS];
-    size_t edgs[NC_MAX_DIMS];
-    for (int i = 0; i < ndims; i++) {
-	crnr[i] = 0;
-	edgs[i] = get_dim(i)->size();
-    }
-    NcValues* valp = get_space();
-    int status;
-    switch (type()) {
-    case ncFloat:
-	status = NcError::set_err(
-				  nc_get_vara_float(the_file->id(), the_id, crnr, edgs, 
-				   (float *)valp->base())
-				  );
-	break;
-    case ncDouble:
-	status = NcError::set_err(
-				  nc_get_vara_double(the_file->id(), the_id, crnr, edgs, 
-				    (double *)valp->base())
-				  );
-	break;
-    case ncInt:
-	status = NcError::set_err(
-				  nc_get_vara_int(the_file->id(), the_id, crnr, edgs, 
-				 (int *)valp->base())
-				  );
-	break;
-    case ncShort:
-	status = NcError::set_err(
-				  nc_get_vara_short(the_file->id(), the_id, crnr, edgs, 
-				   (short *)valp->base())
-				  );
-	break;
-    case ncByte:
-	status = NcError::set_err(
-				  nc_get_vara_schar(the_file->id(), the_id, crnr, edgs, 
-				   (signed char *)valp->base())
-				  );
-	break;
-    case ncChar:
-	status = NcError::set_err(
-				  nc_get_vara_text(the_file->id(), the_id, crnr, edgs, 
-				   (char *)valp->base())
-				  );
-	break;
-    case ncNoType:
-    default:
-	return 0;
-    }
-    if (status != NC_NOERR)
-	return 0;
-    return valp;
-}
-
-int NcVar::dim_to_index(NcDim *rdim)
-{
-  for (int i=0; i < num_dims() ; i++) {
-    if (strcmp(get_dim(i)->name(),rdim->name()) == 0) {
-      return i;
-    }
-  }
-  // we should fail and gripe about it here....
-  return -1;
-}
-
-void NcVar::set_rec(NcDim *rdim, long slice)
-{
-  int i = dim_to_index(rdim);
-  // we should fail and gripe about it here....
-  if (slice >= get_dim(i)->size() && ! get_dim(i)->is_unlimited())
-	  return;  
-  cur_rec[i] = slice;
-  return;
-} 
-
-void NcVar::set_rec(long rec)
-{
-  // Since we can't ask for the record dimension here
-  // just assume [0] is it.....
-  set_rec(get_dim(0),rec);
-  return;
-} 
-
-NcValues* NcVar::get_rec(void)
-{
-    return get_rec(get_dim(0), cur_rec[0]);
-}
-
-NcValues* NcVar::get_rec(long rec)
-{
-    return get_rec(get_dim(0), rec);
-}
-
-NcValues* NcVar::get_rec(NcDim* rdim, long slice)
-{
-    int idx = dim_to_index(rdim);
-    long size = num_dims();
-    size_t* start = new size_t[size];
-    long* startl = new long[size];
-    for (int i=1; i < size ; i++) {
-	start[i] = 0;
-	startl[i] = 0;
-    }
-    start[idx] = slice;
-    startl[idx] = slice;
-    NcBool result = set_cur(startl);
-    if (! result ) {
-	delete [] start;
-	delete [] startl;
-	return 0;
-    }
-
-    size_t* edgel = edges();
-    size_t* edge = new size_t[size];
-    for (int i=1; i < size ; i++) {
-	edge[i] = edgel[i];
-    }
-    edge[idx] = 1;
-    edgel[idx] = 1;
-    NcValues* valp = get_space(rec_size(rdim));
-    int status;
-    switch (type()) {
-    case ncFloat:
-	status = NcError::set_err(
-				  nc_get_vara_float(the_file->id(), the_id, start, edge, 
-				   (float *)valp->base())
-				  );
-	break;
-    case ncDouble:
-	status = NcError::set_err(
-				  nc_get_vara_double(the_file->id(), the_id, start, edge, 
-				    (double *)valp->base())
-				  );
-	break;
-    case ncInt:
-	status = NcError::set_err(
-				  nc_get_vara_int(the_file->id(), the_id, start, edge, 
-				 (int *)valp->base())
-				  );
-	break;
-    case ncShort:
-	status = NcError::set_err(
-				  nc_get_vara_short(the_file->id(), the_id, start, edge, 
-				   (short *)valp->base())
-				  );
-	break;
-    case ncByte:
-	status = NcError::set_err(
-				  nc_get_vara_schar(the_file->id(), the_id, start, edge, 
-				   (signed char *)valp->base())
-				  );
-	break;
-    case ncChar:
-	status = NcError::set_err(
-				  nc_get_vara_text(the_file->id(), the_id, start, edge, 
-				   (char *)valp->base())
-				  );
-	break;
-    case ncNoType:
-    default:
-	return 0;
-    }
-    delete [] start;
-    delete [] startl;
-    delete [] edge;
-    delete [] edgel;
-    if (status != NC_NOERR) {
-	delete valp;
-	return 0;
-    }
-    return valp;
-} 
-
-
-#define NcVar_put_rec(TYPE)                                                   \
-NcBool NcVar::put_rec( const TYPE* vals)                                      \
-{                                                                             \
-    return put_rec(get_dim(0), vals, cur_rec[0]);                             \
-}                                                                             \
-                                                                              \
-NcBool NcVar::put_rec( NcDim *rdim, const TYPE* vals)                         \
-{                                                                             \
-    int idx = dim_to_index(rdim);                                             \
-    return put_rec(rdim, vals, cur_rec[idx]);                                 \
-}                                                                             \
-                                                                              \
-NcBool NcVar::put_rec( const TYPE* vals,                                      \
-                     long rec)                                                \
-{                                                                             \
-   return put_rec(get_dim(0), vals, rec);                                     \
-}                                                                             \
-                                                                              \
-NcBool NcVar::put_rec( NcDim* rdim, const TYPE* vals,                         \
-                     long slice)                                              \
-{                                                                             \
-    int idx = dim_to_index(rdim);                                             \
-    long size = num_dims();                                                   \
-    long* start = new long[size];                                             \
-    for (int i=1; i < size ; i++) start[i] = 0;                               \
-    start[idx] = slice;                                                       \
-    NcBool result = set_cur(start);                                           \
-    delete [] start;                                                          \
-    if (! result )                                                            \
-      return FALSE;                                                           \
-                                                                              \
-    size_t* edge = edges();                                                     \
-    edge[idx] = 1;                                                            \
-    result = put(vals, edge);                                                 \
-    delete [] edge;                                                           \
-    return result;                                                            \
-}
-
-NcVar_put_rec(ncbyte)
-NcVar_put_rec(char)
-NcVar_put_rec(short)
-NcVar_put_rec(int)
-NcVar_put_rec(long)
-NcVar_put_rec(float)
-NcVar_put_rec(double)
-
-long NcVar::rec_size(void) {
-    return rec_size(get_dim(0));
-}
-
-long NcVar::rec_size(NcDim *rdim) {
-    int idx = dim_to_index(rdim); 
-    long size = 1;
-    size_t* edge = edges();
-    for( int i = 0 ; i<num_dims() ; i++) {
-	if (i != idx) {
-	  size *= edge[i];
-	}
-    }
-    delete [] edge;
-    return size;
-}
-
-#define NcVar_get_index(TYPE)                                                 \
-long NcVar::get_index(const TYPE* key)                                        \
-{                                                                             \
-   return get_index(get_dim(0), key);                                         \
-}                                                                             \
-                                                                              \
-long NcVar::get_index(NcDim *rdim, const TYPE* key)                           \
-{                                                                             \
-if (type() != NcTypeEnum(TYPE))                                               \
-    return -1;                                                                \
-if (! the_file->data_mode())                                                  \
-    return -1;                                                                \
-int idx = dim_to_index(rdim);                                                 \
-long maxrec = get_dim(idx)->size();                                           \
-long maxvals = rec_size(rdim);                                                \
-NcValues* val;                                                                \
-int validx;                                                                   \
-for (long j=0; j<maxrec; j++) {                                               \
-    val = get_rec(rdim,j);                                                    \
-    if (val == NULL) return -1;                                               \
-    for (validx = 0; validx < maxvals; validx++) {                            \
-        if (key[validx] != val->as_ ## TYPE(validx)) break;                   \
-        }                                                                     \
-    delete val;                                                               \
-    if (validx == maxvals) return j;                                          \
-    }                                                                         \
-return -1;                                                                    \
-}
-
-
-NcVar_get_index(ncbyte)
-NcVar_get_index(char)
-NcVar_get_index(short)
-NcVar_get_index(nclong)
-NcVar_get_index(long)
-NcVar_get_index(float)
-NcVar_get_index(double)
-    
-// Macros below work for short, nclong, long, float, and double, but for ncbyte
-// and char, we must use corresponding schar, uchar, or text C functions, so in 
-// these cases macros are expanded manually.
-#define NcVar_put_array(TYPE)						      \
-NcBool NcVar::put( const TYPE* vals,					      \
-		     long edge0,					      \
-		     long edge1,					      \
-		     long edge2,					      \
-		     long edge3,					      \
-		     long edge4)					      \
-{									      \
-    /* no need to check type() vs. TYPE, invoked C function will do that */   \
-    if (! the_file->data_mode())					      \
-      return FALSE;							      \
-    size_t count[5];							      \
-    count[0] = edge0;							      \
-    count[1] = edge1;							      \
-    count[2] = edge2;							      \
-    count[3] = edge3;							      \
-    count[4] = edge4;							      \
-    for (int i = 0; i < 5; i++) {					      \
-	if (count[i]) {							      \
-	    if (num_dims() < i)						      \
-	      return FALSE;						      \
-	} else								      \
-	  break;							      \
-    }									      \
-    size_t start[5];	                	 		              \
-    for (int j = 0; j < 5; j++) {					      \
-     start[j] = the_cur[j];						      \
-    }									      \
-    return NcError::set_err(                                                  \
-			    makename2(nc_put_vara_,TYPE) (the_file->id(), the_id, start, count, vals) \
-			    ) == NC_NOERR;     \
-}
-
-NcBool NcVar::put( const ncbyte* vals,
-		     long edge0,
-		     long edge1,
-		     long edge2,
-		     long edge3,
-		     long edge4)
-{
-    /* no need to check type() vs. TYPE, invoked C function will do that */
-    if (! the_file->data_mode())
-      return FALSE;
-    size_t count[5];
-    count[0] = edge0;
-    count[1] = edge1;
-    count[2] = edge2;
-    count[3] = edge3;
-    count[4] = edge4;
-    for (int i = 0; i < 5; i++) {
-	if (count[i]) {
-	    if (num_dims() < i)
-	      return FALSE;
-	} else
-	  break;
-    }
-    size_t start[5];
-    for (int j = 0; j < 5; j++) {
-     start[j] = the_cur[j];
-    }
-    return NcError::set_err(
-			    nc_put_vara_schar (the_file->id(), the_id, start, count, vals)
-			    ) == NC_NOERR;
-}
-
-NcBool NcVar::put( const char* vals,
-		     long edge0,
-		     long edge1,
-		     long edge2,
-		     long edge3,
-		     long edge4)
-{
-    /* no need to check type() vs. TYPE, invoked C function will do that */
-    if (! the_file->data_mode())
-      return FALSE;
-    size_t count[5];
-    count[0] = edge0;
-    count[1] = edge1;
-    count[2] = edge2;
-    count[3] = edge3;
-    count[4] = edge4;
-    for (int i = 0; i < 5; i++) {
-	if (count[i]) {
-	    if (num_dims() < i)
-	      return FALSE;
-	} else
-	  break;
-    }
-    size_t start[5];
-    for (int j = 0; j < 5; j++) {
-     start[j] = the_cur[j];
-    }
-    return NcError::set_err(
-			    nc_put_vara_text (the_file->id(), the_id, start, count, vals)
-			    ) == NC_NOERR;
-}
-
-NcVar_put_array(short)
-NcVar_put_array(int)
-NcVar_put_array(long)
-NcVar_put_array(float)
-NcVar_put_array(double)
-
-#define NcVar_put_nd_array(TYPE)					      \
-NcBool NcVar::put( const TYPE* vals, const size_t* count )		      \
-{									      \
-    /* no need to check type() vs. TYPE, invoked C function will do that */   \
-    if (! the_file->data_mode())					      \
-      return FALSE;							      \
-    size_t start[NC_MAX_DIMS];						      \
-    for (int i = 0; i < num_dims(); i++)				      \
-      start[i] = the_cur[i];						      \
-    return NcError::set_err(                                                  \
-			    makename2(nc_put_vara_,TYPE) (the_file->id(), the_id, start, (const size_t *) count, vals) \
-			    ) == NC_NOERR;                                    \
-}
-
-NcBool NcVar::put( const ncbyte* vals, const size_t* count )
-{
-    /* no need to check type() vs. TYPE, invoked C function will do that */
-    if (! the_file->data_mode())
-      return FALSE;
-    size_t start[NC_MAX_DIMS];
-    for (int i = 0; i < num_dims(); i++)
-      start[i] = the_cur[i];
-    return NcError::set_err(
-			    nc_put_vara_schar (the_file->id(), the_id, start, (const size_t *)count, vals)
-			    ) == NC_NOERR;
-}
-
-NcBool NcVar::put( const char* vals, const size_t* count )
-{
-    /* no need to check type() vs. TYPE, invoked C function will do that */
-    if (! the_file->data_mode())
-      return FALSE;
-    size_t start[NC_MAX_DIMS];
-    for (int i = 0; i < num_dims(); i++)
-      start[i] = the_cur[i];
-    return NcError::set_err(
-			    nc_put_vara_text (the_file->id(), the_id, start, (const size_t *)count, vals)
-			    ) == NC_NOERR;
-}
-
-NcVar_put_nd_array(short)
-NcVar_put_nd_array(int)
-NcVar_put_nd_array(long)
-NcVar_put_nd_array(float)
-NcVar_put_nd_array(double)
-
-#define NcVar_get_array(TYPE)						      \
-NcBool NcVar::get( TYPE* vals,						      \
-		     long edge0,					      \
-		     long edge1,					      \
-		     long edge2,					      \
-		     long edge3,					      \
-		     long edge4) const					      \
-{									      \
-    if (! the_file->data_mode())					      \
-      return FALSE;							      \
-    size_t count[5];							      \
-    count[0] = edge0;							      \
-    count[1] = edge1;							      \
-    count[2] = edge2;							      \
-    count[3] = edge3;							      \
-    count[4] = edge4;							      \
-    for (int i = 0; i < 5; i++) {					      \
-	if (count[i]) {							      \
-	    if (num_dims() < i)						      \
-	      return FALSE;						      \
-	} else								      \
-	  break;							      \
-    }									      \
-    size_t start[5];				      		              \
-    for (int j = 0; j < 5; j++) {					      \
-     start[j] = the_cur[j];						      \
-    }									      \
-    return NcError::set_err(                                                  \
-			    makename2(nc_get_vara_,TYPE) (the_file->id(), the_id, start, count, vals) \
-			    ) == NC_NOERR;                                    \
-}
-
-NcBool NcVar::get( ncbyte* vals,
-		     long edge0,
-		     long edge1,
-		     long edge2,
-		     long edge3,
-		     long edge4) const
-{
-    if (! the_file->data_mode())
-      return FALSE;
-    size_t count[5];
-    count[0] = edge0;
-    count[1] = edge1;
-    count[2] = edge2;
-    count[3] = edge3;
-    count[4] = edge4;
-    for (int i = 0; i < 5; i++) {
-	if (count[i]) {
-	    if (num_dims() < i)
-	      return FALSE;
-	} else
-	  break;
-    }
-    size_t start[5];
-    for (int j = 0; j < 5; j++) {
-     start[j] = the_cur[j];
-    }
-    return NcError::set_err(
-			    nc_get_vara_schar (the_file->id(), the_id, start, count, vals)
-			    ) == NC_NOERR;
-}
-
-NcBool NcVar::get( char* vals,
-		     long edge0,
-		     long edge1,
-		     long edge2,
-		     long edge3,
-		     long edge4) const
-{
-    if (! the_file->data_mode())
-      return FALSE;
-    size_t count[5];
-    count[0] = edge0;
-    count[1] = edge1;
-    count[2] = edge2;
-    count[3] = edge3;
-    count[4] = edge4;
-    for (int i = 0; i < 5; i++) {
-	if (count[i]) {
-	    if (num_dims() < i)
-	      return FALSE;
-	} else
-	  break;
-    }
-    size_t start[5];
-    for (int j = 0; j < 5; j++) {
-     start[j] = the_cur[j];
-    }
-    return NcError::set_err(
-			    nc_get_vara_text (the_file->id(), the_id, start, count, vals)
-			    ) == NC_NOERR;
-}
-
-NcVar_get_array(short)
-NcVar_get_array(int)
-NcVar_get_array(long)
-NcVar_get_array(float)
-NcVar_get_array(double)
-
-#define NcVar_get_nd_array(TYPE)					      \
-NcBool NcVar::get( TYPE* vals, const size_t* count ) const		      \
-{									      \
-    if (! the_file->data_mode())					      \
-      return FALSE;							      \
-    size_t start[NC_MAX_DIMS];						      \
-    for (int i = 0; i < num_dims(); i++)				      \
-	start[i] = the_cur[i];						      \
-    return NcError::set_err(                                                  \
-			    makename2(nc_get_vara_,TYPE) (the_file->id(), the_id, start,  (const size_t *) count, vals) \
-			    ) == NC_NOERR;     \
-}
-
-NcBool NcVar::get( ncbyte* vals, const size_t* count ) const
-{
-    if (! the_file->data_mode())
-      return FALSE;
-    size_t start[NC_MAX_DIMS];
-    for (int i = 0; i < num_dims(); i++)
-	start[i] = the_cur[i];
-    return nc_get_vara_schar (the_file->id(), the_id, start,  (const size_t *) count, vals) == NC_NOERR;
-}
-
-NcBool NcVar::get( char* vals, const size_t* count ) const
-{
-    if (! the_file->data_mode())
-      return FALSE;
-    size_t start[NC_MAX_DIMS];
-    for (int i = 0; i < num_dims(); i++)
-	start[i] = the_cur[i];
-    return nc_get_vara_text (the_file->id(), the_id, start, (const size_t*) count, vals) == NC_NOERR;
-}
-
-NcVar_get_nd_array(short)
-NcVar_get_nd_array(int)
-NcVar_get_nd_array(long)
-NcVar_get_nd_array(float)
-NcVar_get_nd_array(double)
-
-// If no args, set cursor to all zeros.	 Else set initial elements of cursor
-// to args provided, rest to zeros.
-NcBool NcVar::set_cur(long c0, long c1, long c2, long c3, long c4)
-{
-    long t[6];
-    t[0] = c0;
-    t[1] = c1;
-    t[2] = c2;
-    t[3] = c3;
-    t[4] = c4;
-    t[5] = -1;
-    for(int j = 0; j < 6; j++) { // find how many parameters were used
-	int i;
-	if (t[j] == -1) {
-	    if (num_dims() < j)
-	      return FALSE;	// too many for variable's dimensionality
-	    for (i = 0; i < j; i++) {
-		if (t[i] >= get_dim(i)->size() && ! get_dim(i)->is_unlimited())
-		  return FALSE;	// too big for dimension
-		the_cur[i] = t[i];
-	    }
-	    for(i = j; i < num_dims(); i++)
-	      the_cur[i] = 0;
-	    return TRUE;
-	}
-    }
-    return TRUE;
-}
-
-NcBool NcVar::set_cur(long* cur)
-{
-    for(int i = 0; i < num_dims(); i++) {
-	if (cur[i] >= get_dim(i)->size() && ! get_dim(i)->is_unlimited())
-	  return FALSE;
-	the_cur[i] = cur[i];
-    }
-    return TRUE;
-}
-
-#define NcVar_add_scalar_att(TYPE)					      \
-NcBool NcVar::add_att(NcToken aname, TYPE val)				      \
-{									      \
-    if (! the_file->define_mode())					      \
-      return FALSE;							      \
-    if (NcError::set_err(                                                     \
-			    makename2(nc_put_att_,TYPE) (the_file->id(), the_id, aname, (nc_type) NcTypeEnum(TYPE), \
-		 1, &val)                                                     \
-			    ) != NC_NOERR)				      \
-      return FALSE;							      \
-    return TRUE;							      \
-}
-
-NcBool NcVar::add_att(NcToken aname, ncbyte val)
-{
-    if (! the_file->define_mode())
-      return FALSE;
-    if (nc_put_att_schar (the_file->id(), the_id, aname, (nc_type) NcTypeEnum(ncbyte),
-		 1, &val) != NC_NOERR)
-      return FALSE;
-    return TRUE;
-}
-
-NcBool NcVar::add_att(NcToken aname, char val)
-{
-    if (! the_file->define_mode())
-      return FALSE;
-    if (nc_put_att_text (the_file->id(), the_id, aname,
-		 1, &val) != NC_NOERR)
-      return FALSE;
-    return TRUE;
-}
-
-NcVar_add_scalar_att(short)
-NcVar_add_scalar_att(int)
-NcVar_add_scalar_att(long)
-NcVar_add_scalar_att(double)
-
-NcBool NcVar::add_att(NcToken aname, float val)
-{
-    if (! the_file->define_mode())
-      return FALSE;
-    float fval = (float) val;	// workaround for bug, val passed as double??
-    if (nc_put_att_float(the_file->id(), the_id, aname, (nc_type) ncFloat,
-		 1, &fval) != NC_NOERR)
-      return FALSE;
-    return TRUE;
-}
-
-NcBool NcVar::add_att(NcToken aname, const char* val)
-{
-    if (! the_file->define_mode())
-      return FALSE;
-    if (nc_put_att_text(the_file->id(), the_id, aname,
-		 strlen(val), val) != NC_NOERR)
-      return FALSE;
-    return TRUE;
-}
-
-#define NcVar_add_vector_att(TYPE)					      \
-NcBool NcVar::add_att(NcToken aname, int len, const TYPE* vals)		      \
-{									      \
-    if (! the_file->define_mode())					      \
-      return FALSE;							      \
-    if (NcError::set_err(                                                     \
-			    makename2(nc_put_att_,TYPE) (the_file->id(), the_id, aname, (nc_type) NcTypeEnum(TYPE),   \
-		 len, vals)                                                   \
-			    ) != NC_NOERR)				      \
-      return FALSE;							      \
-    return TRUE;							      \
-}
-
-NcBool NcVar::add_att(NcToken aname, int len, const ncbyte* vals)
-{
-    if (! the_file->define_mode())
-      return FALSE;
-    if (NcError::set_err(
-			 nc_put_att_schar (the_file->id(), the_id, aname, (nc_type) NcTypeEnum(ncbyte),
-		 len, vals)
-			 ) != NC_NOERR)
-      return FALSE;
-    return TRUE;
-}
-
-NcBool NcVar::add_att(NcToken aname, int len, const char* vals)
-{
-    if (! the_file->define_mode())
-      return FALSE;
-    if (NcError::set_err(
-			 nc_put_att_text (the_file->id(), the_id, aname,
-		 len, vals)
-			 ) != NC_NOERR)
-      return FALSE;
-    return TRUE;
-}
-
-NcVar_add_vector_att(short)
-NcVar_add_vector_att(int)
-NcVar_add_vector_att(long)
-NcVar_add_vector_att(float)
-NcVar_add_vector_att(double)
-
-NcBool NcVar::rename(NcToken newname)
-{
-    if (strlen(newname) > strlen(the_name)) {
-	if (! the_file->define_mode())
-	    return FALSE;
-    }
-    NcBool ret = NcError::set_err(
-				  nc_rename_var(the_file->id(), the_id, newname)
-				  ) == NC_NOERR;
-    if (ret) {
-	delete [] the_name;
-	the_name = new char [1 + strlen(newname)];
-	strcpy(the_name, newname);
-    }
-    return ret;
-}
-
-int NcVar::id( void ) const
-{
-    return the_id;
-}
-
-NcBool NcVar::sync(void)
-{
-    if (the_name) {
-	delete [] the_name;
-    }
-    if (the_cur) {
-	delete [] the_cur;
-    }
-    if (cur_rec) {
-	delete [] cur_rec;
-    }
-    char nam[NC_MAX_NAME];
-    if (the_file 
-	&& NcError::set_err(
-			    nc_inq_varname(the_file->id(), the_id, nam)
-			    ) == NC_NOERR) {
-	the_name = new char[1 + strlen(nam)];
-	strcpy(the_name, nam);
-    } else {
-	the_name = 0;
-	return FALSE;
-    }
-    init_cur(); 
-    return TRUE;
-}
-
-
-NcVar::NcVar(NcFile* nc, int id)
-   : NcTypedComponent(nc), the_id(id)
-{
-    char nam[NC_MAX_NAME];
-    if (the_file 
-	&& NcError::set_err(
-			    nc_inq_varname(the_file->id(), the_id, nam)
-			    ) == NC_NOERR) {
-	the_name = new char[1 + strlen(nam)];
-	strcpy(the_name, nam);
-    } else {
-	the_name = 0;
-    }
-    init_cur();
-}
-
-int NcVar::attnum( NcToken attrname ) const
-{
-    int num;
-    for(num=0; num < num_atts(); num++) {
-	char aname[NC_MAX_NAME];
-	NcError::set_err(
-			 nc_inq_attname(the_file->id(), the_id, num, aname)
-			 );
-	if (strcmp(aname, attrname) == 0)
-	  break;
-    }
-    return num;			// num_atts() if no such attribute
-}
-
-NcToken NcVar::attname( int attnum ) const // caller must delete[]
-{
-    if (attnum < 0 || attnum >= num_atts())
-      return 0;
-    char aname[NC_MAX_NAME];
-    if (NcError::set_err(
-			 nc_inq_attname(the_file->id(), the_id, attnum, aname)
-			 ) != NC_NOERR)
-      return 0;
-    char* rname = new char[1 + strlen(aname)];
-    strcpy(rname, aname);
-    return rname;
-}
-
-void NcVar::init_cur( void )
-{
-    the_cur = new long[NC_MAX_DIMS]; // *** don't know num_dims() yet?
-    cur_rec = new long[NC_MAX_DIMS]; // *** don't know num_dims() yet?
-    for(int i = 0; i < NC_MAX_DIMS; i++) { 
-	the_cur[i] = 0; cur_rec[i] = 0; }
-}
-
-NcAtt::NcAtt(NcFile* nc, const NcVar* var, NcToken name)
-   : NcTypedComponent(nc), the_variable(var)
-{
-    the_name = new char[1 + strlen(name)];
-    strcpy(the_name, name);
-}
-
-NcAtt::NcAtt(NcFile* nc, NcToken name)
-   : NcTypedComponent(nc), the_variable(NULL)
-{
-    the_name = new char[1 + strlen(name)];
-    strcpy(the_name, name);
-}
-
-NcAtt::~NcAtt( void )
-{
-    delete [] the_name;
-}
-
-NcToken NcAtt::name( void ) const
-{
-    return the_name;
-}
-
-NcType NcAtt::type( void ) const
-{
-    nc_type typ;
-    NcError::set_err(
-		     nc_inq_atttype(the_file->id(), the_variable->id(), the_name, &typ)
-		     );
-    return (NcType) typ;
-}
-
-long NcAtt::num_vals( void ) const
-{
-    size_t len;
-    NcError::set_err(
-		     nc_inq_attlen(the_file->id(), the_variable->id(), the_name, &len)
-		     );
-    return len;
-}
-
-NcBool NcAtt::is_valid( void ) const
-{
-    int num;
-    return the_file->is_valid() &&
-      (the_variable->id() == NC_GLOBAL || the_variable->is_valid()) &&
-	NcError::set_err(
-			 nc_inq_attid(the_file->id(), the_variable->id(), the_name, &num)
-			 ) == NC_NOERR;
-}
-
-NcValues* NcAtt::values( void ) const
-{
-    NcValues* valp = get_space();
-    int status;
-    switch (type()) {
-    case ncFloat:
-	status = NcError::set_err(
-				  nc_get_att_float(the_file->id(), the_variable->id(), the_name,
-				   (float *)valp->base())
-				  );
-	break;
-    case ncDouble:
-	status = NcError::set_err(
-				  nc_get_att_double(the_file->id(), the_variable->id(), the_name,
-				   (double *)valp->base())
-				  );
-	break;
-    case ncInt:
-	status = NcError::set_err(
-				  nc_get_att_int(the_file->id(), the_variable->id(), the_name,
-				(int *)valp->base())
-				  );
-	break;
-    case ncShort:
-	status = NcError::set_err(
-				  nc_get_att_short(the_file->id(), the_variable->id(), the_name,
-				  (short *)valp->base())
-				  );
-	break;
-    case ncByte:
-	status = NcError::set_err(
-				  nc_get_att_schar(the_file->id(), the_variable->id(), the_name,
-				  (signed char *)valp->base())
-				  );
-	break;
-    case ncChar:
-	status = NcError::set_err(
-				  nc_get_att_text(the_file->id(), the_variable->id(), the_name,
-				  (char *)valp->base())
-				  );
-	break;
-    case ncNoType:
-    default:
-	return 0;
-    }
-    if (status != NC_NOERR) {
-	delete valp;
-	return 0;
-    }
-    return valp;
-}
-
-NcBool NcAtt::rename(NcToken newname)
-{
-    if (strlen(newname) > strlen(the_name)) {
-	if (! the_file->define_mode())
-	    return FALSE;
-    }
-    return NcError::set_err(
-			    nc_rename_att(the_file->id(), the_variable->id(),
-		       the_name, newname)
-			    ) == NC_NOERR;
-}
-
-NcBool NcAtt::remove( void )
-{
-    if (! the_file->define_mode())
-	return FALSE;
-    return NcError::set_err(
-			    nc_del_att(the_file->id(), the_variable->id(), the_name)
-			    ) == NC_NOERR;
-}
-
-NcError::NcError( Behavior b )
-{
-    the_old_state = ncopts;	// global variable in version 2 C interface
-    the_old_err = ncerr;	// global variable in version 2 C interface
-    ncopts = (int) b;
-}
-
-NcError::~NcError( void )
-{
-    ncopts = the_old_state;
-    ncerr = the_old_err;
-}
-
-int NcError::get_err( void )	// returns most recent error
-{
-    return ncerr;
-}
-
-int NcError::set_err (int err)
-{
-    ncerr = err;
-    // Check ncopts and handle appropriately
-    if(err != NC_NOERR) {
-	if(ncopts == verbose_nonfatal || ncopts == verbose_fatal) {
-	    std::cout << nc_strerror(err) << std::endl;
-	}
-	if(ncopts == silent_fatal || ncopts == verbose_fatal) {
-	    exit(ncopts);
-	}
-    }
-    return err;
-}
-
-int NcError::ncerr = NC_NOERR;
-int NcError::ncopts = NcError::verbose_fatal ; // for backward compatibility
diff --git a/ThirdParty/netcdfcpp/vtknetcdfcpp/cxx/netcdfcpp.h b/ThirdParty/netcdfcpp/vtknetcdfcpp/cxx/netcdfcpp.h
deleted file mode 100644
index e79b3112588..00000000000
--- a/ThirdParty/netcdfcpp/vtknetcdfcpp/cxx/netcdfcpp.h
+++ /dev/null
@@ -1,474 +0,0 @@
-/*********************************************************************
- *   Copyright 1992, University Corporation for Atmospheric Research
- *   See netcdf/README file for copying and redistribution conditions.
- *
- *   Purpose:   C++ class interface for netCDF
- *
- *   $Header: /upc/share/CVS/netcdf-3/cxx/netcdfcpp.h,v 1.15 2009/03/10 15:20:54 russ Exp $
- *********************************************************************/
-
-#ifndef NETCDF_HH
-#define NETCDF_HH
-
-// VTK has modified the API from upstream in order to use `size_t*` rather than
-// `long*` for some overloads of methods such as `NcVar::get`. This define
-// signals uses of this header that `size_t` should be used instead.
-#define VTK_NETCDFCPP_USE_SIZE_T
-
-#include "ncvalues.h"          // arrays that know their element type
-
-typedef const char* NcToken;    // names for netCDF objects
-typedef unsigned int NcBool;    // many members return 0 on failure
-
-class NcDim;                    // dimensions
-class NcVar;                    // variables
-class NcAtt;                    // attributes
-
-/*
- * ***********************************************************************
- * A netCDF file.
- * ***********************************************************************
- */
-class VTKNETCDFCPP_EXPORT NcFile
-{
-  public:
-
-    virtual ~NcFile( void );
-
-    enum FileMode {
-	ReadOnly,	// file exists, open read-only
-	Write,		// file exists, open for writing
-        Replace,	// create new file, even if already exists
-	New		// create new file, fail if already exists
-      };
-
-    enum FileFormat {
-       Classic,         // netCDF classic format (i.e. version 1 format)
-       Offset64Bits,    // netCDF 64-bit offset format
-       Netcdf4,		// netCDF-4 using HDF5 format
-       Netcdf4Classic,	// netCDF-4 using HDF5 format using only netCDF-3 calls
-       BadFormat
-    };
-
-    NcFile( const char * path, FileMode = ReadOnly ,
-	    size_t *bufrsizeptr = NULL,    // optional tuning parameters
-	    size_t initialsize = 0,
-	    FileFormat = Classic );
-
-    NcBool is_valid( void ) const;         // opened OK in ctr, still valid
-
-    int num_dims( void ) const;            // number of dimensions
-    int num_vars( void ) const;            // number of variables
-    int num_atts( void ) const;            // number of (global) attributes
-
-    NcDim* get_dim( NcToken ) const;       // dimension by name
-    NcVar* get_var( NcToken ) const;       // variable by name
-    NcAtt* get_att( NcToken ) const;       // global attribute by name
-
-    NcDim* get_dim( int ) const;           // n-th dimension
-    NcVar* get_var( int ) const;           // n-th variable
-    NcAtt* get_att( int ) const;           // n-th global attribute
-    NcDim* rec_dim( void ) const;          // unlimited dimension, if any
-
-    // Add new dimensions, variables, global attributes.
-    // These put the file in "define" mode, so could be expensive.
-    virtual NcDim* add_dim( NcToken dimname, long dimsize );
-    virtual NcDim* add_dim( NcToken dimname );     // unlimited
-
-    virtual NcVar* add_var( NcToken varname, NcType type,       // scalar
-                    const NcDim* dim0=0,                // 1-dim
-                    const NcDim* dim1=0,                // 2-dim
-                    const NcDim* dim2=0,                // 3-dim
-                    const NcDim* dim3=0,                // 4-dim
-                    const NcDim* dim4=0 );              // 5-dim
-    virtual NcVar* add_var( NcToken varname, NcType type,       // n-dim
-                          int ndims, const NcDim** dims );
-
-    NcBool add_att( NcToken attname, char );             // scalar attributes
-    NcBool add_att( NcToken attname, ncbyte );
-    NcBool add_att( NcToken attname, short );
-    NcBool add_att( NcToken attname, long );
-    NcBool add_att( NcToken attname, int );
-    NcBool add_att( NcToken attname, float );
-    NcBool add_att( NcToken attname, double );
-    NcBool add_att( NcToken attname, const char*);       // string attribute
-    NcBool add_att( NcToken attname, int, const char* ); // vector attributes
-    NcBool add_att( NcToken attname, int, const ncbyte* );
-    NcBool add_att( NcToken attname, int, const short* );
-    NcBool add_att( NcToken attname, int, const long* );
-    NcBool add_att( NcToken attname, int, const int* );
-    NcBool add_att( NcToken attname, int, const float* );
-    NcBool add_att( NcToken attname, int, const double* );
-
-    enum FillMode {
-        Fill = NC_FILL,                    // prefill (default)
-        NoFill = NC_NOFILL,                // don't prefill
-        Bad
-      };
-
-    NcBool set_fill( FillMode = Fill );    // set fill-mode
-    FillMode get_fill( void ) const;       // get fill-mode
-    FileFormat get_format( void ) const;   // get format version
-
-    NcBool sync( void );                   // synchronize to disk
-    NcBool close( void );                  // to close earlier than dtr
-    NcBool abort( void );                  // back out of bad defines
-
-    // Needed by other Nc classes, but users will not need them
-    NcBool define_mode( void ); // leaves in define mode, if possible
-    NcBool data_mode( void );   // leaves in data mode, if possible
-    int id( void ) const;       // id used by C interface
-
-  protected:
-    int the_id;
-    int in_define_mode;
-    FillMode the_fill_mode;
-    NcDim** dimensions;
-    NcVar** variables;
-    NcVar* globalv;             // "variable" for global attributes
-};
-
-/*
- * For backward compatibility.  We used to derive NcOldFile and NcNewFile
- * from NcFile, but that was over-zealous inheritance.
- */
-#define NcOldFile NcFile
-#define NcNewFile NcFile
-#define Clobber Replace
-#define NoClobber New
-
-/*
- * **********************************************************************
- * A netCDF dimension, with a name and a size.  These are only created
- * by NcFile member functions, because they cannot exist independently
- * of an open netCDF file.
- * **********************************************************************
- */
-class VTKNETCDFCPP_EXPORT NcDim
-{
-  public:
-    NcToken name( void ) const;
-    long size( void ) const;
-    NcBool is_valid( void ) const;
-    NcBool is_unlimited( void ) const;
-    NcBool rename( NcToken newname );
-    int id( void ) const;
-    NcBool sync( void );
-
-  private:
-    NcFile *the_file;		// not const because of rename
-    int the_id;
-    char *the_name;
-
-    NcDim(NcFile*, int num);	// existing dimension
-    NcDim(NcFile*, NcToken name, long sz); // defines a new dim
-    virtual ~NcDim( void );
-
-    // to construct dimensions, since constructor is private
-    friend class NcFile;
-};
-
-
-/*
- * **********************************************************************
- * Abstract base class for a netCDF variable or attribute, both of which
- * have a name, a type, and associated values.  These only exist as
- * components of an open netCDF file.
- * **********************************************************************
- */
-class VTKNETCDFCPP_EXPORT NcTypedComponent
-{
-  public:
-    virtual ~NcTypedComponent( void ) {}
-    virtual NcToken name( void ) const = 0;
-    virtual NcType type( void ) const = 0;
-    virtual NcBool is_valid( void ) const = 0;
-    virtual long num_vals( void ) const = 0;
-    virtual NcBool rename( NcToken newname ) = 0;
-    virtual NcValues* values( void ) const = 0; // block of all values
-
-    // The following member functions provide conversions from the value
-    // type to a desired basic type.  If the value is out of range,
-    // the default "fill-value" for the appropriate type is returned.
-
-    virtual ncbyte as_ncbyte( long n ) const;    // nth value as an unsgnd char
-    virtual char as_char( long n ) const;        // nth value as char
-    virtual short as_short( long n ) const;      // nth value as short
-    virtual int as_int( long n ) const;	         // nth value as int
-    virtual int as_nclong( long n ) const;       // nth value as nclong (deprecated)
-    virtual long as_long( long n ) const;        // nth value as long
-    virtual float as_float( long n ) const;      // nth value as floating-point
-    virtual double as_double( long n ) const;    // nth value as double
-    virtual char* as_string( long n ) const;     // nth value as string
-
-  protected:
-    NcFile *the_file;
-    NcTypedComponent( NcFile* );
-    virtual NcValues* get_space( long numVals = 0 ) const;  // to hold values
-};
-
-
-/*
- * **********************************************************************
- * netCDF variables.  In addition to a name and a type, these also have
- * a shape, given by a list of dimensions
- * **********************************************************************
- */
-class VTKNETCDFCPP_EXPORT NcVar : public NcTypedComponent
-{
-  public:
-    virtual ~NcVar( void ) override;
-    NcToken name( void ) const override;
-    NcType type( void ) const override;
-    NcBool is_valid( void ) const override;
-    int num_dims( void ) const;         // dimensionality of variable
-    NcDim* get_dim( int ) const;        // n-th dimension
-    size_t* edges( void ) const;          // dimension sizes
-    int num_atts( void ) const;         // number of attributes
-    NcAtt* get_att( NcToken ) const;    // attribute by name
-    NcAtt* get_att( int ) const;        // n-th attribute
-    long num_vals( void ) const override;     // product of dimension sizes
-    NcValues* values( void ) const override;  // all values
-
-    // Put scalar or 1, ..., 5 dimensional arrays by providing enough
-    // arguments.  Arguments are edge lengths, and their number must not
-    // exceed variable's dimensionality.  Start corner is [0,0,..., 0] by
-    // default, but may be reset using the set_cur() member.  FALSE is
-    // returned if type of values does not match type for variable.
-    NcBool put( const ncbyte* vals,
-                long c0=0, long c1=0, long c2=0, long c3=0, long c4=0 );
-    NcBool put( const char* vals,
-                long c0=0, long c1=0, long c2=0, long c3=0, long c4=0 );
-    NcBool put( const short* vals,
-                long c0=0, long c1=0, long c2=0, long c3=0, long c4=0 );
-    NcBool put( const int* vals,
-                long c0=0, long c1=0, long c2=0, long c3=0, long c4=0 );
-    NcBool put( const long* vals,
-                long c0=0, long c1=0, long c2=0, long c3=0, long c4=0 );
-    NcBool put( const float* vals,
-                long c0=0, long c1=0, long c2=0, long c3=0, long c4=0 );
-    NcBool put( const double* vals,
-                long c0=0, long c1=0, long c2=0, long c3=0, long c4=0 );
-
-    // Put n-dimensional arrays, starting at [0, 0, ..., 0] by default,
-    // may be reset with set_cur().
-    NcBool put( const ncbyte* vals, const size_t* counts );
-    NcBool put( const char* vals, const size_t* counts );
-    NcBool put( const short* vals, const size_t* counts );
-    NcBool put( const int* vals, const size_t* counts );
-    NcBool put( const long* vals, const size_t* counts );
-    NcBool put( const float* vals, const size_t* counts );
-    NcBool put( const double* vals, const size_t* counts );
-
-    // Get scalar or 1, ..., 5 dimensional arrays by providing enough
-    // arguments.  Arguments are edge lengths, and their number must not
-    // exceed variable's dimensionality.  Start corner is [0,0,..., 0] by
-    // default, but may be reset using the set_cur() member.
-    NcBool get( ncbyte* vals, long c0=0, long c1=0,
-                long c2=0, long c3=0, long c4=0 ) const;
-    NcBool get( char* vals, long c0=0, long c1=0,
-                long c2=0, long c3=0, long c4=0 ) const;
-    NcBool get( short* vals, long c0=0, long c1=0,
-                long c2=0, long c3=0, long c4=0 ) const;
-    NcBool get( int* vals, long c0=0, long c1=0,
-                long c2=0, long c3=0, long c4=0 ) const;
-    NcBool get( long* vals, long c0=0, long c1=0,
-                long c2=0, long c3=0, long c4=0 ) const;
-    NcBool get( float* vals, long c0=0, long c1=0,
-                long c2=0, long c3=0, long c4=0 ) const;
-    NcBool get( double* vals, long c0=0, long c1=0,
-                long c2=0, long c3=0, long c4=0 ) const;
-
-    // Get n-dimensional arrays, starting at [0, 0, ..., 0] by default,
-    // may be reset with set_cur().
-    NcBool get( ncbyte* vals, const size_t* counts ) const;
-    NcBool get( char* vals, const size_t* counts ) const;
-    NcBool get( short* vals, const size_t* counts ) const;
-    NcBool get( int* vals, const size_t* counts ) const;
-    NcBool get( long* vals, const size_t* counts ) const;
-    NcBool get( float* vals, const size_t* counts ) const;
-    NcBool get( double* vals, const size_t* counts ) const;
-
-    NcBool set_cur(long c0=-1, long c1=-1, long c2=-1,
-                         long c3=-1, long c4=-1);
-    NcBool set_cur(long* cur);
-
-    // these put file in define mode, so could be expensive
-    NcBool add_att( NcToken, char );             // add scalar attributes
-    NcBool add_att( NcToken, ncbyte );
-    NcBool add_att( NcToken, short );
-    NcBool add_att( NcToken, int );
-    NcBool add_att( NcToken, long );
-    NcBool add_att( NcToken, float );
-    NcBool add_att( NcToken, double );
-    NcBool add_att( NcToken, const char* );      // string attribute
-    NcBool add_att( NcToken, int, const char* ); // vector attributes
-    NcBool add_att( NcToken, int, const ncbyte* );
-    NcBool add_att( NcToken, int, const short* );
-    NcBool add_att( NcToken, int, const int* );
-    NcBool add_att( NcToken, int, const long* );
-    NcBool add_att( NcToken, int, const float* );
-    NcBool add_att( NcToken, int, const double* );
-
-    NcBool rename( NcToken newname ) override;
-
-    long rec_size ( void );             // number of values per record
-    long rec_size ( NcDim* );           // number of values per dimension slice
-
-    // Though following are intended for record variables, they also work
-    // for other variables, using first dimension as record dimension.
-
-    // Get a record's worth of data
-    NcValues *get_rec(void);	        // get current record
-    NcValues *get_rec(long rec);        // get specified record
-    NcValues *get_rec(NcDim* d);        // get current dimension slice
-    NcValues *get_rec(NcDim* d, long slice); // get specified dimension slice
-
-    // Put a record's worth of data in current record
-    NcBool put_rec( const ncbyte* vals );
-    NcBool put_rec( const char* vals );
-    NcBool put_rec( const short* vals );
-    NcBool put_rec( const int* vals );
-    NcBool put_rec( const long* vals );
-    NcBool put_rec( const float* vals );
-    NcBool put_rec( const double* vals );
-
-    // Put a dimension slice worth of data in current dimension slice
-    NcBool put_rec( NcDim* d, const ncbyte* vals );
-    NcBool put_rec( NcDim* d, const char* vals );
-    NcBool put_rec( NcDim* d, const short* vals );
-    NcBool put_rec( NcDim* d, const int* vals );
-    NcBool put_rec( NcDim* d, const long* vals );
-    NcBool put_rec( NcDim* d, const float* vals );
-    NcBool put_rec( NcDim* d, const double* vals );
-
-    // Put a record's worth of data in specified record
-    NcBool put_rec( const ncbyte* vals, long rec );
-    NcBool put_rec( const char* vals, long rec );
-    NcBool put_rec( const short* vals, long rec );
-    NcBool put_rec( const int* vals, long rec );
-    NcBool put_rec( const long* vals, long rec );
-    NcBool put_rec( const float* vals, long rec );
-    NcBool put_rec( const double* vals, long rec );
-
-    // Put a dimension slice worth of data in specified dimension slice
-    NcBool put_rec( NcDim* d, const ncbyte* vals, long slice );
-    NcBool put_rec( NcDim* d, const char* vals, long slice );
-    NcBool put_rec( NcDim* d, const short* vals, long slice );
-    NcBool put_rec( NcDim* d, const int* vals, long slice );
-    NcBool put_rec( NcDim* d, const long* vals, long slice );
-    NcBool put_rec( NcDim* d, const float* vals, long slice );
-    NcBool put_rec( NcDim* d, const double* vals, long slice );
-
-    // Get first record index corresponding to specified key value(s)
-    long get_index( const ncbyte* vals );
-    long get_index( const char* vals );
-    long get_index( const short* vals );
-    long get_index( const int* vals );
-    long get_index( const long* vals );
-    long get_index( const float* vals );
-    long get_index( const double* vals );
-
-    // Get first index of specified dimension corresponding to key values
-    long get_index( NcDim* d, const ncbyte* vals );
-    long get_index( NcDim* d, const char* vals );
-    long get_index( NcDim* d, const short* vals );
-    long get_index( NcDim* d, const int* vals );
-    long get_index( NcDim* d, const long* vals );
-    long get_index( NcDim* d, const float* vals );
-    long get_index( NcDim* d, const double* vals );
-
-    // Set current record
-    void set_rec ( long rec );
-    // Set current dimension slice
-    void set_rec ( NcDim* d, long slice );
-
-    int id( void ) const;               // rarely needed, C interface id
-    NcBool sync( void );
-
-  private:
-    int dim_to_index(NcDim* rdim);
-    int the_id;
-    long* the_cur;
-    char* the_name;
-    long* cur_rec;
-
-    // private constructors because only an NcFile creates these
-    NcVar( void );
-    NcVar(NcFile*, int);
-
-    int attnum( NcToken attname ) const;
-    NcToken attname( int attnum ) const;
-    void init_cur( void );
-
-    // to make variables, since constructor is private
-  friend class NcFile;
-};
-
-
-/*
- * **********************************************************************
- * netCDF attributes.  In addition to a name and a type, these are each
- * associated with a specific variable, or are global to the file.
- * **********************************************************************
- */
-class VTKNETCDFCPP_EXPORT NcAtt : public NcTypedComponent
-{
-  public:
-    virtual ~NcAtt( void ) override;
-    NcToken name( void ) const override;
-    NcType type( void ) const override;
-    NcBool is_valid( void ) const override;
-    long num_vals( void ) const override;
-    NcValues* values( void ) const override;
-    NcBool rename( NcToken newname ) override;
-    NcBool remove( void );
-
-  private:
-    const NcVar* the_variable;
-    char* the_name;
-    // protected constructors because only NcVars and NcFiles create
-    // attributes
-    NcAtt( NcFile*, const NcVar*, NcToken);
-    NcAtt( NcFile*, NcToken); // global attribute
-
-    // To make attributes, since constructor is private
-  friend class NcFile;
-  friend NcAtt* NcVar::get_att( NcToken ) const;
-};
-
-
-/*
- * **********************************************************************
- * To control error handling.  Declaring an NcError object temporarily
- * changes the error-handling behavior until the object is destroyed, at
- * which time the previous error-handling behavior is restored.
- * **********************************************************************
- */
-class VTKNETCDFCPP_EXPORT NcError {
-  public:
-    enum Behavior {
-        silent_nonfatal = 0,
-        silent_fatal = 1,
-        verbose_nonfatal = 2,
-        verbose_fatal = 3
-      };
-
-    // constructor saves previous error state, sets new state
-    NcError( Behavior b = verbose_fatal );
-
-    // destructor restores previous error state
-    virtual ~NcError( void );
-
-    int get_err( void );                 // returns most recent error number
-    const char* get_errmsg( void ) {return nc_strerror(get_err());}
-    static int set_err( int err );
-
-  private:
-    int the_old_state;
-    int the_old_err;
-    static int ncopts;
-    static int ncerr;
-};
-
-#endif                          /* NETCDF_HH */
diff --git a/ThirdParty/netcdfcpp/vtknetcdfcpp/cxx/vtk_netcdfcpp_mangle.h b/ThirdParty/netcdfcpp/vtknetcdfcpp/cxx/vtk_netcdfcpp_mangle.h
deleted file mode 100644
index 7ffa9fc9d59..00000000000
--- a/ThirdParty/netcdfcpp/vtknetcdfcpp/cxx/vtk_netcdfcpp_mangle.h
+++ /dev/null
@@ -1,25 +0,0 @@
-#ifndef NETCDFCPP_MANGLE
-#define NETCDFCPP_MANGLE
-
-#define NcAtt vtknetcdfcpp_NcAtt
-#define NcDim vtknetcdfcpp_NcDim
-#define NcError vtknetcdfcpp_NcError
-#define NcFile vtknetcdfcpp_NcFile
-#define NcTypedComponent vtknetcdfcpp_NcTypedComponent
-#define NcValues vtknetcdfcpp_NcValues
-#define NcValues_ vtknetcdfcpp_NcValues_
-#define NcValues_char vtknetcdfcpp_NcValues_char
-#define NcValues_double vtknetcdfcpp_NcValues_double
-#define NcValues_float vtknetcdfcpp_NcValues_float
-#define NcValues_int vtknetcdfcpp_NcValues_int
-#define NcValues_long vtknetcdfcpp_NcValues_long
-#define NcValues_ncbyte vtknetcdfcpp_NcValues_ncbyte
-#define NcValues_nclong vtknetcdfcpp_NcValues_nclong
-#define NcValues_short vtknetcdfcpp_NcValues_short
-#define NcVar vtknetcdfcpp_NcVar
-
-// Rederictions for the implementation.
-#define vtknetcdfcpp_NcValuesdeclare NcValuesdeclare
-#define vtknetcdfcpp_NcValuesimplement NcValuesimplement
-
-#endif
